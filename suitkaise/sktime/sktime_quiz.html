<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SKTime Mastery Quiz</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }

        .quiz-header {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            text-align: center;
        }

        .quiz-header h1 {
            color: #4a5568;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .quiz-info {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .info-item {
            background: #f7fafc;
            padding: 15px;
            border-radius: 10px;
            margin: 5px;
            border-left: 4px solid #667eea;
        }

        .timer {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #ff6b6b;
            color: white;
            padding: 15px 20px;
            border-radius: 25px;
            font-weight: bold;
            font-size: 1.2em;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            z-index: 1000;
        }

        .timer.warning {
            background: #ff9f43;
            animation: pulse 1s infinite;
        }

        .timer.danger {
            background: #ee5a52;
            animation: pulse 0.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            margin: 20px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #48bb78, #38a169);
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .question-container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            display: none;
        }

        .question-container.active {
            display: block;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 15px;
        }

        .question-number {
            background: #667eea;
            color: white;
            padding: 10px 15px;
            border-radius: 25px;
            font-weight: bold;
        }

        .part-badge {
            background: #48bb78;
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.9em;
        }

        .question-text {
            font-size: 1.2em;
            margin-bottom: 20px;
            color: #2d3748;
        }

        .code-block {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
            overflow-x: auto;
            white-space: pre;
            line-height: 1.4;
            word-wrap: break-word;
        }

        .fill-blanks {
            background: #fffbeb;
            border: 1px solid #f6e05e;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .answer-options {
            margin: 20px 0;
        }

        .answer-option {
            background: #f7fafc;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            padding: 15px 20px;
            margin: 10px 0;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
        }

        .answer-option:hover {
            border-color: #667eea;
            background: #edf2f7;
            transform: translateY(-2px);
        }

        .answer-option.selected {
            border-color: #667eea;
            background: #ebf4ff;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .answer-option.correct {
            border-color: #48bb78;
            background: #f0fff4;
            color: #22543d;
        }

        .answer-option.incorrect {
            border-color: #f56565;
            background: #fffafa;
            color: #742a2a;
        }

        .answer-option input[type="radio"] {
            margin-right: 15px;
            transform: scale(1.2);
        }

        .text-input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 1em;
            margin: 10px 0;
        }

        .text-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            margin-top: 30px;
        }

        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 25px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5a67d8;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #a0aec0;
            color: white;
        }

        .btn-secondary:hover {
            background: #718096;
        }

        .btn:disabled {
            background: #e2e8f0;
            color: #a0aec0;
            cursor: not-allowed;
            transform: none;
        }

        .results-container {
            background: white;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            display: none;
        }

        .results-container.show {
            display: block;
            animation: slideIn 0.5s ease;
        }

        .score-circle {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            margin: 20px auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2em;
            font-weight: bold;
            color: white;
        }

        .score-master { background: linear-gradient(45deg, #ffd700, #ffed4e); color: #744210; }
        .score-expert { background: linear-gradient(45deg, #48bb78, #38a169); }
        .score-proficient { background: linear-gradient(45deg, #4299e1, #3182ce); }
        .score-competent { background: linear-gradient(45deg, #ed8936, #dd6b20); }
        .score-practice { background: linear-gradient(45deg, #f56565, #e53e3e); }

        .score-details {
            margin: 30px 0;
            padding: 20px;
            background: #f7fafc;
            border-radius: 10px;
        }

        .score-breakdown {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .breakdown-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .start-screen {
            background: white;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .start-screen h2 {
            color: #4a5568;
            margin-bottom: 20px;
        }

        .quiz-features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .feature-card {
            background: #f7fafc;
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }

        .emoji {
            font-size: 2em;
            margin-bottom: 10px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .quiz-info {
                flex-direction: column;
            }
            
            .timer {
                position: relative;
                top: auto;
                right: auto;
                margin: 10px auto;
                display: block;
                text-align: center;
            }
            
            .question-header {
                flex-direction: column;
                gap: 10px;
            }
            
            .navigation {
                flex-direction: column;
                gap: 10px;
            }
        }

        .explanation {
            background: #ebf8ff;
            border: 1px solid #90cdf4;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            display: none;
        }

        .explanation.show {
            display: block;
            animation: slideIn 0.3s ease;
        }

        .feedback-correct {
            color: #22543d;
            background: #f0fff4;
            border-color: #9ae6b4;
        }

        .feedback-incorrect {
            color: #742a2a;
            background: #fffafa;
            border-color: #feb2b2;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="timer" id="timer">45:00</div>
        
        <!-- Start Screen -->
        <div id="startScreen" class="start-screen">
            <h1>üß†‚è±Ô∏è SKTime Mastery Quiz</h1>
            <h2>Test Your Comprehensive Understanding of SKTime</h2>
            
            <div class="quiz-features">
                <div class="feature-card">
                    <div class="emoji">üìä</div>
                    <h3>40 Challenging Questions</h3>
                    <p>Comprehensive coverage of all SKTime features and concepts</p>
                </div>
                <div class="feature-card">
                    <div class="emoji">‚è∞</div>
                    <h3>45 Minute Time Limit</h3>
                    <p>Timed assessment to test real-world application skills</p>
                </div>
                <div class="feature-card">
                    <div class="emoji">üéØ</div>
                    <h3>Advanced Difficulty</h3>
                    <p>Covers debugging, optimization, and production scenarios</p>
                </div>
                <div class="feature-card">
                    <div class="emoji">üèÜ</div>
                    <h3>Mastery Certification</h3>
                    <p>80% passing score proves SKTime expertise</p>
                </div>
            </div>
            
            <div class="quiz-info">
                <div class="info-item">
                    <strong>Questions:</strong> 40
                </div>
                <div class="info-item">
                    <strong>Time Limit:</strong> 45 minutes
                </div>
                <div class="info-item">
                    <strong>Passing Score:</strong> 80% (32/40)
                </div>
                <div class="info-item">
                    <strong>Difficulty:</strong> Advanced
                </div>
            </div>
            
            <button class="btn btn-primary" onclick="startQuiz()" style="font-size: 1.2em; padding: 15px 40px;">
                üöÄ Start Quiz
            </button>
        </div>

        <!-- Quiz Header -->
        <div class="quiz-header" id="quizHeader" style="display: none;">
            <h1>üß†‚è±Ô∏è SKTime Mastery Quiz</h1>
            <div class="progress-bar">
                <div class="progress-fill" id="progressBar"></div>
            </div>
            <div class="quiz-info">
                <div class="info-item">
                    <strong>Question:</strong> <span id="currentQuestion">1</span> of 40
                </div>
                <div class="info-item">
                    <strong>Score:</strong> <span id="currentScore">0</span>/40
                </div>
                <div class="info-item">
                    <strong>Time Remaining:</strong> <span id="timeRemaining">45:00</span>
                </div>
            </div>
        </div>

        <!-- Questions will be dynamically generated here -->
        <div id="questionsContainer"></div>

        <!-- Results Screen -->
        <div id="resultsScreen" class="results-container">
            <h1>üéâ Quiz Complete!</h1>
            <div class="score-circle" id="scoreCircle">
                <span id="finalScore">0/40</span>
            </div>
            <h2 id="scoreTitle">Your Result</h2>
            <p id="scoreDescription">Description of performance</p>
            
            <div class="score-details">
                <div class="score-breakdown">
                    <div class="breakdown-item">
                        <h3 id="part1Score">Part I: Core Concepts</h3>
                        <p>0/10 questions correct</p>
                    </div>
                    <div class="breakdown-item">
                        <h3 id="part2Score">Part II: Decorators</h3>
                        <p>0/10 questions correct</p>
                    </div>
                    <div class="breakdown-item">
                        <h3 id="part3Score">Part III: Advanced Features</h3>
                        <p>0/10 questions correct</p>
                    </div>
                    <div class="breakdown-item">
                        <h3 id="part4Score">Part IV: Best Practices</h3>
                        <p>0/10 questions correct</p>
                    </div>
                </div>
                
                <div style="margin-top: 20px;">
                    <p><strong>Time Taken:</strong> <span id="timeTaken">0:00</span></p>
                    <p><strong>Percentage:</strong> <span id="percentage">0%</span></p>
                </div>
            </div>

            <div class="navigation">
                <button class="btn btn-secondary" onclick="reviewAnswers()">üìã Review Answers</button>
                <button class="btn btn-primary" onclick="restartQuiz()">üîÑ Retake Quiz</button>
            </div>
        </div>
    </div>

    <script>
        // Quiz data and state
        let currentQuestionIndex = 0;
        let userAnswers = [];
        let score = 0;
        let timeRemaining = 45 * 60; // 45 minutes in seconds
        let timerInterval;
        let quizStartTime;
        let partScores = [0, 0, 0, 0]; // Scores for each part

        // Quiz questions data
        const quizData = [
            // Part I: Core Concepts (Questions 1-10)
            {
                part: "I: Core Concepts",
                question: "What will this code output?",
                code: `from suitkaise.sktime import fmttime
print(fmttime(3661.5))`,
                type: "multiple",
                options: [
                    '"3661.5s"',
                    '"1h 1m 1.50s"',
                    '"61m 1.50s"',
                    '"1:01:01.5"'
                ],
                correct: 1,
                explanation: "fmttime() formats durations into human-readable format. 3661.5 seconds = 1 hour + 1 minute + 1.5 seconds."
            },
            {
                part: "I: Core Concepts",
                question: "Which Timer method allows you to get the current elapsed time WITHOUT stopping the timer?",
                type: "multiple",
                options: [
                    "current_time()",
                    "get_elapsed()",
                    "get_current_time()",
                    "peek_time()"
                ],
                correct: 2,
                explanation: "get_current_time() returns the current elapsed time without stopping the timer."
            },
            {
                part: "I: Core Concepts",
                question: "Complete this code to create a Timer that records lap times and handles pauses correctly:",
                code: `with Timer() as timer:
    work_phase_1()
    timer.___("phase 1")
    
    timer.___()  # Pause timing
    break_time()  # This shouldn't count
    timer.___()  # Resume timing
    
    work_phase_2()
    timer.___("phase 2")

# Get the lap that took the longest
longest_lap = max(timer.get_laps(), key=lambda lap: lap.___)`,
                type: "fill",
                blanks: 5,
                correct: ["lap", "pause", "resume", "lap", "lap_time"],
                explanation: "Use lap() to record checkpoints, pause()/resume() for timing control, and lap_time attribute for lap duration."
            },
            {
                part: "I: Core Concepts",
                question: "What's wrong with this code?",
                code: `timer = Timer()
timer.start()
do_work()
timer.pause()
break_time()
elapsed = timer.stop()  # What happens here?`,
                type: "multiple",
                options: [
                    "Nothing wrong",
                    "stop() will raise an error because timer is paused",
                    "Break time included in duration",
                    "Timer wasn't initialized properly"
                ],
                correct: 1,
                explanation: "You cannot stop() a timer while it's paused. You must resume() first."
            },
            {
                part: "I: Core Concepts",
                question: "Which fmtdate() call will output \"2 hours ago\"?",
                code: `from suitkaise.sktime import fmtdate, now, date_ago

current = now()
two_hours_ago = date_ago(hours=2)`,
                type: "multiple",
                options: [
                    'fmtdate(two_hours_ago, style="relative")',
                    'fmtdate(two_hours_ago)',
                    'fmtdate(two_hours_ago, reference_time=current)',
                    'All of the above'
                ],
                correct: 3,
                explanation: "All options work because fmtdate() defaults to relative style, and reference_time defaults to now()."
            },
            {
                part: "I: Core Concepts",
                question: "What does the elapsed() function return if end_time < start_time?",
                type: "multiple",
                options: [
                    "Negative number",
                    "Positive number (absolute difference)",
                    "Zero",
                    "Raises SKTimeError"
                ],
                correct: 3,
                explanation: "elapsed() raises SKTimeError when end_time < start_time to prevent logical errors."
            },
            {
                part: "I: Core Concepts",
                question: "Complete the code to format a timestamp as \"2025-01-15 14:30\":",
                code: `from suitkaise.sktime import fmtdate, now

timestamp = now()
formatted = fmtdate(timestamp, style="___", custom_format="___")`,
                type: "fill",
                blanks: 2,
                correct: ["custom", "%Y-%m-%d %H:%M"],
                explanation: "Use style='custom' with strftime format '%Y-%m-%d %H:%M' for the desired output."
            },
            {
                part: "I: Core Concepts",
                question: "Which statement about parse_human_date() is TRUE?",
                type: "multiple",
                options: [
                    "It only accepts ISO format strings",
                    "It returns a formatted date string",
                    "It returns a timestamp (float) or None",
                    "It raises an error for invalid input"
                ],
                correct: 2,
                explanation: "parse_human_date() returns a timestamp (float) if successful, or None if parsing fails."
            },
            {
                part: "I: Core Concepts",
                question: "What happens if you call timer.get_current_time() before calling timer.start()?",
                type: "multiple",
                options: [
                    "Returns 0.0",
                    "Returns None",
                    "Raises RuntimeError",
                    "Returns current timestamp"
                ],
                correct: 2,
                explanation: "get_current_time() raises RuntimeError if the timer hasn't been started."
            },
            {
                part: "I: Core Concepts",
                question: "Fill in the missing time units for fmttime():",
                code: `0.003 seconds ‚Üí ___
75 seconds ‚Üí ___
86400 seconds ‚Üí ___`,
                type: "fill",
                blanks: 3,
                correct: ["3.00ms", "1m 15.00s", "1d 0h 0m 0.00s"],
                explanation: "fmttime() automatically chooses appropriate units: milliseconds, minutes/seconds, days/hours/minutes/seconds."
            },

            // Part II: Decorators & Advanced Timing (Questions 11-20)
            {
                part: "II: Decorators",
                question: "Fix this @timethis decorator usage:",
                code: `@timethis(store_in_global="my_func_timing", track_calls=True, return_timing=True)
def my_function(x, y):
    return x + y

result = my_function(1, 2)  # What does result contain?`,
                type: "multiple",
                options: [
                    "3",
                    "(3, timing_info)",
                    "{'result': 3, 'timing': timing_info}",
                    "The code has an error"
                ],
                correct: 1,
                explanation: "With return_timing=True, @timethis returns a tuple: (original_result, timing_info)."
            },
            {
                part: "II: Decorators",
                question: "Complete this code to track API call performance across multiple processes:",
                code: `from suitkaise.sktime import timethis, get_timing_registry

api_registry = get_timing_registry("___")

@timethis(callback=api_registry.___, track_calls=___)
def api_call(endpoint):
    return make_request(endpoint)

# Later, in another process, access the same data:
same_registry = get_timing_registry("___")
stats = same_registry.get_function_stats("___")`,
                type: "fill",
                blanks: 5,
                correct: ["api_calls", "record_timing", "True", "api_calls", "api_call"],
                explanation: "Use same registry name across processes, record_timing callback, track_calls=True, and function name for stats."
            },
            {
                part: "II: Decorators",
                question: "What's the difference between these two decorators?",
                code: `@time_function
def func1():
    pass

@timethis(print_result=True)
def func2():
    pass`,
                type: "multiple",
                options: [
                    "No difference",
                    "@time_function stores timing data, @timethis doesn't",
                    "@timethis stores timing data, @time_function doesn't",
                    "@time_function uses different time formatting"
                ],
                correct: 2,
                explanation: "@timethis stores timing data on the function and in registries, while @time_function only prints results."
            },
            {
                part: "II: Decorators",
                question: "Debug this rate limiter: How many calls will execute immediately without waiting?",
                code: `@rate_limiter(max_calls_per_second=2.0, burst_size=5)
def api_call():
    return "response"

# Call 10 times rapidly
for i in range(10):
    print(f"Call {i}: {api_call()}")`,
                type: "multiple",
                options: [
                    "2",
                    "5",
                    "10",
                    "Depends on timing"
                ],
                correct: 1,
                explanation: "burst_size=5 allows 5 immediate calls, then rate limiting kicks in."
            },
            {
                part: "II: Decorators",
                question: "Complete this @profile_function_calls usage:",
                code: `@profile_function_calls(print_stats=True, track_memory=False)
def monitored_func():
    return "result"

# Call 150 times
for i in range(150):
    monitored_func()

# Get statistics
stats = monitored_func.___()
print(f"Average time: {stats['___']}")`,
                type: "fill",
                blanks: 2,
                correct: ["get_stats", "avg_time"],
                explanation: "Use get_stats() method to retrieve statistics, avg_time key for average duration."
            },
            {
                part: "II: Decorators",
                question: "What happens with this @timethis configuration?",
                code: `@timethis(
    store_in_global="test",
    return_timing=True,
    store_on_function=False,
    track_calls=False
)
def test_func():
    return "result"

result = test_func()
last_timing = test_func.get_last_timing()  # What does this return?`,
                type: "multiple",
                options: [
                    "The timing info",
                    "None",
                    "Raises AttributeError",
                    "Empty dict"
                ],
                correct: 1,
                explanation: "With store_on_function=False, no timing methods are added to the function, so get_last_timing() returns None."
            },
            {
                part: "II: Decorators",
                question: "Fix this callback usage:",
                code: `def custom_callback(timing_info):
    print(f"Function {timing_info['___']} took {timing_info['___']:.3f}s")

@timethis(callback=custom_callback, print_result=False)
def slow_func():
    sleep(1)
    return "done"`,
                type: "fill",
                blanks: 2,
                correct: ["function_name", "duration"],
                explanation: "Timing info contains 'function_name' and 'duration' keys among others."
            },
            {
                part: "II: Decorators",
                question: "What's wrong with this decorator combination?",
                code: `@rate_limiter(max_calls_per_second=1.0)
@timethis(track_calls=True)
def limited_func():
    return "result"`,
                type: "multiple",
                options: [
                    "Nothing wrong",
                    "Decorators are in wrong order",
                    "Can't combine these decorators",
                    "Need to set auto_sync=False"
                ],
                correct: 0,
                explanation: "Nothing wrong - decorators can be combined and order doesn't matter for these two."
            },
            {
                part: "II: Decorators",
                question: "Complete this advanced @timethis usage:",
                code: `@timethis(
    store_in_global="api_stats",
    track_calls=True,
    callback=lambda t: print(f"Call #{t['___']}"),
    return_timing=False,
    store_on_function=True
)
def api_endpoint():
    return "response"

# Access all timing data later
all_timings = api_endpoint.___()
call_count = len(all_timings)`,
                type: "fill",
                blanks: 2,
                correct: ["call_number", "get_all_timings"],
                explanation: "Use 'call_number' from timing info and get_all_timings() method to access all recorded timings."
            },
            {
                part: "II: Decorators",
                question: "What does timeout_after() decorator do if a function times out?",
                type: "multiple",
                options: [
                    "Returns None",
                    "Returns partial results",
                    "Raises SKTimeError",
                    "Logs error and continues"
                ],
                correct: 2,
                explanation: "timeout_after() raises SKTimeError when the timeout is exceeded."
            },

            // Part III: Advanced Features & Integration (Questions 21-30)
            {
                part: "III: Advanced Features",
                question: "Complete this SharedTimer implementation:",
                code: `from suitkaise.sktime import create_shared_timer

# Process 1
shared_timer = create_shared_timer("batch_job")
shared_timer.start()
shared_timer.lap("initialization")

# Process 2 - check status
monitor = create_shared_timer("___")
status = monitor.___()
if status and status['___']:
    print(f"Job running for: {status['___']}")`,
                type: "fill",
                blanks: 4,
                correct: ["batch_job", "get_shared_status", "is_running", "elapsed_time"],
                explanation: "Use same timer name, get_shared_status() method, check is_running flag, access elapsed_time."
            },
            {
                part: "III: Advanced Features",
                question: "Debug this TimingRegistry usage - what import is missing?",
                code: `from suitkaise.sktime import get_timing_registry

registry = get_timing_registry("my_funcs")

# Record some timing data manually
registry.record_timing({
    'function_name': 'test_func',
    'duration': 1.5,
    'success': True,
    'timestamp': now()
})

# Find slow functions
slow_funcs = registry.find_functions(
    lambda name, timings: statistics.mean([t['duration'] for t in timings]) > 1.0
)`,
                type: "multiple",
                options: [
                    "from statistics import mean",
                    "import statistics",
                    "from suitkaise.sktime import now",
                    "Both B and C"
                ],
                correct: 3,
                explanation: "Need both 'import statistics' for statistics.mean() and 'from suitkaise.sktime import now' for now()."
            },
            {
                part: "III: Advanced Features",
                question: "Complete this cross-process timing scenario:",
                code: `# Process 1: Record data
api_registry = get_timing_registry("api_calls")
api_registry.sync_to_skglobal("___")

# Process 2: Load data
new_registry = get_timing_registry("___")  # Different name OK?
new_registry.load_from_skglobal("___")

# Will new_registry have the data from Process 1?`,
                type: "multiple",
                options: [
                    "Yes, if names match exactly",
                    "Yes, regardless of registry names",
                    "No, data is process-specific",
                    "Only if using same SKGlobal key"
                ],
                correct: 1,
                explanation: "Registry names don't matter for SKGlobal sync - the SKGlobal key is what matters for data sharing."
            },
            {
                part: "III: Advanced Features",
                question: "What's the output of this benchmark? How many times was quick_func actually called?",
                code: `from suitkaise.sktime import benchmark

def quick_func():
    return sum(range(100))

results = benchmark(quick_func, iterations=1000, warmup=100)
print(f"Ops/sec: {results['ops_per_second']:.0f}")`,
                type: "multiple",
                options: [
                    "1000",
                    "1100",
                    "100",
                    "2000"
                ],
                correct: 1,
                explanation: "benchmark() calls the function during warmup (100) plus iterations (1000) = 1100 total calls."
            },
            {
                part: "III: Advanced Features",
                question: "Fix this skglobal_timing_context usage - what key stores the timing data?",
                code: `with skglobal_timing_context("data_processing", store_results=True) as timer:
    process_data()
    timer.lap("processing")
    save_data()

# Where is the timing data stored?
from suitkaise.sktime import get_global_timing
data = get_global_timing("___")  # What key?`,
                type: "fill",
                blanks: 1,
                correct: ["timing_data_processing"],
                explanation: "skglobal_timing_context stores data with 'timing_' prefix plus the provided name."
            },
            {
                part: "III: Advanced Features",
                question: "Complete this performance analysis:",
                code: `registry = get_timing_registry("analysis")

# Get top 5 functions by call count
busiest = registry.get_top_functions(limit=5, sort_by="___")

# Get top 5 functions by average time
slowest = registry.get_top_functions(limit=5, sort_by="___")

# Find functions with > 100 calls AND > 500ms average
problematic = registry.find_functions(
    lambda name, timings: (
        len(timings) > 100 and
        statistics.mean([t['___'] for t in timings]) > 0.5
    )
)`,
                type: "fill",
                blanks: 3,
                correct: ["call_count", "avg_time", "duration"],
                explanation: "Use 'call_count' and 'avg_time' for sorting, 'duration' key in timing records."
            },
            {
                part: "III: Advanced Features",
                question: "What happens with this RateMonitor? Which rate will be higher?",
                code: `from suitkaise.sktime import RateMonitor

monitor = RateMonitor(window_size=5.0)  # 5-second window

# Record 100 operations instantly
for i in range(100):
    monitor.tick()

current_rate = monitor.get_current_rate()
average_rate = monitor.get_average_rate()`,
                type: "multiple",
                options: [
                    "current_rate",
                    "average_rate",
                    "They'll be equal",
                    "Depends on timing precision"
                ],
                correct: 0,
                explanation: "current_rate measures recent activity (100 ops in ~0 time = very high), average_rate considers entire lifetime."
            },
            {
                part: "III: Advanced Features",
                question: "Debug this PerformanceTracker usage - what's missing?",
                code: `from suitkaise.sktime import PerformanceTracker

tracker = PerformanceTracker("API calls")

with tracker.time_operation("user_login") as timing:
    result = authenticate_user()
    timing.add_metadata(user_id=result.user_id, success=result.success)

stats = tracker.get_statistics()
print(f"Average time: {stats['avg_time']}")`,
                type: "multiple",
                options: [
                    "Nothing missing",
                    "Need to call tracker.finalize()",
                    "Need from suitkaise.sktime import now",
                    "PerformanceTracker doesn't exist in this module"
                ],
                correct: 3,
                explanation: "PerformanceTracker is not part of the SKTime module in this implementation."
            },
            {
                part: "III: Advanced Features",
                question: "Complete this timing comparison - how are results ordered?",
                code: `from suitkaise.sktime import compare_functions

def method_a(data):
    return sorted(data, reverse=True)

def method_b(data):
    return list(reversed(sorted(data)))

results = compare_functions(
    method_a, method_b,
    iterations=1000,
    data=list(range(1000))
)

# Which method info is in results?
fastest_method = list(results.keys())[0]  # Gets first result`,
                type: "multiple",
                options: [
                    "Alphabetically by function name",
                    "By fastest average time first",
                    "By order of function arguments",
                    "Random order"
                ],
                correct: 1,
                explanation: "compare_functions() sorts results by fastest average time first for easy comparison."
            },
            {
                part: "III: Advanced Features",
                question: "What's wrong with this date range usage?",
                code: `from suitkaise.sktime import date_range, date_ago, fmtdate

start = date_ago(days=7)
end = date_ago(days=1)  # 1 day ago

dates = date_range(start, end, step_days=1)
for date in dates:
    print(fmtdate(date, style="date_only"))`,
                type: "multiple",
                options: [
                    "Nothing wrong",
                    "Start and end are swapped",
                    "Need to use now() for end",
                    "step_days should be negative"
                ],
                correct: 0,
                explanation: "Nothing wrong - date_range() automatically handles when start > end by swapping them internally."
            },

            // Part IV: Debugging & Best Practices (Questions 31-40)
            {
                part: "IV: Best Practices",
                question: "Fix this broken timing code:",
                code: `timer = Timer()
timer.start()
process_data()
timer.pause()
take_break()
# Forgot to resume!
duration = timer.stop()  # What happens?`,
                type: "multiple",
                options: [
                    "Works fine, break time excluded",
                    "Raises RuntimeError",
                    "Break time included in duration",
                    "Returns None"
                ],
                correct: 1,
                explanation: "Calling stop() on a paused timer raises RuntimeError. Must resume() first."
            },
            {
                part: "IV: Best Practices",
                question: "What's the best approach for this scenario: You need to time 50 different functions across 5 different modules and analyze performance patterns across modules.",
                type: "multiple",
                options: [
                    "Use 50 separate @timethis decorators",
                    "Create 5 module-specific TimingRegistries",
                    "Use one global TimingRegistry for everything",
                    "Manual timing with Timer class"
                ],
                correct: 1,
                explanation: "Module-specific registries provide organization while enabling cross-module analysis through registry comparison."
            },
            {
                part: "IV: Best Practices",
                question: "Debug this cross-process timing issue:",
                code: `# Process 1
@timethis(store_in_global="shared_timing", auto_sync=True)  # Error here?
def shared_func():
    return "result"

shared_func()

# Process 2
timing_data = get_global_timing("shared_timing")
print(timing_data)  # Returns None - why?`,
                type: "multiple",
                options: [
                    "auto_sync is not a valid parameter",
                    "Need to use track_calls=True",
                    "SKGlobal storage takes time to sync",
                    "Missing import"
                ],
                correct: 0,
                explanation: "auto_sync is not a valid parameter for @timethis decorator."
            },
            {
                part: "IV: Best Practices",
                question: "Complete this error handling pattern:",
                code: `@timethis(track_calls=True)
def risky_operation():
    if random.random() < 0.3:
        raise ValueError("Random failure")
    return "success"

# Call 100 times
for i in range(100):
    try:
        risky_operation()
    except ValueError:
        pass

stats = risky_operation.get_timing_stats()
print(f"Success rate: {stats['___']:.1%}")
print(f"Failed calls: {stats['___']}")`,
                type: "fill",
                blanks: 2,
                correct: ["success_rate", "failure_count"],
                explanation: "@timethis tracks both successful and failed calls, providing success_rate and failure_count in statistics."
            },
            {
                part: "IV: Best Practices",
                question: "What's wrong with this timing measurement?",
                code: `import time

# Measuring sleep accuracy
with Timer() as timer:
    time.sleep(1.0)  # Should be exactly 1 second

measured = timer.elapsed_time
print(f"Measured: {measured:.3f}s")

# measured is usually 1.001-1.005 seconds - why?`,
                type: "multiple",
                options: [
                    "Timer is inaccurate",
                    "System sleep is not precise",
                    "Context manager overhead",
                    "Clock resolution issues"
                ],
                correct: 1,
                explanation: "System sleep() calls are not precise due to OS scheduling and other system factors."
            },
            {
                part: "IV: Best Practices",
                question: "Fix this memory issue: This code runs in a long-running service. Memory usage keeps growing - why?",
                code: `# This code runs in a long-running service
registry = get_timing_registry("service_calls")

@timethis(callback=registry.record_timing, track_calls=True)
def service_call():
    return "result"

# Called millions of times over weeks
# Memory usage keeps growing - why?`,
                type: "multiple",
                options: [
                    "TimingRegistry has memory leaks",
                    "Unlimited timing data accumulation",
                    "SKGlobal storage issues",
                    "Decorator overhead"
                ],
                correct: 1,
                explanation: "Timing data accumulates indefinitely without cleanup, causing memory growth in long-running services."
            },
            {
                part: "IV: Best Practices",
                question: "Complete this performance optimization: You have 1000 functions to time, but timing overhead is affecting performance. The best approach is:",
                type: "multiple",
                options: [
                    "Use track_calls=False to reduce overhead",
                    "Implement custom sampling in callback",
                    "Use @time_function instead",
                    "No good solution in SKTime"
                ],
                correct: 1,
                explanation: "Custom sampling in the callback allows you to record only a percentage of calls, reducing overhead while maintaining useful data."
            },
            {
                part: "IV: Best Practices",
                question: "Debug this date formatting issue:",
                code: `from suitkaise.sktime import fmtdate

timestamp = "2025-01-15T14:30:00Z"
formatted = fmtdate(timestamp, style="relative")
print(formatted)  # Outputs unexpected result`,
                type: "multiple",
                options: [
                    "String timestamps not supported",
                    "Need to specify timezone",
                    "ISO format requires parsing",
                    'style="relative" needs reference_time'
                ],
                correct: 0,
                explanation: "fmtdate() expects float timestamps or datetime objects, not string timestamps directly."
            },
            {
                part: "IV: Best Practices",
                question: "What's the thread safety issue here?",
                code: `# Multiple threads using the same registry
registry = get_timing_registry("shared")

def worker_thread(thread_id):
    @timethis(callback=registry.record_timing)
    def thread_work():
        return f"work from thread {thread_id}"
    
    for i in range(1000):
        thread_work()

# Start 10 threads
threads = [threading.Thread(target=worker_thread, args=(i,)) for i in range(10)]
for t in threads:
    t.start()`,
                type: "multiple",
                options: [
                    "No issues - SKTime is thread-safe",
                    "Registry corruption possible",
                    "Decorator conflicts between threads",
                    "Timing data will be inaccurate"
                ],
                correct: 0,
                explanation: "SKTime is designed to be thread-safe, using proper locking mechanisms in registries and timers."
            },
            {
                part: "IV: Best Practices",
                question: "Complete this production monitoring setup:",
                code: `class ProductionMonitor:
    def __init__(self):
        self.registry = get_timing_registry("___")
        self.sample_rate = 0.01
    
    def monitor_function(self, func):
        def sampling_callback(timing_info):
            if random.random() < self.sample_rate:
                self.registry.___
        
        return timethis(
            callback=sampling_callback,
            track_calls=___,
            store_in_global="___",
            print_result=___
        )(func)
    
    def check_alerts(self):
        slow_functions = self.registry.find_functions(
            lambda name, timings: 
                len(timings) > 10 and
                statistics.mean([t['duration'] for t in timings]) > ___  # 1 second threshold
        )
        return slow_functions`,
                type: "fill",
                blanks: 6,
                correct: ["production", "record_timing(timing_info)", "True", "production_monitoring", "False", "1.0"],
                explanation: "Production setup needs meaningful names, sampling callback, call tracking, global storage, quiet operation, and performance thresholds."
            }
        ];

        function startQuiz() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('quizHeader').style.display = 'block';
            
            quizStartTime = Date.now();
            startTimer();
            generateQuestions();
            showQuestion(0);
        }

        function startTimer() {
            updateTimerDisplay();
            timerInterval = setInterval(() => {
                timeRemaining--;
                updateTimerDisplay();
                
                if (timeRemaining <= 0) {
                    clearInterval(timerInterval);
                    finishQuiz();
                }
            }, 1000);
        }

        function updateTimerDisplay() {
            const minutes = Math.floor(timeRemaining / 60);
            const seconds = timeRemaining % 60;
            const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            document.getElementById('timer').textContent = timeString;
            document.getElementById('timeRemaining').textContent = timeString;
            
            // Change timer color based on remaining time
            const timerElement = document.getElementById('timer');
            if (timeRemaining <= 300) { // 5 minutes
                timerElement.className = 'timer danger';
            } else if (timeRemaining <= 600) { // 10 minutes
                timerElement.className = 'timer warning';
            } else {
                timerElement.className = 'timer';
            }
        }

        function generateQuestions() {
            const container = document.getElementById('questionsContainer');
            container.innerHTML = '';

            quizData.forEach((q, index) => {
                const questionDiv = document.createElement('div');
                questionDiv.className = 'question-container';
                questionDiv.id = `question-${index}`;

                let optionsHTML = '';
                let navigationHTML = '';

                if (q.type === 'multiple') {
                    optionsHTML = `
                        <div class="answer-options">
                            ${q.options.map((option, optIndex) => `
                                <div class="answer-option" onclick="selectAnswer(${index}, ${optIndex})">
                                    <input type="radio" name="q${index}" value="${optIndex}">
                                    <span>${option}</span>
                                </div>
                            `).join('')}
                        </div>
                    `;
                } else if (q.type === 'fill') {
                    optionsHTML = `
                        <div class="fill-blanks">
                            <p><strong>Fill in the blanks:</strong></p>
                            ${Array.from({length: q.blanks}, (_, i) => `
                                <input type="text" class="text-input" placeholder="Blank ${i + 1}" 
                                       onchange="updateFillAnswer(${index}, ${i}, this.value)">
                            `).join('')}
                        </div>
                    `;
                }

                navigationHTML = `
                    <div class="navigation">
                        <button class="btn btn-secondary" onclick="previousQuestion()" 
                                ${index === 0 ? 'style="visibility: hidden;"' : ''}>
                            ‚Üê Previous
                        </button>
                        <button class="btn btn-primary" onclick="nextQuestion()">
                            ${index === quizData.length - 1 ? 'Finish Quiz' : 'Next ‚Üí'}
                        </button>
                    </div>
                `;

                questionDiv.innerHTML = `
                    <div class="question-header">
                        <span class="question-number">Question ${index + 1}</span>
                        <span class="part-badge">Part ${q.part}</span>
                    </div>
                    <div class="question-text">${q.question}</div>
                    ${q.code ? `<pre class="code-block">${q.code}</pre>` : ''}
                    ${optionsHTML}
                    <div class="explanation" id="explanation-${index}">
                        <strong>Explanation:</strong> ${q.explanation}
                    </div>
                    ${navigationHTML}
                `;

                container.appendChild(questionDiv);
            });

            // Initialize user answers array
            userAnswers = new Array(quizData.length).fill(null);
        }

        function selectAnswer(questionIndex, answerIndex) {
            userAnswers[questionIndex] = answerIndex;
            
            // Update UI
            const options = document.querySelectorAll(`#question-${questionIndex} .answer-option`);
            options.forEach((option, index) => {
                option.classList.remove('selected');
                if (index === answerIndex) {
                    option.classList.add('selected');
                    option.querySelector('input').checked = true;
                }
            });
            
            updateScore();
        }

        function updateFillAnswer(questionIndex, blankIndex, value) {
            if (!userAnswers[questionIndex]) {
                userAnswers[questionIndex] = new Array(quizData[questionIndex].blanks).fill('');
            }
            userAnswers[questionIndex][blankIndex] = value.trim();
            updateScore();
        }

        function updateScore() {
            let correctAnswers = 0;
            partScores = [0, 0, 0, 0];

            quizData.forEach((q, index) => {
                const userAnswer = userAnswers[index];
                let isCorrect = false;

                if (q.type === 'multiple') {
                    isCorrect = userAnswer === q.correct;
                } else if (q.type === 'fill') {
                    if (Array.isArray(userAnswer) && Array.isArray(q.correct)) {
                        isCorrect = userAnswer.length === q.correct.length && 
                                   userAnswer.every((ans, i) => 
                                       ans.toLowerCase() === q.correct[i].toLowerCase());
                    }
                }

                if (isCorrect) {
                    correctAnswers++;
                    // Update part scores
                    if (index < 10) partScores[0]++;
                    else if (index < 20) partScores[1]++;
                    else if (index < 30) partScores[2]++;
                    else partScores[3]++;
                }
            });

            score = correctAnswers;
            document.getElementById('currentScore').textContent = score;
        }

        function showQuestion(index) {
            // Hide all questions
            document.querySelectorAll('.question-container').forEach(q => {
                q.classList.remove('active');
            });

            // Show current question
            document.getElementById(`question-${index}`).classList.add('active');
            
            // Update progress
            currentQuestionIndex = index;
            document.getElementById('currentQuestion').textContent = index + 1;
            
            const progress = ((index + 1) / quizData.length) * 100;
            document.getElementById('progressBar').style.width = `${progress}%`;
        }

        function nextQuestion() {
            if (currentQuestionIndex < quizData.length - 1) {
                showQuestion(currentQuestionIndex + 1);
            } else {
                finishQuiz();
            }
        }

        function previousQuestion() {
            if (currentQuestionIndex > 0) {
                showQuestion(currentQuestionIndex - 1);
            }
        }

        function finishQuiz() {
            clearInterval(timerInterval);
            
            const timeTaken = Math.floor((Date.now() - quizStartTime) / 1000);
            updateScore(); // Final score calculation
            
            // Hide quiz elements
            document.getElementById('quizHeader').style.display = 'none';
            document.getElementById('questionsContainer').style.display = 'none';
            
            // Show results
            showResults(timeTaken);
        }

        function showResults(timeTaken) {
            const percentage = Math.round((score / quizData.length) * 100);
            
            // Determine score level and styling
            let scoreTitle, scoreDescription, scoreClass;
            if (score >= 36) {
                scoreTitle = "üèÜ SKTime Master";
                scoreDescription = "Outstanding! You have complete mastery of SKTime.";
                scoreClass = "score-master";
            } else if (score >= 32) {
                scoreTitle = "ü•á SKTime Expert";
                scoreDescription = "Excellent! You have very strong knowledge of SKTime.";
                scoreClass = "score-expert";
            } else if (score >= 28) {
                scoreTitle = "ü•à SKTime Proficient";
                scoreDescription = "Good work! You have solid working knowledge of SKTime.";
                scoreClass = "score-proficient";
            } else if (score >= 24) {
                scoreTitle = "ü•â SKTime Competent";
                scoreDescription = "You have basic competence in SKTime. Consider more practice.";
                scoreClass = "score-competent";
            } else {
                scoreTitle = "üìö Need More Practice";
                scoreDescription = "You should review the SKTime documentation and try again.";
                scoreClass = "score-practice";
            }

            // Update results display
            document.getElementById('finalScore').textContent = `${score}/40`;
            document.getElementById('scoreTitle').textContent = scoreTitle;
            document.getElementById('scoreDescription').textContent = scoreDescription;
            document.getElementById('scoreCircle').className = `score-circle ${scoreClass}`;
            document.getElementById('percentage').textContent = `${percentage}%`;
            
            const minutes = Math.floor(timeTaken / 60);
            const seconds = timeTaken % 60;
            document.getElementById('timeTaken').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;

            // Update part scores
            document.getElementById('part1Score').innerHTML = `Part I: Core Concepts<br><small>${partScores[0]}/10 questions correct</small>`;
            document.getElementById('part2Score').innerHTML = `Part II: Decorators<br><small>${partScores[1]}/10 questions correct</small>`;
            document.getElementById('part3Score').innerHTML = `Part III: Advanced Features<br><small>${partScores[2]}/10 questions correct</small>`;
            document.getElementById('part4Score').innerHTML = `Part IV: Best Practices<br><small>${partScores[3]}/10 questions correct</small>`;

            // Show results screen
            document.getElementById('resultsScreen').classList.add('show');
        }

        function reviewAnswers() {
            // Show all questions with answers revealed
            document.getElementById('resultsScreen').style.display = 'none';
            document.getElementById('questionsContainer').style.display = 'block';
            
            // Mark all answers and show explanations
            quizData.forEach((q, index) => {
                const questionDiv = document.getElementById(`question-${index}`);
                const userAnswer = userAnswers[index];
                
                if (q.type === 'multiple') {
                    const options = questionDiv.querySelectorAll('.answer-option');
                    options.forEach((option, optIndex) => {
                        if (optIndex === q.correct) {
                            option.classList.add('correct');
                        } else if (optIndex === userAnswer && optIndex !== q.correct) {
                            option.classList.add('incorrect');
                        }
                    });
                } else if (q.type === 'fill') {
                    const inputs = questionDiv.querySelectorAll('.text-input');
                    inputs.forEach((input, inputIndex) => {
                        input.value = userAnswers[index]?.[inputIndex] || '';
                        if (userAnswers[index]?.[inputIndex]?.toLowerCase() === q.correct[inputIndex]?.toLowerCase()) {
                            input.style.borderColor = '#48bb78';
                            input.style.backgroundColor = '#f0fff4';
                        } else {
                            input.style.borderColor = '#f56565';
                            input.style.backgroundColor = '#fffafa';
                        }
                    });
                    
                    // Show correct answers
                    const correctAnswersDiv = document.createElement('div');
                    correctAnswersDiv.className = 'explanation show feedback-correct';
                    correctAnswersDiv.innerHTML = `<strong>Correct answers:</strong> ${q.correct.join(', ')}`;
                    questionDiv.appendChild(correctAnswersDiv);
                }
                
                // Show explanation
                document.getElementById(`explanation-${index}`).classList.add('show');
            });
            
            showQuestion(0);
        }

        function restartQuiz() {
            // Reset all state
            currentQuestionIndex = 0;
            userAnswers = [];
            score = 0;
            timeRemaining = 45 * 60;
            partScores = [0, 0, 0, 0];
            
            // Reset UI
            document.getElementById('resultsScreen').classList.remove('show');
            document.getElementById('startScreen').style.display = 'block';
            
            // Clear timer
            if (timerInterval) {
                clearInterval(timerInterval);
            }
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Quiz starts with the start screen visible
        });
    </script>
</body>
</html>