an idea for a dynamic ui builder

I want to make a ui system that allows me and eventually the user to create and edit ui components
in an easy to understand, visual manner. 

from color, to shape, to text, to animation, to layout, I want full control over
making components, creating themes, animating components, and creating layouts.

The system.

First, I want to have a custom color manager that allows me to create, save, and load colors,
as well as put colors together to create palettes. 

SKColor: a class instance that represents a color.

- name: 'Pine Green'
- hex: '#01796F'

modifying SKColors

i want to be able to modify colors
- make them lighter
- make them darker
- change alpha value (opacity)
- get the contrast color
- n% more (color) ex. 10% more red
- n% less (color) ex. 10% less red

I will register some colors automatically. these will be Suitkaise.color colors, and
will be defaulted to if no SKColor created by the user has the same name.

users can save their own colors, which will be saved in a json file
that will be loaded when the app starts, registering just like the default colors.

you can remove colors.


SKComponent: a class instance that represents a single ui component.
Lets take a slider for example.

A slider has 2 specific parts: the track and the thumb.
And one general function: change a value as the thumb moves across the track.

But there are some differences between sliders...
- length. some sliders are just 2 steps, and are used to toggle settings and any other yes/no
  values. (ex. apple settings slider)
- some sliders are more than 2 steps, and are used to change values. (ex. volume slider)
- sliders can spread across any angle (horizontal, vertical, diagonal, 
    right and down at a 35 degree angle, etc.)
- the thumb can be any shape, and be housed completely inside the track, or
    expand outside the track (apple settings slider vs a volume slider)
- the thumb can look like anything, and be any size, within reason.
- the track should generally be a line (really thin rectangle), but the ends of the line can
    be rounded, or square, or make the track look trapezoidal...
- the track can be any color, and the thumb can be any color, and both could have multiple colors
    (ex. a gradient, or a pattern)
- they can have a shadow, border, glow, or other effect, and the effect could even be animated.

so how do we balance creative freedom with ease of use?

boil it down to the most necessary parts, and let the user customize the rest.

for a slider, we need 2-3 things:
- a track
- a thumb
- a boundary (what are the bounds of this slider?)

thats really it.

say user A wants to make a sleek, modern application, and need a slider that is
modern and sleek, sort of like the apple settings slider.

but user b wants to make a more gamified application, and wants a slider that will:
- have a light emitting, triganular thumb that spins 60 degrees every 1/6th of the way
- have a track with a border, and a trapezoidal shape to accomodate the look of the thumb
- have the track look like it is powering on when the user first opens the window, like they
  have just entered a space ship control room.

I want to be able to accomodate both of these users, and make the process as intuitive as possible.
This doesnt necessarily mean simple, as creating complex animations and components will require a 
higher learning curve. But I want user 1 to have high levels of customization, be able to create
themes to change the color of their application, and easily edit components. however, I want user 2
to be able to create a complex, animated component, and have the same level of customization
as user 1 for the more straightforward things.


- name: 'SK_Slider1'
- type: 'Slider'
- desc: "A sleek, modern, 2 step slider for toggling settings."
- steps: 2
- pieces: {
    'thumb': {
        'parent': 'track_line', # line of movement that the thumb will follow
        'my_circle_1':{ 
            'parent': 'thumb',
            'color': SKColor('Light Cream'), # an instance of SKColor
            'shape': SKCircle, # an instance of SKShape
            'size': 20,
            'position': 0,
            'border': SKBorder, # an instance of SKBorder
            'effects': {}
    },
    'track': {
        'my_track_1' : {
            'color': SKColor('Pine Green'), # an instance of SKColor
            'shape': SKRectangle, # an instance of SKShape
            'size': 100,
            'position': 0
            'border': SKBorder, # an instance of SKBorder
            'effects': {
                'glow': {
                    'color': SKColor('Lime Green'),
                    'strength': 5, # will affect total appearing size of the component
                    'size': 10, # will affect the base size of the glow
                }
            }
        },
        'track_line': {
            'location_A': 0, 0,
            'location_B': 100, 0,
        }
    }
}

- name: 'SK_Slider2'
- type: 'Slider'
- desc: "A gamified, animated slider with a light emitting track on first load."
- steps: num_steps (12)
- pieces: {
    'thumb': {
        'parent': 'track_line', # line of movement that the thumb will follow
        'theme2_slider_triangle1': {
            'parent': 'thumb',
            'color': SKColor('Tin'),
            'shape': SKTriangle,
            'size': 20,
            'position': 0,
            'border': SKBorder,
            'effects': {
                'incremental_spin': {
                    'from': 'center',
                    'angle': 60,
                    'direction': 'clockwise', # when increasing the value, the thumb will spin clockwise
                    'spin_every': steps / 6,
                    'delay_on_first_spin': 0.2, # delay before the first spin
                    'spin_speed': 0.5, # how fast it will take to complete the spin
                },
                'spin_when_value_reached': {
                    'value': 1,
                    'angle': 120,
                    'direction': 'counterclockwise', # when value is reached
                    'spin_speed': 0.5, # how fast it will take to complete the spin
                    'delay': 0.2, # delay before starting animation
                }
                'spin_when_value_reached': {
                    'value': num_steps, (12)
                    'angle': 120,
                    'direction': 'clockwise', # when value is reached
                    'spin_speed': 0.5, # how fast it will take to complete the spin
                    'delay': 0.2, # delay before starting animation
                }
                # when combining the incremental spin and the spin when value reached,
                # if the thumb hits either end of the track (min or max value) it will 
                # do a 180 degree spin in the correct direction, giving a stronger effect.
            }
        }
    },
    'track': {
        'my_track_2' : {
            'color': SKColor('Jet Black'),
            'shape': SKRectangle,
            'size': 100,
            'position': 0
            'border': SKBorder,
            'effects': {
                'increasing glow': {
                    'color': SKColor('Light Yellow'),
                    'strength': 5, # will affect total appearing size of the component
                    'size': 10, # will affect the base size of the glow
                },
                'change_color': {
                    'change_to_color': SKColor('Vanilla'), # light-like color
                    'duration': 3.0, # how long it will take to change color
                    'delay': 0.2, # delay before starting animation
                    'id': (a unique id for this effect)
                },
                'flicker': { # an effect that 'flickers' the timeline of a parent animation
                    'parent_effect': (change_color's id),
                    'chance': 33, # 33% chance to flicker
                    'duration': 0.4, # how long it will take to flicker
                    'num_flickers': randint(2, 4), # random number of flickers
                }
                # this will make the track look like it is powering on when the user first 
                # opens the window, and the flicker will make it look like the power is unstable,
                # happening randomly.
                # the flicker will only happen if the change_color effect is happening, and 
                # if it activates, it will move the timeline of the change_color effect back and forth
                # num_flickers times across flicker duration.
            }
        },
        'track_line': {
            'location_A': 0, 0,
            'location_B': 100, 0,
        }
    }
}



say that user 2 started out with a circle, and wanted to make it a triangle.
instead of having to start from scratch with an SKTriangle, we would call 
SKShape.changeShape(SKTriangle) and it would change the shape of the circle to a triangle,
but keep the same properties, like color, size, position, etc.

we have an editor window, with dedicated tabs to edit:
- colors
- shapes
- animations
- text
- and more

for a single component!

so, what do we do with completed components?

say we have these components:
- SKAnimBackground
- SK_Slider2 from the example above
- SKAutoComplete
- SKMessageLog (a component that shows a list of similar "items" in a message log/list format)
- SKCommandLine
- SKConfirm(icon='checkmark2', hover_text='Save Changes')
- SKCancel(icon='x', hover_text='Discard Changes')


and we want to make a window that has all of these components in it.
but, we aren't sure if this is the final color scheme or if these components will be
the ones used.

Creating and editing SKThemes

SKTheme: a class instance that represents a theme, or a collection of components,
with specific theme-wide properties.

- name: 'Control Room'
- desc: "A space ship control room theme."

theme wide properties:
- primary color - when it changes, the primary color that each component has set will change.
- secondary color
- tertiary color
- 4th color - don't know how to handle adding n colors yet.
- 5th color
- nth color

this way, we can quickly change the color scheme of the whole window, by changing the 'primary color',
'secondary color', etc. and all components that have a color set to one of these colors will change.

background color: a special color that can only be applied to certain components, namely
- SKWindow
- SKContainer
- occasionally present in other components.

The quirk of using background color is this:
- say you have 3 containers (think pyqt layouts) in a window, but you want an animated background
  that is flush across the whole window, uninterrupted by the containers (you want one singular) 
  background instead of 4 (one for window and 3 for containers).
  - when you set background color, it will change the window's background color to your selection,
    and make the container backgrounds transparent, so that the window's background color
    shows through.

SKDecals: collection of patterns that can change the look and depth of a component.

- examples, wood, rusty metal, glass, etc.

- also: can be in the style of added styles, like a Persona 5 style, or a cyberpunk style.

SKFX: a collection of effects that can be applied to components.

these are like the effects in the second slider example above, but span much broader.

- examples: 
    - glow
    - shadow
    - border
    - fiery
    - etc

these apply to borders of pieces in components, or the border of the component itself.

SKAnim: a tool that allows you to animate pieces in components, and components in themes.




