# -------------------------------------------------------------------------------------
# Copyright 2025 Casey Eddings
# Copyright (C) 2025 Casey Eddings
#
# This file is a part of the Suitkaise application, available under either
# the Apache License, Version 2.0 or the GNU General Public License v3.
#
# ~~ Apache License, Version 2.0 (http://www.apache.org/licenses/LICENSE-2.0)
#
#       Licensed under the Apache License, Version 2.0 (the "License");
#       you may not use this file except in compliance with the License.
#       You may obtain a copy of the License at
#
#           http://www.apache.org/licenses/LICENSE-2.0
#
#       Unless required by applicable law or agreed to in writing, software
#       distributed under the License is distributed on an "AS IS" BASIS,
#       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#       See the License for the specific language governing permissions and
#       limitations under the License.
#
# ~~ GNU General Public License, Version 3 (http://www.gnu.org/licenses/gpl-3.0.html)
#
#       This program is free software: you can redistribute it and/or modify
#       it under the terms of the GNU General Public License as published by
#       the Free Software Foundation, either version 3 of the License, or
#       (at your option) any later version.
#
#       This program is distributed in the hope that it will be useful,
#       but WITHOUT ANY WARRANTY; without even the implied warranty of
#       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#       GNU General Public License for more details.
#
#       You should have received a copy of the GNU General Public License
#       along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
# -------------------------------------------------------------------------------------

# suitkaise/int/eventsys/core/station/int_station.py

"""
Module containing the IntStation singleton class for managing internal events.

The IntStation acts as the central repository for all internal events in the system.
Internal events are those that are generated by the Suitkaise application itself
under the 'suitkaise.int' namespace. It communicates with BusStations in all internal 
processes and with the ExtStation through the EventBridge.

"""

import threading
from typing import List, Optional, Type, ClassVar

from suitkaise.int.eventsys.data.enums.enums import (
    StationLevel, BridgeDirection, BridgeState, SKDomain
)
from suitkaise.int.eventsys.events.base_event import Event
from suitkaise.int.eventsys.core.station.main_station import MainStation
from suitkaise.int.eventsys.core.station.bus_station import BusStation
import suitkaise.int.time.sktime as sktime
import suitkaise.int.domain.get_domain as get_domain

class IntStation(MainStation):
    """
    Singleton class managing all internal events in the system.
    
    The IntStation is responsible for:
    1. Collecting events from all internal BusStations
    2. Redistributing these events to interested BusStations
    3. Communicating with the ExtStation through the EventBridge
    4. Maintaining a chronological history of all internal events
    
    This class follows the Singleton pattern - only one instance exists.
    Use IntStation.get_instance() to get the singleton instance.

    """
    _instance: ClassVar[Optional["IntStation"]] = None
    _instance_lock = threading.RLock()

    def __new__(cls):
        """Control instance creation for the singleton pattern."""
        with cls._instance_lock:
            if cls._instance is None:
                cls._instance = super(IntStation, cls).__new__(cls)
        return cls._instance
    
    def __init__(self):
        """
        Initialize the IntStation singleton.
        
        This will only execute once, when the singleton is first created.
        Subsequent calls to IntStation() will return the existing instance
        without re-initializing.

        """
        if hasattr(self, "_initialized") and self._initialized:
            return
        
        super().__init__()

        self.name = "INTSTATION"

        domain = get_domain.get_domain()
        if domain != SKDomain.INTERNAL:
            raise RuntimeError("IntStation can only be used in the INTERNAL domain.")
        
        self.bridge = self.connect_to_bridge()
        
        self._initialized = True

        # last syncs
        self.last_bus_sync = None
        self.last_ext_sync = None

        print(f"IntStation initialized in domain: {domain}")


    def _init_background(self) -> None:
        """
        Initialize and start background tasks for the IntStation.

        This should:
        1. Start the thread to periodically sync with the ExtStation
        using the EventBridge.
        2. Start the thread to periodically compress events in the event
        history.
        
        """
        self._running = True

        # Ensure bridge connection
        if not self.bridge:
            try:
                self.bridge = self.connect_to_bridge()
                if not self.bridge:
                    print(f"Warning: Failed to connect to EventBridge during initialization.")
            except Exception as e:
                print(f"Error connecting to EventBridge: {e}")
                # Continue anyway, background thread will retry

        # start the thread to sync with the other MainStation
        self._sync_thread = threading.Thread(
            target=self._intstation_sync, # sync with extstation and busstations
            name="IntStation Sync Thread",
            daemon=True
        )
        self._sync_thread.start()

        # start the thread to compress events in the event history
        self._compression_thread = threading.Thread(
            target=self._compress_station_history,
            name="IntStation Compression Thread",
            daemon=True
        )
        self._compression_thread.start()

        print(f"Started background tasks for IntStation.")


    @classmethod
    def get_instance(cls) -> "IntStation":
        """
        Get the singleton instance of IntStation.
        
        This method ensures that only one instance of IntStation exists
        throughout the application.

        Returns:
            IntStation: The singleton instance of IntStation.

        """
        if cls._instance is None:
            cls._instance = cls()
        return cls._instance
    

    def _intstation_yawn(self) -> None:
        """
        Set the yawn to timeout background tasks.

        If 3 exceptions are raised within 20 seconds, this method will
        set the yawn to timeout background tasks for 30 seconds, allowing
        other processes some time to reset or fix issues before attempting
        to run these tasks again.
        
        """
        message = "IntStation raised an exception 3 times within the last 18 seconds. "
        message += "Timing out background tasks for 30 seconds."
        sktime.yawn(3, 20, 30, self.station_name, message, dprint=True)


    def _compress_station_history(self):
        """
        Periodically compress the event history to save space.
        
        This method runs in a separate thread and compresses the event
        history every 5 minutes. The compression level is set to HIGH
        for maximum space savings.

        """
        while self._running:
            try:
                # check if comporession is needed
                if self.needs_compressing == True:
                    self.compress_events() # from Station class
                    print(f"Compressed events for {self.name}.")

                sktime.sleep(self.compression_interval)

            except Exception as e:
                print(f"Error in compression thread for {self.name}: {e}")
                self._intstation_yawn()
                sktime.sleep(1)

    
    def _connected_to_bridge(self):
        """Ensure the bridge connection is established, with retry logic."""
        if not self.bridge:
            try:
                self.bridge = self.connect_to_bridge()
                if self.bridge:
                    print(f"Successfully connected to EventBridge.")
                    return True
                else:
                    print(f"Failed to connect to EventBridge.")
                    return False
            except Exception as e:
                print(f"Error connecting to EventBridge: {e}")
                return False
        return True


# 
# Communication with BusStations and Bridge/ExtStation
#

    def connect(self) -> 'IntStation':
        """
        Return the IntStation instance.

        This method can be used by BusStations to connect to the IntStation.
        
        """
        return self.get_instance()


    def _intstation_sync(self):
        """
        Periodically sync with the ExtStation and any BusStations in 
        a background thread.

        This method:
        1. attempts to sync its events with Exstation through EventBridge.sync()
        2. replies to requests from BusStations asking for MainStation events,
           making said events available in the IntStation's self.replies dict for
           the BusStation to get.
        
        """
        while self._running:
            try:
                # sync with the ExtStation
                self._sync_with_extstation()

                # sync with BusStations if they request it
                self._process_received_messages()

            except Exception as e:
                print(f"Error in sync thread for {self.name}: {e}")
                self._intstation_yawn()
                sktime.sleep(1)

            finally:
                # Sleep for a short time before next sync attempt
                sktime.sleep(4)
                

    def _sync_with_extstation(self) -> None:
        """
        Periodically sync with the ExtStation using the EventBridge.

        Uses EventBridge.sync() to synchronize events with the ExtStation.
        This method runs in a separate thread and syncs every self.compression_interval
        seconds.
        
        """
        while self._running:
            try:
                if not self._connected_to_bridge():
                    attempts = 0
                    while not self._connected_to_bridge():
                        if attempts >= 3:
                            self._intstation_yawn()

                        print(f"Warning: Not connected to EventBridge. Retrying...")
                        attempts += 1
                        sktime.sleep(2)
                        


                # if last_ext_sync is None or more than sync_interval seconds ago
                if self.last_ext_sync:
                    elapsed = sktime.elapsed(self.last_ext_sync)
                
                if self.last_ext_sync is None or elapsed > self.ext_sync_interval:
                    # check bridge direction and state
                    direction, state = self.get_bridge_info()

                    if not self.bridge.can_send_to_ext():
                        # Log the state but don't treat as error
                        print(f"{self.name}: cannot currently sync with ExtStation. "
                            f"Bridge direction {direction.name}/state {state.name}.")
                        # Sleep before next attempt
                        continue

                    # sync with ExtStation
                    synced = self.bridge.sync()
                    if synced:
                        self.last_ext_sync = sktime.now()
                        print(f"{self.name}: synced with ExtStation.")
                        print(f"Time since last sync: {sktime.elapsed(self.last_ext_sync)} seconds.")
                    else:
                        print(f"{self.name}: failed to sync with ExtStation.")

            except Exception as e:
                print(f"Error in sync with ExtStation: {e}")
                self._intstation_yawn()
                sktime.sleep(1)
            
                

    

            




        
    



        



    

                



        







        

        
        


