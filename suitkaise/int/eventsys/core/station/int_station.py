# -------------------------------------------------------------------------------------
# Copyright 2025 Casey Eddings
# Copyright (C) 2025 Casey Eddings
#
# This file is a part of the Suitkaise application, available under either
# the Apache License, Version 2.0 or the GNU General Public License v3.
#
# ~~ Apache License, Version 2.0 (http://www.apache.org/licenses/LICENSE-2.0)
#
#       Licensed under the Apache License, Version 2.0 (the "License");
#       you may not use this file except in compliance with the License.
#       You may obtain a copy of the License at
#
#           http://www.apache.org/licenses/LICENSE-2.0
#
#       Unless required by applicable law or agreed to in writing, software
#       distributed under the License is distributed on an "AS IS" BASIS,
#       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#       See the License for the specific language governing permissions and
#       limitations under the License.
#
# ~~ GNU General Public License, Version 3 (http://www.gnu.org/licenses/gpl-3.0.html)
#
#       This program is free software: you can redistribute it and/or modify
#       it under the terms of the GNU General Public License as published by
#       the Free Software Foundation, either version 3 of the License, or
#       (at your option) any later version.
#
#       This program is distributed in the hope that it will be useful,
#       but WITHOUT ANY WARRANTY; without even the implied warranty of
#       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#       GNU General Public License for more details.
#
#       You should have received a copy of the GNU General Public License
#       along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
# -------------------------------------------------------------------------------------

# suitkaise/int/eventsys/core/station/int_station.py

"""
Module containing the IntStation singleton class for managing internal events.

The IntStation acts as the central repository for all internal events in the system.
Internal events are those that are generated by the Suitkaise application itself
under the 'suitkaise.int' namespace. It communicates with BusStations in all internal 
processes and with the ExtStation through the EventBridge.

"""

import threading
from typing import List, Optional, Type, ClassVar

from suitkaise.int.eventsys.data.enums.enums import (
    StationLevel, BridgeDirection, BridgeState, SKDomain
)
from suitkaise.int.eventsys.events.base_event import Event
from suitkaise.int.eventsys.core.station.main_station import MainStation
from suitkaise.int.eventsys.core.station.bus_station import BusStation
import suitkaise.int.time.sktime as sktime
import suitkaise.int.domain.get_domain as get_domain

class IntStation(MainStation):
    """
    Singleton class managing all internal events in the system.
    
    The IntStation is responsible for:
    1. Collecting events from all internal BusStations
    2. Redistributing these events to interested BusStations
    3. Communicating with the ExtStation through the EventBridge
    4. Maintaining a chronological history of all internal events
    
    This class follows the Singleton pattern - only one instance exists.
    Use IntStation.get_instance() to get the singleton instance.

    """
    _instance: ClassVar[Optional["IntStation"]] = None
    _instance_lock = threading.RLock()

    def __new__(cls):
        """Control instance creation for the singleton pattern."""
        with cls._instance_lock:
            if cls._instance is None:
                cls._instance = super(IntStation, cls).__new__(cls)
        return cls._instance
    
    def __init__(self):
        """
        Initialize the IntStation singleton.
        
        This will only execute once, when the singleton is first created.
        Subsequent calls to IntStation() will return the existing instance
        without re-initializing.

        """
        if hasattr(self, "_initialized") and self._initialized:
            return
        
        super().__init__()

        self.name = "INTSTATION"

        domain = get_domain.get_domain()
        if domain != SKDomain.INTERNAL:
            raise RuntimeError("IntStation can only be used in the INTERNAL domain.")
        
        self.bridge = self.connect_to_bridge()
        
        self._initialized = True

        # last syncs
        self.last_bus_sync = None
        self.last_ext_sync = None

        print(f"IntStation initialized in domain: {domain}")


    def _init_background(self) -> None:
        """
        Initialize and start background tasks for the IntStation.

        This should:
        1. Start the thread to periodically sync with the ExtStation
        using the EventBridge.
        2. Start the thread to periodically compress events in the event
        history.
        
        """
        self._running = True

        # start the thread to sync with the other MainStation
        self._sync_thread = threading.Thread(
            target=self._sync_with_extstation,
            name="IntStation Sync Thread",
            daemon=True
        )
        self._sync_thread.start()

        # start the thread to compress events in the event history
        self._compression_thread = threading.Thread(
            target=self._compress_station_history,
            name="IntStation Compression Thread",
            daemon=True
        )
        self._compression_thread.start()

        print(f"Started background tasks for IntStation.")


    @classmethod
    def get_instance(cls) -> "IntStation":
        """
        Get the singleton instance of IntStation.
        
        This method ensures that only one instance of IntStation exists
        throughout the application.

        Returns:
            IntStation: The singleton instance of IntStation.

        """
        if cls._instance is None:
            cls._instance = cls()
        return cls._instance


    def _compress_station_history(self):
        """
        Periodically compress the event history to save space.
        
        This method runs in a separate thread and compresses the event
        history every 5 minutes. The compression level is set to HIGH
        for maximum space savings.

        """
        while self._running:
            try:
                # check if comporession is needed
                if self.needs_compressing == True:
                    self.compress_events() # from Station class
                    print(f"Compressed events for {self.name}.")

                sktime.sleep(self.compression_interval)

            except Exception as e:
                print(f"Error in compression thread for {self.name}: {e}")
                sktime.yawn(3, 10, 100, self.station_name, dprint=True)
                sktime.sleep(1)


# 
# Bridge related methods
#

    def _sync_with_extstation(self):
        """
        Periodically sync with the ExtStation using the EventBridge.

        Uses EventBridge.sync() to synchronize events with the ExtStation.
        This method runs in a separate thread and syncs every self.compression_interval
        seconds.
        
        """
        while self._running:
            try:
                # if last_ext_sync is None or more than sync_interval seconds ago
                if self.last_ext_sync:
                    elapsed = sktime.elapsed(self.last_ext_sync)
                
                if self.last_ext_sync is None or elapsed > self.sync_interval:
                    # sync with the ExtStation, depending on BridgeState 
                    # and BridgeDirection
                    synced = self.bridge.sync()
                    if synced:
                        self.last_ext_sync = sktime.now()
                        print(f"Synced with ExtStation at "
                              f"{sktime.to_custom_time_format(self.last_ext_sync)}.")
                    else:
                        direction, state = self.get_bridge_info()
                        if self.bridge.can_send_to_ext():
                            raise RuntimeError(
                                f"Failed to sync with ExtStation despite BridgeState {state} "
                                f"and BridgeDirection {direction} allowing a sync."
                                )
                        # if we can't sync due to bridge closure, don't raise an error
                        # because this is intended behavior
                        
            except Exception as e:
                print(f"Error in sync thread for {self.name}: {e}")
                raise e
            
            finally:
                # sleep for the sync interval
                sktime.sleep(self.sync_interval)




        
    



        



    

                



        







        

        
        


