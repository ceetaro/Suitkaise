# -------------------------------------------------------------------------------------
# Copyright 2025 Casey Eddings
# Copyright (C) 2025 Casey Eddings
#
# This file is a part of the Suitkaise application, available under either
# the Apache License, Version 2.0 or the GNU General Public License v3.
#
# ~~ Apache License, Version 2.0 (http://www.apache.org/licenses/LICENSE-2.0)
#
#       Licensed under the Apache License, Version 2.0 (the "License");
#       you may not use this file except in compliance with the License.
#       You may obtain a copy of the License at
#
#           http://www.apache.org/licenses/LICENSE-2.0
#
#       Unless required by applicable law or agreed to in writing, software
#       distributed under the License is distributed on an "AS IS" BASIS,
#       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#       See the License for the specific language governing permissions and
#       limitations under the License.
#
# ~~ GNU General Public License, Version 3 (http://www.gnu.org/licenses/gpl-3.0.html)
#
#       This program is free software: you can redistribute it and/or modify
#       it under the terms of the GNU General Public License as published by
#       the Free Software Foundation, either version 3 of the License, or
#       (at your option) any later version.
#
#       This program is distributed in the hope that it will be useful,
#       but WITHOUT ANY WARRANTY; without even the implied warranty of
#       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#       GNU General Public License for more details.
#
#       You should have received a copy of the GNU General Public License
#       along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
# -------------------------------------------------------------------------------------

# suitkaise/int/eventsys/core/station/int_station.py

"""
Module containing the IntStation singleton class for managing internal events.

The IntStation acts as the central repository for all internal events in the system.
Internal events are those that are generated by the Suitkaise application itself
under the 'suitkaise.int' namespace. It communicates with BusStations in all internal 
processes and with the ExtStation through the EventBridge.

"""

import threading
from typing import List, Optional, Type, ClassVar

from suitkaise.int.eventsys.data.enums.enums import (
    StationLevel, BridgeDirection, BridgeState, SKDomain
)
from suitkaise.int.eventsys.events.base_event import Event
from suitkaise.int.eventsys.core_depr.station.main_station import MainStation
from suitkaise.int.eventsys.core_depr.station.bus_station import BusStation
import suitkaise.int.utils.time.sktime as sktime
import suitkaise.int.domain.get_domain as get_domain

class IntStation(MainStation):
    """
    Singleton class managing all internal events in the system.
    
    The IntStation is responsible for:
    1. Collecting events from all internal BusStations
    2. Redistributing these events to interested BusStations
    3. Communicating with the ExtStation through the EventBridge
    4. Maintaining a chronological history of all internal events
    
    This class follows the Singleton pattern - only one instance exists.
    Use IntStation.get_instance() to get the singleton instance.

    """
    _instance: ClassVar[Optional["IntStation"]] = None
    _instance_lock = threading.RLock()

    def __new__(cls):
        """Control instance creation for the singleton pattern."""
        with cls._instance_lock:
            if cls._instance is None:
                cls._instance = super(IntStation, cls).__new__(cls)
        return cls._instance
    
    def __init__(self):
        """
        Initialize the IntStation singleton.
        
        This will only execute once, when the singleton is first created.
        Subsequent calls to IntStation() will return the existing instance
        without re-initializing.

        """
        if hasattr(self, "_initialized") and self._initialized:
            return
        
        super().__init__()

        self.name = "INTSTATION"

        domain = get_domain.get_domain()
        if domain != SKDomain.INTERNAL:
            raise RuntimeError("IntStation can only be used in the INTERNAL domain.")
        
        self.bridge = self.connect_to_bridge()

        self.ext_sync_interval = 30.0
        
        self._initialized = True

        # last syncs
        self.last_bus_sync = None
        self.last_ext_sync = None

        print(f"IntStation initialized in domain: {domain}")


    def _init_background(self) -> None:
        """
        Initialize and start background tasks for the IntStation.

        This should:
        1. Start the thread to periodically sync with the ExtStation
        using the EventBridge.
        2. Start the thread to periodically manage the event history.
        
        """
        self._running = True

        # Ensure bridge connection
        if not self.bridge:
            try:
                self.bridge = self.connect_to_bridge()
                if not self.bridge:
                    print(f"Warning: Failed to connect to EventBridge during initialization.")
            except Exception as e:
                print(f"Error connecting to EventBridge: {e}")
                # Continue anyway, background thread will retry

        # start the thread to sync with the other MainStation
        self._sync_thread = threading.Thread(
            target=self._intstation_sync, # sync with extstation and busstations
            name="IntStation Sync Thread",
            daemon=True
        )
        self._sync_thread.start()

        # start the thread to compress events in the event history
        self._compression_thread = threading.Thread(
            target=self._manage_history,
            name="IntStation Compression Thread",
            daemon=True
        )
        self._compression_thread.start()

        print(f"Started background tasks for IntStation.")


    @classmethod
    def get_instance(cls) -> "IntStation":
        """
        Get the singleton instance of IntStation.
        
        This method ensures that only one instance of IntStation exists
        throughout the application.

        Returns:
            IntStation: The singleton instance of IntStation.

        """
        if cls._instance is None:
            cls._instance = cls()
        return cls._instance
    

# 
# Communication with BusStations and Bridge/ExtStation
#

    def connect(self) -> 'IntStation':
        """
        Return the IntStation instance.

        This method can be used by BusStations to connect to the IntStation.
        
        """
        return self.get_instance()


    def _intstation_sync(self):
        """
        Periodically sync with the ExtStation and any BusStations in 
        a background thread.

        This method:
        1. attempts to sync its events with Extstation through EventBridge.sync()
        2. replies to requests from BusStations asking for MainStation events,
           making said events available in the IntStation's self.replies dict for
           the BusStation to get.
        
        """
        while self._running:
            start_time = sktime.now()
            try:
                # set a max operation time
                max_operation_time = 30.0

                # check if we should continue
                if not self._running:
                    break

                # perform sync with ExtStation before syncing with BusStations
                operation_start = sktime.now()
                self._sync_with_extstation()

                # check for timeout
                if sktime.elapsed(operation_start) > max_operation_time:
                    print(f"Warning: Sync with ExtStation took too long. "
                          f"Elapsed time: {sktime.elapsed(operation_start)} seconds.")
                
                # perform the sync with BusStations
                operation_start = sktime.now()
                self._process_received_messages()

                # check for timeout
                if sktime.elapsed(operation_start) > max_operation_time:
                    print(f"Warning: Sync with BusStations took too long. "
                          f"Elapsed time: {sktime.elapsed(operation_start)} seconds.")
                    
                elapsed = sktime.elapsed(start_time)
                if elapsed < 5.0:
                    # sleep for a short time to avoid busy waiting
                    sktime.sleep(5.0 - elapsed)

            except Exception as e:
                print(f"{self.name} Error in IntStation sync thread: {e}")
                self._sync_yawn()
            
                # prevent tight loop
                if elapsed < 2.0:
                    sktime.sleep(2.0 - elapsed)

                

    def _sync_with_extstation(self) -> None:
        """
        Periodically sync with the ExtStation using the EventBridge.

        Uses EventBridge.sync() to synchronize events with the ExtStation.
        This method runs in a separate thread.
        
        """
        while self._running:
            try:
                if not self._connected_to_bridge():
                    attempts = 0
                    while not self._connected_to_bridge():
                        if attempts >= 3:
                            self._bridge_error_yawn()

                        print(f"Warning: Not connected to EventBridge. Retrying...")
                        attempts += 1
                        sktime.sleep(2)
                        


                # if last_ext_sync is None or more than sync_interval seconds ago
                if self.last_ext_sync:
                    elapsed = sktime.elapsed(self.last_ext_sync)
                
                if self.last_ext_sync is None or elapsed > self.ext_sync_interval:
                    # check bridge direction and state
                    direction, state = self.get_bridge_info()

                    if not self.bridge.can_send_to_ext():
                        # Log the state but don't treat as error
                        print(f"{self.name}: cannot currently sync with ExtStation. "
                            f"Bridge direction {direction.name}/state {state.name}.")
                        # Sleep before next attempt
                        continue

                    # sync with ExtStation
                    synced, report = self.bridge.sync()
                    if report:
                        state = report.get("state")
                        direction = report.get("direction")
                        # NOTE: and more... depending on what else we add to the report
                    if synced:
                        self.last_ext_sync = sktime.now()
                        print(f"{self.name}: synced with ExtStation.")
                        print(f"Time since last sync: {sktime.elapsed(self.last_ext_sync)} seconds.")
                    else:
                        print(f"{self.name}: failed to sync with ExtStation.")

            except Exception as e:
                print(f"Error in sync with ExtStation: {e}")
                self._bridge_error_yawn()
                sktime.sleep(1)