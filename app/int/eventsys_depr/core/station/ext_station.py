# -------------------------------------------------------------------------------------
# Copyright 2025 Casey Eddings
# Copyright (C) 2025 Casey Eddings
#
# This file is a part of the Suitkaise application, available under either
# the Apache License, Version 2.0 or the GNU General Public License v3.
#
# ~~ Apache License, Version 2.0 (http://www.apache.org/licenses/LICENSE-2.0)
#
#       Licensed under the Apache License, Version 2.0 (the "License");
#       you may not use this file except in compliance with the License.
#       You may obtain a copy of the License at
#
#           http://www.apache.org/licenses/LICENSE-2.0
#
#       Unless required by applicable law or agreed to in writing, software
#       distributed under the License is distributed on an "AS IS" BASIS,
#       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#       See the License for the specific language governing permissions and
#       limitations under the License.
#
# ~~ GNU General Public License, Version 3 (http://www.gnu.org/licenses/gpl-3.0.html)
#
#       This program is free software: you can redistribute it and/or modify
#       it under the terms of the GNU General Public License as published by
#       the Free Software Foundation, either version 3 of the License, or
#       (at your option) any later version.
#
#       This program is distributed in the hope that it will be useful,
#       but WITHOUT ANY WARRANTY; without even the implied warranty of
#       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#       GNU General Public License for more details.
#
#       You should have received a copy of the GNU General Public License
#       along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
# -------------------------------------------------------------------------------------

# suitkaise/int/eventsys/core/station/ext_station.py

"""
Module containing the ExtStation singleton class for managing external events.

The ExtStation acts as the central repository for all external events in the system.
External events are those that are generated by user imported code under the 
'suitkaise.ext' namespace. It communicates with BusStations in all external processes
and with the IntStation through the EventBridge.

ExtStation should also have extra methods to let the user adjust source code settings
without directly modifying the source code. Example, changing how long we timeout
background task threads after they raise 3 exceptions.

"""

import threading
from typing import List, Optional, Type, ClassVar

from suitkaise_app.int.eventsys.data.enums.enums import (
    StationLevel, BridgeDirection, BridgeState, SKDomain
)
from suitkaise_app.int.eventsys.events.base_event import Event
from suitkaise_app.int.eventsys.core_depr.station.main_station import MainStation
from suitkaise_app.int.eventsys.core_depr.station.bus_station import BusStation
import suitkaise_app.int.utils.time.sktime as sktime
import suitkaise_app.int.domain.get_domain as get_domain

class ExtStation(MainStation):
    """
    Singleton class managing all external events in the system.

    The ExtStation is responsible for:
    1. Collecting events from all external BusStations
    2. Redistributing these events to interested BusStations
    3. Communicating with the IntStation through the EventBridge
    4. Maintaining a chronological history of all external events

    This class follows the Singleton pattern - only one instance exists.
    Use ExtStation.get_instance() to get the singleton instance.

    """
    _instance: ClassVar[Optional["ExtStation"]] = None
    _instance_lock = threading.RLock()

    def __new__(cls):
        """Control instance creation for the singleton pattern."""
        with cls._instance_lock:
            if cls._instance is None:
                cls._instance = super(ExtStation, cls).__new__(cls)
        return cls._instance
    
    def __init__(self):
        """
        Initialize the ExtStation singleton.
        
        This will only execute once, when the singleton is first created.
        Subsequent calls to ExtStation() will return the existing instance
        without re-initializing.

        """
        if hasattr(self, "_initialized") and self._initialized:
            return
        
        super().__init__()

        self.name = "EXTSTATION"

        domain = get_domain.get_domain()
        if domain != SKDomain.EXTERNAL:
            raise RuntimeError("ExtStation can only be used in the EXTERNAL domain.")
        
        self.bridge = self.connect_to_bridge()

        self.int_sync_interval = 30.0

        self._initialized = True

        # last syncs
        self.last_bus_sync = None
        self.last_int_sync = None

        print(f"ExtStation initialized in domain: {domain}")


    def _init_background(self) -> None:
        """
        Initialize and start background tasks for the ExtStation.

        This should:
        1. Start the thread to periodically sync with the ExtStation
        using the EventBridge.
        2. Start the thread to periodically manage the event history.
 
        """
        self._running = True

        # Ensure bridge connection
        if not self.bridge:
            try:
                self.bridge = self.connect_to_bridge()
                if not self.bridge:
                    print(f"Warning: Failed to connect to EventBridge during initialization.")
            except Exception as e:
                print(f"Error connecting to EventBridge: {e}")
                # Continue anyway, background thread will retry

        # start the thread to sync with the other MainStation
        self._sync_thread = threading.Thread(
            target=self._extstation_sync, # sync with intstation and busstations
            name="ExtStation Sync Thread",
            daemon=True
        )
        self._sync_thread.start()

        # start the thread to compress events in the event history
        self._compression_thread = threading.Thread(
            target=self._manage_history,
            name="ExtStation Compression Thread",
            daemon=True
        )
        self._compression_thread.start()

        print(f"Started background tasks for ExtStation.")


    @classmethod
    def get_instance(cls) -> "ExtStation":
        """
        Get the singleton instance of ExtStation.

        This method ensures that only one instance of ExtStation exists
        throughout the application.

        Returns:
            ExtStation: The singleton instance of ExtStation.
        """
        if cls._instance is None:
            cls._instance = cls()
        return cls._instance
    
# 
# Communication with BusStations and Bridge/IntStation
#

    def connect(self) -> 'ExtStation':
        """
        Return the ExtStation instance.

        This method can be used by BusStations to connect to the ExtStation.
        
        """
        return self.get_instance()
    

    def _extstation_sync(self):
        """
        Periodically sync with the ExtStation and any BusStations in 
        a background thread.

        This method:
        1. attempts to sync its events with IntStation through EventBridge.sync()
        2. replies to requests from BusStations asking for MainStation events,
           making said events available in the ExtStation's self.replies dict for
           the BusStation to get.
        
        """
        while self._running:
            start_time = sktime.now()
            try:
                # set a max operation time
                max_operation_time = 30.0

                # check if we should continue
                if not self._running:
                    break

                # perform sync with IntStation
                operation_start = sktime.now()
                self._sync_with_intstation()

                # check for timeout
                if sktime.elapsed(operation_start) > max_operation_time:
                    print(f"Warning: Sync with IntStation took too long. "
                          f"Elapsed time: {sktime.elapsed(operation_start)} seconds.")
                
                # perform the sync with BusStations
                operation_start = sktime.now()
                self._process_received_messages()

                # check for timeout
                if sktime.elapsed(operation_start) > max_operation_time:
                    print(f"Warning: Sync with BusStations took too long. "
                          f"Elapsed time: {sktime.elapsed(operation_start)} seconds.")
                    
                elapsed = sktime.elapsed(start_time)
                if elapsed < 5.0:
                    # sleep for a short time to avoid busy waiting
                    sktime.sleep(5.0 - elapsed)

            except Exception as e:
                print(f"{self.name}: Error in ExtStation sync thread: {e}")
                self._sync_yawn()
            
                # prevent tight loop
                if elapsed < 2.0:
                    sktime.sleep(2.0 - elapsed)

    def _sync_with_intstation(self) -> None:
        """
        Periodically sync with the IntStation using the EventBridge.

        Uses EventBridge.sync() to synchronize events with the IntStation.
        This method runs in a separate thread.
        
        """
        while self._running:
            try:
                if not self._connected_to_bridge():
                    attempts = 0
                    while not self._connected_to_bridge():
                        if attempts >= 3:
                            self._bridge_error_yawn()

                        print(f"Warning: Not connected to EventBridge. Retrying...")
                        attempts += 1
                        sktime.sleep(2)
                        


                # if last_int_sync is None or more than sync_interval seconds ago
                if self.last_int_sync:
                    elapsed = sktime.elapsed(self.last_int_sync)
                
                if self.last_int_sync is None or elapsed > self.int_sync_interval:
                    # check bridge direction and state
                    direction, state = self.get_bridge_info()

                    if not self.bridge.can_send_to_int():
                        # Log the state but don't treat as error
                        print(f"{self.name}: cannot currently sync with IntStation. "
                            f"Bridge direction {direction.name}/state {state.name}.")
                        # Sleep before next attempt
                        continue

                    # sync with IntStation
                    synced = self.bridge.sync(self)
                    if synced:
                        self.last_int_sync = sktime.now()
                        print(f"{self.name}: synced with IntStation.")
                        print(f"Time since last sync: {sktime.elapsed(self.last_int_sync)} seconds.")
                    else:
                        print(f"{self.name}: failed to sync with IntStation.")

            except Exception as e:
                print(f"Error in sync with IntStation: {e}")
                self._bridge_error_yawn()
                sktime.sleep(1)