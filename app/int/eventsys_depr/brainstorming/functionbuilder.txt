FunctionInstanceBuilder: takes a function and builds a callable instance of it,
with the ability to add specific values for args and kwargs. Then, the FIB
validates the args you add, and builds the callable instance, with metadata for 
args and their values (args not added use their default values) and kwargs, if
any.

We will use this whenever we need to store a callable instance of a function
in order to store it and call it at a later date with this specific set of 
args and kwargs.


with FunctionInstanceBuilder() as FIB:
    FIB.add_callable(module='mymodule', function=myfunction())

      or maybe FIB.add_callable(module='mymodule', function='myfunction')?

    then...
    FIB.add_argument('arg1', value=value1)
    - verifies the arg exists and the value is the correct type

    kwargs = {
        'my_string': 'Hello, World!',
        'my_int': 42,
        'my_float': 3.14,
        'my_list': [1, 2, 3],
    }
    FIB.add_kwargs(kwargs)
    - verifies that function takes kwargs

    FIB.add_kwarg({'my_string2', value='Hello, World2!'})
    - verifies that function takes kwargs, and adds it to kwargs dict that
    this FIB might already have

    function = FIB.build()
    - builds a container with all information about the function, its args and kwargs,
      and a callable instance of the function with the args and kwargs in place






    

