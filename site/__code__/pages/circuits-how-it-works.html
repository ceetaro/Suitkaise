<div class="module-bar" data-module="circuits">
    <button class="module-bar-title">suitkaise.circuits</button>
    <nav class="module-bar-nav">
        <a href="#circuits-why" class="module-bar-link" data-page="circuits-why">why</a>
        <a href="#circuits-quick-start" class="module-bar-link" data-page="circuits-quick-start">quick start</a>
        <a href="#circuits" class="module-bar-link" data-page="circuits">how to use</a>
        <a href="#circuits-how-it-works" class="module-bar-link active" data-page="circuits-how-it-works">how it works</a>
        <a href="#circuits-examples" class="module-bar-link" data-page="circuits-examples">examples</a>
        <a href="#circuits-tests" class="module-bar-link" data-page="circuits-tests">tests</a>
        <a href="#circuits-videos" class="module-bar-link" data-page="circuits-videos">videos</a>
        <a href="#circuits-learn" class="module-bar-link" data-page="circuits-learn">learn</a>
    </nav>
</div>
<section class="module-page">
    <h1>How <code><suitkaise-api>circuits</suitkaise-api></code> actually works</h1>
    <p><code><suitkaise-api>circuits</suitkaise-api></code> is 2 circuit breaker classes, that help you manage failures in your code.</p>
    <ul>
        <li><code><suitkaise-api>Circuit</suitkaise-api></code> - auto-resetting circuit that sleeps and continues</li>
        <li><code><suitkaise-api>BreakingCircuit</suitkaise-api></code> - stays broken until manually reset</li>
    </ul>
    <p>Both classes have:</p>
    <ul>
        <li>thread safety</li>
        <li>native async support</li>
        <li>exponential backoff (with jitter and max sleep time)</li>
        <li>super simple API</li>
    </ul>
    <h2><code><suitkaise-api>Circuit</suitkaise-api></code></h2>
    <p><code><suitkaise-api>Circuit</suitkaise-api></code> is an auto-resetting circuit that sleeps, and then automatically resets to continue.</p>
    <p>When the short counter reaches the <code>num_shorts_to_trip</code> threshold, the circuit trips.</p>
    <pre><code class="language-text"><suitkaise-api>short</suitkaise-api>() -&gt; increment counter -&gt; if shorts == num_shorts_to_trip? -&gt; trip -&gt; sleep and reset</code></pre>
    <p><code><suitkaise-api>Circuit</suitkaise-api></code> uses a <code>threading.RLock</code> to ensure that internal state is thread-safe.</p>
    <h3>Tracking state</h3>
    <p><code>_num_shorts_to_trip: int</code> Number of shorts required before the circuit trips. Set at initialization.</p>
    <p><code>_times_shorted: int</code> Counter tracking shorts since the last trip. Resets to 0 after each trip.</p>
    <p><code>_total_trips: int</code> Lifetime count of all trips. Never resets.</p>
    <p><code>_current_sleep_time: float</code> Current sleep duration after backoff is applied. Starts at <code>sleep_time_after_trip</code> and grows with each trip.</p>
    <p><code>_lock: threading.RLock</code> Reentrant lock for thread-safe state access.</p>
    <h3>Properties</h3>
    <p><code>num_shorts_to_trip</code>: Number of shorts required before the circuit trips.</p>
    <ul>
        <li><code>int</code></li>
        <li>read-only</li>
    </ul>
    <p><code>times_shorted</code>: Counter tracking shorts since the last trip. Resets to 0 after each trip.</p>
    <ul>
        <li><code>int</code></li>
        <li>read-only</li>
    </ul>
    <p><code>total_trips</code>: Lifetime count of all trips. Never resets.</p>
    <ul>
        <li><code>int</code></li>
        <li>read-only</li>
    </ul>
    <p><code>current_sleep_time</code>: Current sleep duration after backoff is applied. Starts at <code>sleep_time_after_trip</code> and grows with each trip.</p>
    <ul>
        <li><code>float</code></li>
        <li>read-only</li>
    </ul>
    <h3>Methods</h3>
    <h4><code><suitkaise-api>short</suitkaise-api>(custom_sleep: float | None = None) -&gt; bool</code></h4>
    <p>Increments <code>_times_shorted</code> by 1, calling <code>_trip_circuit()</code> if the <code>num_shorts_to_trip</code> threshold is reached.</p>
    <p>If <code>custom_sleep</code> is provided, it will be used instead of <code>_current_sleep_time</code>.</p>
    <ol>
        <li>Acquires <code>self._lock</code></li>
        <li>Increments <code>_times_shorted</code> by 1</li>
        <li>Checks if <code>_times_shorted</code> &gt;= <code>num_shorts_to_trip</code></li>
        <li>Releases <code>self._lock</code></li>
        <li>If <code>_times_shorted</code> &gt;= <code>num_shorts_to_trip</code>, calls <code>_trip_circuit()</code>:</li>
    </ol>
    <ul>
        <li>Acquires <code>self._lock</code></li>
        <li>Captures <code>sleep_duration</code> (<code>custom_sleep</code> or <code>_current_sleep_time</code>)</li>
        <li>Increments <code>_total_trips</code> by 1</li>
        <li>Resets <code>_times_shorted</code> to 0</li>
        <li>Applies backoff factor to <code>_current_sleep_time</code> (if <code>backoff_factor</code> != 1.0)</li>
        <li>Releases <code>self._lock</code></li>
        <li>Applies jitter to <code>sleep_duration</code></li>
        <li>Sleeps for <code>sleep_duration</code></li>
    </ul>
    <ol start="6">
        <li>Returns <code>True</code> if slept, <code>False</code> otherwise</li>
    </ol>
    <h4><code><suitkaise-api>trip</suitkaise-api>(custom_sleep: float | None = None) -&gt; bool</code></h4>
    <p><code><suitkaise-api>trip</suitkaise-api>()</code> immediately triggers the circuit, bypassing the short counter.</p>
    <p>If <code>custom_sleep</code> is provided, it will be used instead of <code>_current_sleep_time</code>.</p>
    <ol>
        <li>Calls <code>_trip_circuit()</code>:</li>
    </ol>
    <ul>
        <li>Acquires <code>self._lock</code></li>
        <li>Captures <code>sleep_duration</code> (<code>custom_sleep</code> or <code>_current_sleep_time</code>)</li>
        <li>Increments <code>_total_trips</code> by 1</li>
        <li>Resets <code>_times_shorted</code> to 0</li>
        <li>Applies backoff factor to <code>_current_sleep_time</code> (if <code>backoff_factor</code> != 1.0)</li>
        <li>Releases <code>self._lock</code></li>
        <li>Applies jitter to <code>sleep_duration</code></li>
        <li>Sleeps for <code>sleep_duration</code></li>
    </ul>
    <ol start="2">
        <li>Returns <code>True</code> (always sleeps)</li>
    </ol>
    <h4><code><suitkaise-api>reset_backoff</suitkaise-api>() -&gt; None</code></h4>
    <p>Restores the original sleep time to <code>sleep_time_after_trip</code>.</p>
    <ol>
        <li>Acquires <code>self._lock</code></li>
        <li>Sets <code>_current_sleep_time</code> to <code>sleep_time_after_trip</code></li>
        <li>Releases <code>self._lock</code></li>
        <li>Returns <code>None</code></li>
    </ol>
    <h3>Exponential Backoff</h3>
    <p><code><suitkaise-api>Circuit</suitkaise-api></code> supports exponential backoff to progressively increase sleep time after repeated trips.</p>
    <pre><code class="language-python">circ = <suitkaise-api>Circuit</suitkaise-api>(
    num_shorts_to_trip=5,
    sleep_time_after_trip=1.0,  # initial sleep time == 1.0s
    backoff_factor=2.0,         # double it each time it is tripped
    max_sleep_time=30.0         # sleep time is capped at 30s
)</code></pre>
    <p>With the above parameters:</p>
    <ul>
        <li>Trip 1: sleep 1.0s</li>
        <li>Trip 2: sleep 2.0s</li>
        <li>Trip 3: sleep 4.0s</li>
        <li>Trip 4: sleep 8.0s</li>
        <li>Trip 5: sleep 16.0s</li>
        <li>Trip 6: sleep 30.0s (capped)</li>
        <li>Trip 7: sleep 30.0s (capped)</li>
        <li>...</li>
    </ul>
    <p>Formula for calculating the next sleep time:</p>
    <pre><code class="language-python">_current_sleep_time = min(
    _current_sleep_time * backoff_factor,
    max_sleep_time
)</code></pre>
    <h4>Jitter and max sleep time</h4>
    <p>Jitter adds randomness to sleep durations.</p>
    <p>When multiple processes trip their circuits at the same time, they all wake up at the same time, which puts pressure on the system. Jitter spreads out the wake-up times to prevent this.</p>
    <p>The <code>jitter</code> parameter is a decimal (0.2), not a percentage (20).</p>
    <p>Values are clamped to <code>[0.0, 1.0]</code>.</p>
    <p>For a <code>jitter</code> of 0.2 and a <code>sleep_duration</code> of 1.0, the range is <code>[0.8, 1.2]</code>.</p>
    <h3>Thread Safety</h3>
    <p>All state access is protected by a reentrant lock (<code>threading.RLock</code>).</p>
    <p>A reentrant lock is needed because  <code>_trip_circuit()</code> may be called from <code><suitkaise-api>short</suitkaise-api>()</code> and <code><suitkaise-api>trip</suitkaise-api>()</code> and both need lock access.</p>
    <p>The sleep operation itself happens outside the lock to avoid blocking other threads during the sleep.</p>
    <p>All public properties acquire the lock for reads.</p>
    <pre><code class="language-python">@property
def <suitkaise-api>times_shorted</suitkaise-api>(self) -&gt; int:
    with self._lock:
        return self._times_shorted</code></pre>
    <p>This ensures that all reads are consistent and thread-safe.</p>
    <h3>Async Support</h3>
    <p><code><suitkaise-api>Circuit</suitkaise-api></code> supports async usage via the <code>_AsyncableMethod</code> pattern from <code><suitkaise-api>suitkaise</suitkaise-api>.<suitkaise-api>sk</suitkaise-api></code>.</p>
    <p><code>_AsyncableMethod</code> wraps a sync method and an async method into a single attribute that can be called either way.</p>
    <pre><code class="language-python">short = _AsyncableMethod(_sync_short, _async_short)</code></pre>
    <p>Usage:</p>
    <pre><code class="language-python"># sync usage
circ.<suitkaise-api>short</suitkaise-api>()

# async usage
await circ.<suitkaise-api>short</suitkaise-api>.<suitkaise-api>asynced</suitkaise-api>()()</code></pre>
    <p>The async versions use <code>asyncio.sleep()</code> instead of blocking <code>time.sleep()</code>:</p>
    <pre><code class="language-python">async def _async_trip_circuit(self, custom_sleep: float | None = None) -&gt; bool:
    with self._lock:
        sleep_duration = custom_sleep if custom_sleep is not None else self._current_sleep_time
        self._total_trips += 1
        self._times_shorted = 0
        
        if self.backoff_factor != 1.0:
            self._current_sleep_time = min(
                self._current_sleep_time * self.backoff_factor,
                self.max_sleep_time
            )
    
    sleep_duration = self._apply_jitter(sleep_duration)
    if sleep_duration &gt; 0:
        await asyncio.sleep(sleep_duration)
    
    return True</code></pre>
    <p>The lock usage is the same - only the sleep call differs.</p>
    <p>Methods with async support:</p>
    <ul>
        <li><code><suitkaise-api>short</suitkaise-api>()</code> - via <code><suitkaise-api>short</suitkaise-api>.<suitkaise-api>asynced</suitkaise-api>()()</code></li>
        <li><code><suitkaise-api>trip</suitkaise-api>()</code> - via <code><suitkaise-api>trip</suitkaise-api>.<suitkaise-api>asynced</suitkaise-api>()()</code></li>
    </ul>
    <p>Methods like <code><suitkaise-api>reset_backoff</suitkaise-api>()</code> and properties do not need async versions because they don&#x27;t sleep.</p>
    <h3>Share Integration</h3>
    <p><code><suitkaise-api>Circuit</suitkaise-api></code> includes <code>_shared_meta</code> for integration with <code><suitkaise-api>suitkaise</suitkaise-api>.<suitkaise-api>processing</suitkaise-api>.<suitkaise-api>Share</suitkaise-api></code>.</p>
    <p><code>_shared_meta</code> is a dictionary that declares which attributes each method/property reads from or writes to. The <code><suitkaise-api>Share</suitkaise-api></code> class uses this metadata to synchronize state across processes.</p>
    <pre><code class="language-python">_shared_meta = {
    &#x27;methods&#x27;: {
        &#x27;short&#x27;: {&#x27;writes&#x27;: [&#x27;_times_shorted&#x27;, &#x27;_total_trips&#x27;, &#x27;_current_sleep_time&#x27;]},
        &#x27;trip&#x27;: {&#x27;writes&#x27;: [&#x27;_times_shorted&#x27;, &#x27;_total_trips&#x27;, &#x27;_current_sleep_time&#x27;]},
        &#x27;reset_backoff&#x27;: {&#x27;writes&#x27;: [&#x27;_current_sleep_time&#x27;]},
    },
    &#x27;properties&#x27;: {
        &#x27;times_shorted&#x27;: {&#x27;reads&#x27;: [&#x27;_times_shorted&#x27;]},
        &#x27;total_trips&#x27;: {&#x27;reads&#x27;: [&#x27;_total_trips&#x27;]},
        &#x27;current_sleep_time&#x27;: {&#x27;reads&#x27;: [&#x27;_current_sleep_time&#x27;]},
    }
}</code></pre>
    <p>This allows a <code><suitkaise-api>Share</suitkaise-api></code> instance to wrap a circuit and automatically synchronize state across multiple processes.</p>
    <h3>Sleep Implementation</h3>
    <p><code><suitkaise-api>Circuit</suitkaise-api></code> uses <code><suitkaise-api>suitkaise</suitkaise-api>.<suitkaise-api>timing</suitkaise-api>.sleep()</code> for blocking sleeps:</p>
    <pre><code class="language-python">from <suitkaise-api>suitkaise</suitkaise-api>.<suitkaise-api>timing</suitkaise-api> import api as <suitkaise-api>timing</suitkaise-api>

# in _trip_circuit():
<suitkaise-api>timing</suitkaise-api>.sleep(sleep_duration)</code></pre>
    <p>This uses the timing module&#x27;s sleep implementation, which provides consistent behavior across different environments.</p>
    <h2><code><suitkaise-api>BreakingCircuit</suitkaise-api></code></h2>
    <p>Breaking circuit that stops when the failure threshold is reached.</p>
    <p>Unlike <code><suitkaise-api>Circuit</suitkaise-api></code>, it stays broken until you manually reset it. Use this for stopping after a threshold is reached and deciding what to do next.</p>
    <p>When the short counter reaches the <code>num_shorts_to_trip</code> threshold, the circuit breaks.</p>
    <pre><code class="language-text"><suitkaise-api>short</suitkaise-api>() -&gt; increment counter -&gt; if shorts &gt;= num_shorts_to_trip? -&gt; break -&gt; sleep (but stay broken)</code></pre>
    <p><code><suitkaise-api>BreakingCircuit</suitkaise-api></code> uses a <code>threading.RLock</code> to ensure that internal state is thread-safe.</p>
    <h3>Tracking state</h3>
    <p><code>_num_shorts_to_trip: int</code> Number of shorts required before the circuit breaks. Set at initialization.</p>
    <p><code>_times_shorted: int</code> Counter tracking shorts since the last trip/reset. Resets to 0 after each trip or reset.</p>
    <p><code>_total_trips: int</code> Lifetime count of all trips. Incremented on every <code><suitkaise-api>short</suitkaise-api>()</code> call, never resets.</p>
    <p><code>_current_sleep_time: float</code> Current sleep duration after backoff is applied. Starts at <code>sleep_time_after_trip</code> and grows with each <code><suitkaise-api>reset</suitkaise-api>()</code>.</p>
    <p><code>_broken: bool</code> Whether the circuit is currently broken. Set to <code>True</code> on trip, cleared by <code><suitkaise-api>reset</suitkaise-api>()</code>.</p>
    <p><code>_lock: threading.RLock</code> Reentrant lock for thread-safe state access.</p>
    <h3>Properties</h3>
    <p><code>num_shorts_to_trip</code>: Number of shorts required before the circuit breaks.</p>
    <ul>
        <li><code>int</code></li>
        <li>read-only</li>
    </ul>
    <p><code>broken</code>: Whether the circuit is currently broken.</p>
    <ul>
        <li><code>bool</code></li>
        <li>read-only</li>
    </ul>
    <p><code>times_shorted</code>: Counter tracking shorts since the last trip/reset. Resets to 0 after each trip or reset.</p>
    <ul>
        <li><code>int</code></li>
        <li>read-only</li>
    </ul>
    <p><code>total_trips</code>: Lifetime count of all trips. Never resets.</p>
    <ul>
        <li><code>int</code></li>
        <li>read-only</li>
    </ul>
    <p><code>current_sleep_time</code>: Current sleep duration after backoff is applied. Starts at <code>sleep_time_after_trip</code> and grows with each <code><suitkaise-api>reset</suitkaise-api>()</code>.</p>
    <ul>
        <li><code>float</code></li>
        <li>read-only</li>
    </ul>
    <h3>Methods</h3>
    <h4><code><suitkaise-api>short</suitkaise-api>(custom_sleep: float | None = None) -&gt; None</code></h4>
    <p>Increments <code>_times_shorted</code> and <code>_total_trips</code> by 1, calling <code>_break_circuit()</code> if the <code>num_shorts_to_trip</code> threshold is reached.</p>
    <p>If <code>custom_sleep</code> is provided, it will be used instead of <code>_current_sleep_time</code>.</p>
    <ol>
        <li>Captures <code>sleep_duration</code> (<code>custom_sleep</code> or <code>_current_sleep_time</code>)</li>
        <li>Acquires <code>self._lock</code></li>
        <li>Increments <code>_times_shorted</code> by 1</li>
        <li>Increments <code>_total_trips</code> by 1</li>
        <li>Checks if <code>_times_shorted</code> &gt;= <code>num_shorts_to_trip</code></li>
        <li>Releases <code>self._lock</code></li>
        <li>If <code>_times_shorted</code> &gt;= <code>num_shorts_to_trip</code>, calls <code>_break_circuit()</code>:</li>
    </ol>
    <ul>
        <li>Acquires <code>self._lock</code></li>
        <li>Sets <code>_broken</code> to <code>True</code></li>
        <li>Resets <code>_times_shorted</code> to 0</li>
        <li>Releases <code>self._lock</code></li>
        <li>Applies jitter to <code>sleep_duration</code></li>
        <li>Sleeps for <code>sleep_duration</code></li>
    </ul>
    <ol start="8">
        <li>Returns <code>None</code></li>
    </ol>
    <p>Note: Unlike <code><suitkaise-api>Circuit</suitkaise-api></code>, <code><suitkaise-api>BreakingCircuit</suitkaise-api></code> increments <code>_total_trips</code> on every <code><suitkaise-api>short</suitkaise-api>()</code> call, not just when the circuit trips.</p>
    <h4><code><suitkaise-api>trip</suitkaise-api>(custom_sleep: float | None = None) -&gt; None</code></h4>
    <p><code><suitkaise-api>trip</suitkaise-api>()</code> immediately breaks the circuit, bypassing the short counter.</p>
    <p>If <code>custom_sleep</code> is provided, it will be used instead of <code>_current_sleep_time</code>.</p>
    <ol>
        <li>Acquires <code>self._lock</code></li>
        <li>Increments <code>_total_trips</code> by 1</li>
        <li>Releases <code>self._lock</code></li>
        <li>Captures <code>sleep_duration</code> (<code>custom_sleep</code> or <code>_current_sleep_time</code>)</li>
        <li>Calls <code>_break_circuit(sleep_duration)</code>:</li>
    </ol>
    <ul>
        <li>Acquires <code>self._lock</code></li>
        <li>Sets <code>_broken</code> to <code>True</code></li>
        <li>Resets <code>_times_shorted</code> to 0</li>
        <li>Releases <code>self._lock</code></li>
        <li>Applies jitter to <code>sleep_duration</code></li>
        <li>Sleeps for <code>sleep_duration</code></li>
    </ul>
    <ol start="6">
        <li>Returns <code>None</code></li>
    </ol>
    <h4><code><suitkaise-api>reset</suitkaise-api>() -&gt; None</code></h4>
    <p>Resets the circuit to operational state and applies exponential backoff.</p>
    <ol>
        <li>Acquires <code>self._lock</code></li>
        <li>Sets <code>_broken</code> to <code>False</code></li>
        <li>Resets <code>_times_shorted</code> to 0</li>
        <li>If <code>backoff_factor</code> != 1.0:</li>
    </ol>
    <ul>
        <li>Sets <code>_current_sleep_time</code> to <code>min(_current_sleep_time * backoff_factor, max_sleep_time)</code></li>
    </ul>
    <ol start="5">
        <li>Releases <code>self._lock</code></li>
        <li>Returns <code>None</code></li>
    </ol>
    <p>Note: Unlike <code><suitkaise-api>Circuit</suitkaise-api></code> which applies backoff on trip, <code><suitkaise-api>BreakingCircuit</suitkaise-api></code> applies backoff on <code><suitkaise-api>reset</suitkaise-api>()</code>. This means the next trip will use the increased sleep time.</p>
    <h4><code><suitkaise-api>reset_backoff</suitkaise-api>() -&gt; None</code></h4>
    <p>Restores the original sleep time to <code>sleep_time_after_trip</code>.</p>
    <ol>
        <li>Acquires <code>self._lock</code></li>
        <li>Sets <code>_current_sleep_time</code> to <code>sleep_time_after_trip</code></li>
        <li>Releases <code>self._lock</code></li>
        <li>Returns <code>None</code></li>
    </ol>
    <p>Note: Does NOT reset the broken state - use <code><suitkaise-api>reset</suitkaise-api>()</code> for that.</p>
    <h3>Exponential Backoff</h3>
    <p><code><suitkaise-api>BreakingCircuit</suitkaise-api></code> supports exponential backoff to progressively increase sleep time after repeated resets.</p>
    <pre><code class="language-python">circ = <suitkaise-api>BreakingCircuit</suitkaise-api>(
    num_shorts_to_trip=5,
    sleep_time_after_trip=1.0,  # initial sleep time == 1.0s
    backoff_factor=2.0,         # double it each time <suitkaise-api>reset</suitkaise-api>() is called
    max_sleep_time=30.0         # sleep time is capped at 30s
)</code></pre>
    <p>With the above parameters:</p>
    <ul>
        <li>Trip 1: sleep 1.0s</li>
        <li>Reset 1: backoff applied, next sleep will be 2.0s</li>
        <li>Trip 2: sleep 2.0s</li>
        <li>Reset 2: backoff applied, next sleep will be 4.0s</li>
        <li>Trip 3: sleep 4.0s</li>
        <li>...</li>
    </ul>
    <p>Formula for calculating the next sleep time (applied on <code><suitkaise-api>reset</suitkaise-api>()</code>):</p>
    <pre><code class="language-python">_current_sleep_time = min(
    _current_sleep_time * backoff_factor,
    max_sleep_time
)</code></pre>
    <h4>Jitter and max sleep time</h4>
    <p>Jitter adds randomness to sleep durations.</p>
    <p>When multiple processes trip their circuits at the same time, they all wake up at the same time, which puts pressure on the system. Jitter spreads out the wake-up times to prevent this.</p>
    <p>The <code>jitter</code> parameter is a decimal (0.2), not a percentage (20).</p>
    <p>Values are clamped to <code>[0.0, 1.0]</code>.</p>
    <p>For a <code>jitter</code> of 0.2 and a <code>sleep_duration</code> of 1.0, the range is <code>[0.8, 1.2]</code>.</p>
    <h3>Thread Safety</h3>
    <p>All state access is protected by a reentrant lock (<code>threading.RLock</code>).</p>
    <p>A reentrant lock is needed because <code>_break_circuit()</code> may be called from <code><suitkaise-api>short</suitkaise-api>()</code> and <code><suitkaise-api>trip</suitkaise-api>()</code> and both need lock access.</p>
    <p>The sleep operation itself happens outside the lock to avoid blocking other threads during the sleep.</p>
    <p>All public properties acquire the lock for reads.</p>
    <pre><code class="language-python">@property
def <suitkaise-api>broken</suitkaise-api>(self) -&gt; bool:
    with self._lock:
        return self._broken</code></pre>
    <p>This ensures that all reads are consistent and thread-safe.</p>
    <h3>Async Support</h3>
    <p><code><suitkaise-api>BreakingCircuit</suitkaise-api></code> supports async usage via the <code>_AsyncableMethod</code> pattern from <code><suitkaise-api>suitkaise</suitkaise-api>.<suitkaise-api>sk</suitkaise-api></code>.</p>
    <p><code>_AsyncableMethod</code> wraps a sync method and an async method into a single attribute that can be called either way.</p>
    <pre><code class="language-python">short = _AsyncableMethod(_sync_short, _async_short)</code></pre>
    <p>Usage:</p>
    <pre><code class="language-python"># sync usage
circ.<suitkaise-api>short</suitkaise-api>()

# async usage
await circ.<suitkaise-api>short</suitkaise-api>.<suitkaise-api>asynced</suitkaise-api>()()</code></pre>
    <p>The async versions use <code>asyncio.sleep()</code> instead of blocking <code>time.sleep()</code>:</p>
    <pre><code class="language-python">async def _async_break_circuit(self, sleep_duration: float) -&gt; None:
    with self._lock:
        self._broken = True
        self._times_shorted = 0

    sleep_duration = self._apply_jitter(sleep_duration)
    if sleep_duration &gt; 0:
        await asyncio.sleep(sleep_duration)</code></pre>
    <p>The lock usage is the same - only the sleep call differs.</p>
    <p>Methods with async support:</p>
    <ul>
        <li><code><suitkaise-api>short</suitkaise-api>()</code> - via <code><suitkaise-api>short</suitkaise-api>.<suitkaise-api>asynced</suitkaise-api>()()</code></li>
        <li><code><suitkaise-api>trip</suitkaise-api>()</code> - via <code><suitkaise-api>trip</suitkaise-api>.<suitkaise-api>asynced</suitkaise-api>()()</code></li>
    </ul>
    <p>Methods like <code><suitkaise-api>reset</suitkaise-api>()</code>, <code><suitkaise-api>reset_backoff</suitkaise-api>()</code>, and properties do not need async versions because they don&#x27;t sleep.</p>
    <h3>Share Integration</h3>
    <p><code><suitkaise-api>BreakingCircuit</suitkaise-api></code> includes <code>_shared_meta</code> for integration with <code><suitkaise-api>suitkaise</suitkaise-api>.<suitkaise-api>processing</suitkaise-api>.<suitkaise-api>Share</suitkaise-api></code>.</p>
    <p><code>_shared_meta</code> is a dictionary that declares which attributes each method/property reads from or writes to. The <code><suitkaise-api>Share</suitkaise-api></code> class uses this metadata to synchronize state across processes.</p>
    <pre><code class="language-python">_shared_meta = {
    &#x27;methods&#x27;: {
        &#x27;short&#x27;: {&#x27;writes&#x27;: [&#x27;_times_shorted&#x27;, &#x27;_total_trips&#x27;, &#x27;_broken&#x27;]},
        &#x27;trip&#x27;: {&#x27;writes&#x27;: [&#x27;_total_trips&#x27;, &#x27;_broken&#x27;, &#x27;_times_shorted&#x27;]},
        &#x27;reset&#x27;: {&#x27;writes&#x27;: [&#x27;_broken&#x27;, &#x27;_times_shorted&#x27;, &#x27;_current_sleep_time&#x27;]},
        &#x27;reset_backoff&#x27;: {&#x27;writes&#x27;: [&#x27;_current_sleep_time&#x27;]},
    },
    &#x27;properties&#x27;: {
        &#x27;broken&#x27;: {&#x27;reads&#x27;: [&#x27;_broken&#x27;]},
        &#x27;times_shorted&#x27;: {&#x27;reads&#x27;: [&#x27;_times_shorted&#x27;]},
        &#x27;total_trips&#x27;: {&#x27;reads&#x27;: [&#x27;_total_trips&#x27;]},
        &#x27;current_sleep_time&#x27;: {&#x27;reads&#x27;: [&#x27;_current_sleep_time&#x27;]},
    }
}</code></pre>
    <p>This allows a <code><suitkaise-api>Share</suitkaise-api></code> instance to wrap a circuit and automatically synchronize state across multiple processes.</p>
    <h3>Sleep Implementation</h3>
    <p><code><suitkaise-api>BreakingCircuit</suitkaise-api></code> uses <code><suitkaise-api>suitkaise</suitkaise-api>.<suitkaise-api>timing</suitkaise-api>.sleep()</code> for blocking sleeps:</p>
    <pre><code class="language-python">from <suitkaise-api>suitkaise</suitkaise-api>.<suitkaise-api>timing</suitkaise-api> import api as <suitkaise-api>timing</suitkaise-api>

# in _break_circuit():
<suitkaise-api>timing</suitkaise-api>.sleep(sleep_duration)</code></pre>
    <p>This uses the timing module&#x27;s sleep implementation, which provides consistent behavior across different environments.</p>
</section>
