<div class="module-bar" data-module="sk">
    <button class="module-bar-title">suitkaise.sk</button>
    <nav class="module-bar-nav">
        <a href="#sk-why" class="module-bar-link" data-page="sk-why">why</a>
        <a href="#sk-quick-start" class="module-bar-link active" data-page="sk-quick-start">quick start</a>
        <a href="#sk" class="module-bar-link" data-page="sk">how to use</a>
        <a href="#sk-how-it-works" class="module-bar-link" data-page="sk-how-it-works">how it works</a>
        <a href="#sk-examples" class="module-bar-link" data-page="sk-examples">examples</a>
        <a href="#sk-blocking-calls" class="module-bar-link" data-page="sk-blocking-calls">blocking calls</a>
        <a href="#sk-videos" class="module-bar-link" data-page="sk-videos">videos</a>
        <a href="#sk-tests" class="module-bar-link" data-page="sk-tests">tests</a>
        <a href="#sk-learn" class="module-bar-link" data-page="sk-learn">learn</a>
    </nav>
</div>
<section class="module-page">
    <h1>Quick Start: <code>sk</code></h1>
    <pre><code class="language-bash">pip install suitkaise</code></pre>
    <h2>Add modifiers to a function</h2>
    <pre><code class="language-python">from suitkaise import sk

@sk
def fetch(url):
    return requests.get(url).json()

# normal call — works exactly like before
data = fetch(&quot;https://api.example.com&quot;)

# retry 3 times
data = fetch.retry(times=3)(&quot;https://api.example.com&quot;)

# timeout after 5 seconds
data = fetch.timeout(5.0)(&quot;https://api.example.com&quot;)

# run in background, get a Future
future = fetch.background()(&quot;https://api.example.com&quot;)
result = future.result()

# rate limit to 2 calls per second
data = fetch.rate_limit(2.0)(&quot;https://api.example.com&quot;)

# async
data = await fetch.asynced()(&quot;https://api.example.com&quot;)</code></pre>
    <h2>Chain modifiers</h2>
    <pre><code class="language-python"># retry 3 times, 5 second timeout per attempt
data = fetch.retry(3).timeout(5.0)(&quot;https://api.example.com&quot;)

# order doesn&#x27;t matter — these are identical
data = fetch.timeout(5.0).retry(3)(&quot;https://api.example.com&quot;)</code></pre>
    <h2>Use on classes</h2>
    <pre><code class="language-python">@sk
class DataProcessor:
    def __init__(self, config):
        self.config = config

    def process(self, data):
        return transform(data)

    def save(self, path):
        with open(path, &#x27;w&#x27;) as f:
            f.write(json.dumps(self.results))

processor = DataProcessor(config)

# normal call
processor.process(data)

# with modifiers
processor.process.retry(3)(data)
processor.save.timeout(10.0)(&quot;output.json&quot;)
future = processor.save.background()(&quot;output.json&quot;)</code></pre>
    <h2>Mark blocking code explicitly</h2>
    <p>When AST detection misses CPU-intensive work:</p>
    <pre><code class="language-python">from suitkaise import sk, blocking

@sk
@blocking
def heavy_computation():
    return sum(x**2 for x in range(10_000_000))

# now .asynced() and .background() are available
result = await heavy_computation.asynced()()</code></pre>
    <h2>Check for blocking calls</h2>
    <pre><code class="language-python">@sk
def slow_fetch(url):
    return requests.get(url).text

print(slow_fetch.has_blocking_calls)  # True
print(slow_fetch.blocking_calls)      # [&#x27;requests.get&#x27;]</code></pre>
    <h2>Want to learn more?</h2>
    <ul>
        <li><strong>Why page</strong> — why <code>sk</code> exists, the call-site modifier pattern, and <code>_shared_meta</code> for <code>Share</code></li>
        <li><strong>How to use</strong> — full API reference for all modifiers</li>
        <li><strong>Examples</strong> — progressively complex examples into a full script</li>
        <li><strong>How it works</strong> — AST analysis, <code>Skfunction</code> wrappers, execution order (level: intermediate)</li>
    </ul>
</section>
