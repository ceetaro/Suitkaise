<div class="module-bar" data-module="circuits">
    <button class="module-bar-title">suitkaise.circuits</button>
    <nav class="module-bar-nav">
        <a href="#circuits-why" class="module-bar-link" data-page="circuits-why">why</a>
        <a href="#circuits-quick-start" class="module-bar-link" data-page="circuits-quick-start">quick start</a>
        <a href="#circuits" class="module-bar-link" data-page="circuits">how to use</a>
        <a href="#circuits-how-it-works" class="module-bar-link" data-page="circuits-how-it-works">how it works</a>
        <a href="#circuits-examples" class="module-bar-link active" data-page="circuits-examples">examples</a>
        <a href="#circuits-videos" class="module-bar-link" data-page="circuits-videos">videos</a>
        <a href="#circuits-learn" class="module-bar-link" data-page="circuits-learn">learn</a>
    </nav>
</div>
<section class="module-page">
    <h1><code><suitkaise-api>circuits</suitkaise-api></code> examples</h1>
    <details>
        <summary>Common Patterns</summary>
        <div class="dropdown-content">
    <details>
        <summary><code><suitkaise-api>Circuit</suitkaise-api></code></summary>
        <div class="dropdown-content">
    <p>Use <code><suitkaise-api>Circuit</suitkaise-api></code> when you want to automatically continue after a cooldown.</p>
    <pre><code class="language-python">from <suitkaise-api>suitkaise</suitkaise-api> import <suitkaise-api>Circuit</suitkaise-api>

# create a circuit that:
# - trips after 10 shorts
# - sleeps 1 second on first trip
# - increases sleep by 1.5x after each trip (1s → 1.5s → 2.25s → ...)
# - caps sleep at 30 seconds max
<suitkaise-api>rate_limiter</suitkaise-api> = <suitkaise-api>Circuit(</suitkaise-api>
    num_shorts_to_trip=10,
    sleep_time_after_trip=1.0,
    backoff_factor=1.5,
    max_sleep_time=30.0
)

for request in incoming_requests:
    # check if this request is rate limited
    if is_rate_limited(request):
        # count the rate limit as a &quot;short&quot;
        # after 10 shorts, circuit trips: sleeps, then auto-resets counter
        # short() returns True if it slept, False otherwise
        <suitkaise-api>rate_limiter.short()</suitkaise-api>
    else:
        # not rate limited, process normally
        process(request)</code></pre>
        </div>
    </details>
    <details>
        <summary><code><suitkaise-api>BreakingCircuit</suitkaise-api></code></summary>
        <div class="dropdown-content">
    <p>Use <code><suitkaise-api>BreakingCircuit</suitkaise-api></code> when you want to stop after too many failures.</p>
    <pre><code class="language-python">from <suitkaise-api>suitkaise</suitkaise-api> import <suitkaise-api>BreakingCircuit</suitkaise-api>

# create a circuit that:
# - breaks after 3 shorts
# - sleeps 1 second when it breaks
# - stays broken until manually reset
<suitkaise-api>circ</suitkaise-api> = <suitkaise-api>BreakingCircuit(</suitkaise-api>
    num_shorts_to_trip=3,
    sleep_time_after_trip=1.0
)

# loop continues as long as circuit is not broken
while not <suitkaise-api>circ.broken</suitkaise-api>:
    try:
        # attempt the risky operation
        result = risky_operation()
        # success - exit the retry loop
        break
    except OperationError:
        # failure - count it as a short
        # after 3 failures, circuit.broken becomes True
        <suitkaise-api>circ.short()</suitkaise-api>

# check if we exited because circuit broke
if <suitkaise-api>circ.broken</suitkaise-api>:
    # handle the failure case (e.g., log, alert, fallback)
    handle_failure()</code></pre>
        </div>
    </details>
    <details>
        <summary>Dual usage</summary>
        <div class="dropdown-content">
    <p>Use <code><suitkaise-api>BreakingCircuit</suitkaise-api></code> for inner retries and <code><suitkaise-api>Circuit</suitkaise-api></code> for outer rate limiting.</p>
    <pre><code class="language-python">from <suitkaise-api>suitkaise</suitkaise-api> import <suitkaise-api>Circuit</suitkaise-api>, <suitkaise-api>BreakingCircuit</suitkaise-api>

# outer circuit: rate limits the overall process
# - trips after 5 item failures
# - sleeps 5 seconds, then continues to next item
<suitkaise-api>outer</suitkaise-api> = <suitkaise-api>Circuit(</suitkaise-api>num_shorts_to_trip=5, sleep_time_after_trip=5.0)

# inner circuit: controls retries for each item
# - breaks after 3 failed attempts
# - sleeps 0.5 seconds between retries
<suitkaise-api>inner</suitkaise-api> = <suitkaise-api>BreakingCircuit(</suitkaise-api>num_shorts_to_trip=3, sleep_time_after_trip=0.5)

for item in items:
    # reset inner circuit for each new item
    # this clears the broken flag and short counter
    <suitkaise-api>inner.reset()</suitkaise-api>
    
    # retry loop for this item
    while not <suitkaise-api>inner.broken</suitkaise-api>:
        try:
            # attempt to process
            process(item)
            # success - exit retry loop, move to next item
            break
        except TransientError:
            # transient failure - count it
            # after 3 failures, inner.broken becomes True
            <suitkaise-api>inner.short()</suitkaise-api>
    
    # if inner circuit broke, this item completely failed
    if <suitkaise-api>inner.broken</suitkaise-api>:
        # count it as a failure for the outer circuit
        # after 5 failed items, outer circuit sleeps
        <suitkaise-api>outer.short()</suitkaise-api></code></pre>
        </div>
    </details>
    <details>
        <summary>Async pattern</summary>
        <div class="dropdown-content">
    <pre><code class="language-python">import asyncio
import aiohttp
from <suitkaise-api>suitkaise</suitkaise-api> import <suitkaise-api>Circuit</suitkaise-api>

# create circuit for rate limiting
# - trips after 5 rate limit responses
# - sleeps 2 seconds (using asyncio.sleep, not blocking)
# - doubles sleep time after each trip
# - adds ±20% randomness to prevent thundering herd
<suitkaise-api>circ</suitkaise-api> = <suitkaise-api>Circuit(</suitkaise-api>
    num_shorts_to_trip=5,
    sleep_time_after_trip=2.0,
    backoff_factor=2.0,
    jitter=0.2
)

async def fetch_url(session: aiohttp.ClientSession, url: str) -&gt; dict | None:
    &quot;&quot;&quot;Fetch a single URL with circuit breaker protection.&quot;&quot;&quot;
    try:
        # make the async HTTP request
        async with session.get(url) as response:
            # check for rate limiting (HTTP 429)
            if response.status == 429:
                # count rate limit as a short
                # .asynced()() returns an async version that uses asyncio.sleep
                # first () gets the async function, second () calls it
                await <suitkaise-api>circ.short</suitkaise-api>.<suitkaise-api>asynced</suitkaise-api>()()
                # return None to indicate we didn&#x27;t get data
                return None
            
            # success - parse and return JSON
            return await response.json()
    
    except aiohttp.ClientError:
        # network error - also count as a short
        await <suitkaise-api>circ.short</suitkaise-api>.<suitkaise-api>asynced</suitkaise-api>()()
        return None

async def fetch_all(urls: list[str]) -&gt; list[dict]:
    &quot;&quot;&quot;Fetch multiple URLs sequentially with shared circuit.&quot;&quot;&quot;
    results = []
    
    # create a single session for all requests
    async with aiohttp.ClientSession() as session:
        for url in urls:
            # fetch each URL
            result = await fetch_url(session, url)
            # only keep successful results
            if result:
                results.append(result)
    
    return results

async def main():
    urls = [
        &quot;https://api.example.com/data/1&quot;,
        &quot;https://api.example.com/data/2&quot;,
        &quot;https://api.example.com/data/3&quot;,
    ]
    
    # fetch all URLs
    results = await fetch_all(urls)
    
    # print summary
    print(f&quot;Fetched {len(results)} results&quot;)
    print(f&quot;Circuit tripped {circ.total_trips} times&quot;)

# run the async main function
asyncio.run(main())</code></pre>
        </div>
    </details>
    <details>
        <summary>Multithreading with a shared circuit</summary>
        <div class="dropdown-content">
    <p>Multiple threads share a <code><suitkaise-api>BreakingCircuit</suitkaise-api></code>. When one thread breaks it, the others stop immediately.</p>
    <pre><code class="language-python">import threading
from queue import Queue
from <suitkaise-api>suitkaise</suitkaise-api> import <suitkaise-api>BreakingCircuit</suitkaise-api>

def worker(worker_id: int, queue: Queue, circuit: <suitkaise-api>BreakingCircuit</suitkaise-api>, results: list):
    &quot;&quot;&quot;Worker function that processes items from a shared queue.&quot;&quot;&quot;
    
    # loop continues as long as circuit is not broken
    # when ANY thread breaks the circuit, ALL threads see it
    while not <suitkaise-api>circuit.broken</suitkaise-api>:
        # try to get an item from the queue
        try:
            # timeout allows us to periodically check circuit.broken
            item = queue.get(timeout=0.1)
        except:
            # queue is empty or timed out
            # loop back to check circuit.broken again
            continue
        
        try:
            # attempt to process the item
            result = process_item(item)
            # success - add to shared results
            results.append(result)
        
        except FatalError:
            # fatal error - immediately break circuit for ALL workers
            print(f&quot;Worker {worker_id}: Fatal error, breaking circuit&quot;)
            # trip() immediately sets circuit.broken = True
            <suitkaise-api>circuit.trip()</suitkaise-api>
        
        except TransientError:
            # transient error - count it
            # after threshold, circuit.broken becomes True
            <suitkaise-api>circuit.short()</suitkaise-api>
        
        finally:
            # always mark task as done (for queue.join())
            queue.task_done()
    
    # we exit the loop when circuit.broken is True
    print(f&quot;Worker {worker_id}: Circuit broken, stopping&quot;)


# MAIN CODE

# create a shared circuit
# - breaks after 5 transient errors across ALL workers
# - no sleep time (we just want to stop, not pause)
<suitkaise-api>circuit</suitkaise-api> = <suitkaise-api>BreakingCircuit(</suitkaise-api>num_shorts_to_trip=5, sleep_time_after_trip=0.0)

# create a shared queue for work items
queue = Queue()

# shared list for results (thread-safe for append)
results = []

# fill the queue with work items
for item in items:
    queue.put(item)

# start 4 worker threads
threads = []
for i in range(4):
    # each thread gets the same circuit, queue, and results list
    t = threading.Thread(target=worker, args=(i, queue, circuit, results))
    t.start()
    threads.append(t)

# wait for all threads to finish
for t in threads:
    t.join()

# check final state
if <suitkaise-api>circuit.broken</suitkaise-api>:
    # some items were not processed
    print(f&quot;Stopped early: {queue.qsize()} items remaining&quot;)
    # optionally reset and retry later
    <suitkaise-api>circuit.reset()</suitkaise-api>
else:
    print(f&quot;All items processed: {len(results)} results&quot;)</code></pre>
    <p>When any worker calls <code><suitkaise-api>circuit.trip()</suitkaise-api></code> or <code><suitkaise-api>circuit.short()</suitkaise-api></code> enough times, all workers see <code><suitkaise-api>circuit.broken</suitkaise-api> == True</code> and exit their loops. This provides coordinated shutdown across threads.</p>
        </div>
    </details>
        </div>
    </details>
    <details>
        <summary>More specific examples</summary>
        <div class="dropdown-content">
    <details>
        <summary>API client with circuit breaker</summary>
        <div class="dropdown-content">
    <pre><code class="language-python">import requests
from <suitkaise-api>suitkaise</suitkaise-api> import <suitkaise-api>BreakingCircuit</suitkaise-api>

class APIClient:
    &quot;&quot;&quot;API client with circuit breaker for fault tolerance.&quot;&quot;&quot;
    
    def __init__(self, base_url: str):
        self.base_url = base_url
        
        # create circuit breaker
        # - breaks after 3 consecutive failures
        # - sleeps 1 second when broken (before user can retry)
        # - doubles sleep time after each reset (1s → 2s → 4s → ...)
        # - caps at 60 seconds max
        # - adds ±10% randomness
        self.<suitkaise-api>circuit</suitkaise-api> = <suitkaise-api>BreakingCircuit(</suitkaise-api>
            num_shorts_to_trip=3,
            sleep_time_after_trip=1.0,
            backoff_factor=2.0,
            max_sleep_time=60.0,
            jitter=0.1
        )
    
    def get(self, endpoint: str) -&gt; dict | None:
        &quot;&quot;&quot;Make a GET request with circuit breaker protection.&quot;&quot;&quot;
        
        # first, check if circuit is broken
        # if broken, fail fast without making request
        if self.<suitkaise-api>circuit.broken</suitkaise-api>:
            return None
        
        try:
            # make the HTTP request
            response = requests.get(
                f&quot;{self.base_url}/{endpoint}&quot;,
                timeout=5  # 5 second timeout
            )
            # raise exception for 4xx/5xx status codes
            response.raise_for_status()
            # success - return parsed JSON
            return response.json()
        
        except requests.RequestException:
            # any request error (timeout, connection, HTTP error)
            # count as a short - may break circuit
            self.<suitkaise-api>circuit.short()</suitkaise-api>
            return None
    
    def reset(self):
        &quot;&quot;&quot;Reset the circuit to try again.&quot;&quot;&quot;
        self.<suitkaise-api>circuit.reset()</suitkaise-api>


# USAGE

# create client
client = APIClient(&quot;https://api.example.com&quot;)

for user_id in user_ids:
    # try to fetch user data
    data = client.get(f&quot;users/{user_id}&quot;)
    
    if data:
        # success - process the data
        process_user(data)
    
    elif client.<suitkaise-api>circuit.broken</suitkaise-api>:
        # circuit is broken - API is down
        # stop making requests
        print(&quot;API is down, stopping&quot;)
        break
    
    # else: request failed but circuit not broken yet
    # continue to next user

# later, when we want to try again
client.reset()</code></pre>
        </div>
    </details>
    <details>
        <summary>Database connection pool</summary>
        <div class="dropdown-content">
    <pre><code class="language-python">from <suitkaise-api>suitkaise</suitkaise-api> import <suitkaise-api>BreakingCircuit</suitkaise-api>

class ConnectionPool:
    &quot;&quot;&quot;Connection pool with circuit breaker for database failures.&quot;&quot;&quot;
    
    def __init__(self, max_connections: int = 10):
        self.max_connections = max_connections
        
        # circuit breaker for connection failures
        # - breaks after 5 failed connection attempts
        # - sleeps 0.5 seconds when broken
        # - increases sleep by 1.5x after each reset
        # - caps at 5 seconds
        self.<suitkaise-api>circuit</suitkaise-api> = <suitkaise-api>BreakingCircuit(</suitkaise-api>
            num_shorts_to_trip=5,
            sleep_time_after_trip=0.5,
            backoff_factor=1.5,
            max_sleep_time=5.0
        )
    
    def get_connection(self):
        &quot;&quot;&quot;Get a database connection with circuit breaker protection.&quot;&quot;&quot;
        
        # fail fast if circuit is broken
        if self.<suitkaise-api>circuit.broken</suitkaise-api>:
            raise ConnectionPoolExhausted(&quot;Circuit breaker is open&quot;)
        
        try:
            # attempt to acquire a connection
            return self._acquire_connection()
        
        except ConnectionError:
            # connection failed - count it
            self.<suitkaise-api>circuit.short()</suitkaise-api>
            # re-raise so caller knows it failed
            raise
    
    def mark_healthy(self):
        &quot;&quot;&quot;Call when operations succeed to reset the circuit.&quot;&quot;&quot;
        
        # only reset if currently broken
        if self.<suitkaise-api>circuit.broken</suitkaise-api>:
            # reset the broken flag
            self.<suitkaise-api>circuit.reset()</suitkaise-api>
            # also reset backoff to original sleep time
            self.<suitkaise-api>circuit.reset_backoff()</suitkaise-api>
    
    def _acquire_connection(self):
        &quot;&quot;&quot;Internal method to actually get a connection.&quot;&quot;&quot;
        # ... implementation details ...
        pass</code></pre>
        </div>
    </details>
    <details>
        <summary>File processor with rate limiting</summary>
        <div class="dropdown-content">
    <pre><code class="language-python">from pathlib import Path
from <suitkaise-api>suitkaise</suitkaise-api> import <suitkaise-api>Circuit</suitkaise-api>

def process_files(directory: Path, max_errors_per_batch: int = 10):
    &quot;&quot;&quot;Process all .txt files with automatic pausing on errors.&quot;&quot;&quot;
    
    # circuit for error rate limiting
    # - trips after max_errors_per_batch errors
    # - sleeps 5 seconds on first trip
    # - doubles sleep time after each trip
    # - caps at 60 seconds
    <suitkaise-api>circ</suitkaise-api> = <suitkaise-api>Circuit(</suitkaise-api>
        num_shorts_to_trip=max_errors_per_batch,
        sleep_time_after_trip=5.0,
        backoff_factor=2.0,
        max_sleep_time=60.0
    )
    
    # counters for summary
    processed = 0
    errors = 0
    
    # iterate over all .txt files recursively
    for file_path in directory.rglob(&quot;*.txt&quot;):
        try:
            # attempt to process the file
            process_file(file_path)
            # success - increment counter
            processed += 1
        
        except ProcessingError as e:
            # error - increment counter and log
            errors += 1
            print(f&quot;Error processing {file_path}: {e}&quot;)
            
            # count the error as a short
            # short() returns True if circuit tripped and slept
            if <suitkaise-api>circ.short()</suitkaise-api>:
                # we just paused - log it
                print(f&quot;Too many errors, paused for {circ.current_sleep_time:.1f}s&quot;)
    
    # print summary
    print(f&quot;Processed: {processed}, Errors: {errors}, Trips: {circ.total_trips}&quot;)</code></pre>
        </div>
    </details>
    <details>
        <summary>Worker with graceful degradation</summary>
        <div class="dropdown-content">
    <pre><code class="language-python">from <suitkaise-api>suitkaise</suitkaise-api> import <suitkaise-api>Circuit</suitkaise-api>, <suitkaise-api>BreakingCircuit</suitkaise-api>

class Worker:
    &quot;&quot;&quot;Worker that falls back to secondary service if primary fails.&quot;&quot;&quot;
    
    def __init__(self):
        # primary service circuit - auto-recovers
        # - trips after 3 failures
        # - sleeps 1 second, then auto-resets
        # - doubles sleep time after each trip
        # - caps at 30 seconds
        self.<suitkaise-api>primary</suitkaise-api> = <suitkaise-api>Circuit(</suitkaise-api>
            num_shorts_to_trip=3,
            sleep_time_after_trip=1.0,
            backoff_factor=2.0,
            max_sleep_time=30.0
        )
        
        # fallback service circuit - stops if it also fails
        # - breaks after 5 failures
        # - sleeps 0.5 seconds when broken
        self.<suitkaise-api>fallback</suitkaise-api> = <suitkaise-api>BreakingCircuit(</suitkaise-api>
            num_shorts_to_trip=5,
            sleep_time_after_trip=0.5
        )
    
    def process(self, item):
        &quot;&quot;&quot;Process an item, falling back to secondary service if needed.&quot;&quot;&quot;
        
        # STEP 1: try primary service
        try:
            return self._process_primary(item)
        except PrimaryServiceError:
            # primary failed - count it
            # circuit will sleep if threshold reached
            self.primary.<suitkaise-api>short</suitkaise-api>()
        
        # STEP 2: try fallback service (only if not broken)
        if not self.fallback.<suitkaise-api>broken</suitkaise-api>:
            try:
                return self._process_fallback(item)
            except FallbackServiceError:
                # fallback also failed - count it
                # may break the fallback circuit
                self.fallback.<suitkaise-api>short</suitkaise-api>()
        
        # STEP 3: both services failed
        return None
    
    def _process_primary(self, item):
        &quot;&quot;&quot;Process using primary service.&quot;&quot;&quot;
        # ... implementation ...
        pass
    
    def _process_fallback(self, item):
        &quot;&quot;&quot;Process using fallback service.&quot;&quot;&quot;
        # ... implementation ...
        pass</code></pre>
        </div>
    </details>
    <details>
        <summary>Monitoring circuit state</summary>
        <div class="dropdown-content">
    <pre><code class="language-python">from <suitkaise-api>suitkaise</suitkaise-api> import <suitkaise-api>Circuit</suitkaise-api>, <suitkaise-api>BreakingCircuit</suitkaise-api>

def log_circuit_state(name: str, circ: <suitkaise-api>Circuit</suitkaise-api> | <suitkaise-api>BreakingCircuit</suitkaise-api>):
    &quot;&quot;&quot;Log the current state of a circuit.&quot;&quot;&quot;
    
    print(f&quot;[{name}]&quot;)
    
    # shorts: how many failures since last trip/reset
    # num_shorts_to_trip: threshold before trip
    print(f&quot;  shorts: {circ.times_shorted}/{circ.num_shorts_to_trip}&quot;)
    
    # total_trips: lifetime count of all trips
    print(f&quot;  total trips: {circ.total_trips}&quot;)
    
    # current_sleep_time: sleep duration (after backoff applied)
    print(f&quot;  current sleep: {circ.current_sleep_time:.2f}s&quot;)
    
    # broken: only exists on BreakingCircuit
    if isinstance(circ, <suitkaise-api>BreakingCircuit</suitkaise-api>):
        print(f&quot;  broken: {circ.broken}&quot;)


# USAGE

# create a circuit
<suitkaise-api>circ</suitkaise-api> = <suitkaise-api>Circuit(</suitkaise-api>
    num_shorts_to_trip=5,
    sleep_time_after_trip=1.0,
    backoff_factor=2.0
)

# process real files and count failures
from pathlib import Path
import json

data_dir = Path(&quot;data/circuits&quot;)
data_dir.mkdir(parents=True, exist_ok=True)

# seed files (some invalid)
files = []
for i in range(20):
    path = data_dir / f&quot;item_{i}.json&quot;
    content = json.dumps({&quot;id&quot;: i}) if i % 6 else &#x27;{&quot;id&quot;:&#x27;
    path.write_text(content)
    files.append(path)

for path in files:
    try:
        json.loads(path.read_text())
    except json.JSONDecodeError:
        # count a short on bad input
        <suitkaise-api>circ.short()</suitkaise-api>
    
    # check if we just tripped (counter resets to 0 after trip)
    if <suitkaise-api>circ.times_shorted</suitkaise-api> == 0:
        # log the state right after a trip
        log_circuit_state(&quot;my_circuit&quot;, circ)</code></pre>
        </div>
    </details>
        </div>
    </details>
    <h2>Full script using <code><suitkaise-api>circuits</suitkaise-api></code></h2>
    <p>A web scraper with rate limiting and failure handling.</p>
    <pre><code class="language-python">&quot;&quot;&quot;
In-memory scraper with circuit breakers for rate limiting and failures.

Uses two <suitkaise-api>circuits</suitkaise-api>:
- <suitkaise-api>Circuit</suitkaise-api> for rate limiting (auto-recovers after cooldown)
- <suitkaise-api>BreakingCircuit</suitkaise-api> for failures (stops after too many errors)
&quot;&quot;&quot;

import asyncio
import json
import hashlib
from dataclasses import dataclass
from <suitkaise-api>suitkaise</suitkaise-api> import <suitkaise-api>Circuit</suitkaise-api>, <suitkaise-api>BreakingCircuit</suitkaise-api>


@dataclass
class ScrapeResult:
    &quot;&quot;&quot;Result of scraping a single URL.&quot;&quot;&quot;
    url: str
    status: str  # &quot;success&quot;, &quot;rate_limited&quot;, &quot;server_error&quot;, &quot;client_error&quot;, &quot;skipped&quot;
    data: dict | None = None
    error: str | None = None


class WebScraper:
    &quot;&quot;&quot;Scraper with circuit breaker protection (in-memory data).&quot;&quot;&quot;
    
    def __init__(
        self,
        data_store: dict[str, tuple[int, dict]],
        max_rate_limits: int = 10,
        max_failures: int = 5,
        rate_limit_sleep: float = 2.0,
        failure_sleep: float = 1.0,
    ):
        self.data_store = data_store
        # CIRCUIT 1: rate limiting
        self.<suitkaise-api>rate_limiter</suitkaise-api> = <suitkaise-api>Circuit(</suitkaise-api>
            num_shorts_to_trip=max_rate_limits,
            sleep_time_after_trip=rate_limit_sleep,
            backoff_factor=1.5,
            max_sleep_time=30.0,
            jitter=0.2
        )
        # CIRCUIT 2: failure handling
        self.<suitkaise-api>failure_circuit</suitkaise-api> = <suitkaise-api>BreakingCircuit(</suitkaise-api>
            num_shorts_to_trip=max_failures,
            sleep_time_after_trip=failure_sleep,
            backoff_factor=2.0,
            max_sleep_time=60.0,
            jitter=0.1
        )
    
    async def scrape(self, urls: list[str]) -&gt; list[ScrapeResult]:
        &quot;&quot;&quot;Scrape multiple URLs with circuit breaker protection.&quot;&quot;&quot;
        results = []
        for url in urls:
            if self.failure_circuit.broken:
                results.append(ScrapeResult(
                    url=url,
                    status=&quot;skipped&quot;,
                    error=&quot;Too many failures, circuit broken&quot;
                ))
                continue
            result = await self._scrape_url(url)
            results.append(result)
        return results
    
    async def _scrape_url(self, url: str) -&gt; ScrapeResult:
        &quot;&quot;&quot;Scrape a single URL with error handling.&quot;&quot;&quot;
        status, payload = self.data_store[url]
        
        # perform real work regardless of status
        data_bytes = json.dumps(payload).encode()
        digest = hashlib.sha256(data_bytes).hexdigest()
        
        if status == 429:
            await self.<suitkaise-api>rate_limiter.short</suitkaise-api>.<suitkaise-api>asynced</suitkaise-api>()()
            return ScrapeResult(url=url, status=&quot;rate_limited&quot;)
        
        if status &gt;= 500:
            await self.failure_circuit.short.<suitkaise-api>asynced</suitkaise-api>()()
            return ScrapeResult(url=url, status=&quot;server_error&quot;, error=f&quot;HTTP {status}&quot;)
        
        if status &gt;= 400:
            return ScrapeResult(url=url, status=&quot;client_error&quot;, error=f&quot;HTTP {status}&quot;)
        
        # success: parse and return with hash
        data = json.loads(data_bytes)
        data[&quot;hash&quot;] = digest[:8]
        return ScrapeResult(url=url, status=&quot;success&quot;, data=data)
    
    def get_stats(self) -&gt; dict:
        &quot;&quot;&quot;Get current circuit statistics.&quot;&quot;&quot;
        return {
            &quot;rate_limit_trips&quot;: self.<suitkaise-api>rate_limiter.total_trips</suitkaise-api>,
            &quot;rate_limit_sleep&quot;: self.<suitkaise-api>rate_limiter.current_sleep_time</suitkaise-api>,
            &quot;failure_trips&quot;: self.failure_circuit.total_trips,
            &quot;failure_circuit_broken&quot;: self.failure_circuit.broken,
        }
    
    def reset(self):
        &quot;&quot;&quot;Reset circuits for a new batch of URLs.&quot;&quot;&quot;
        self.failure_circuit.reset()
        self.<suitkaise-api>rate_limiter.reset_backoff()</suitkaise-api>
        self.failure_circuit.reset_backoff()


async def main():
    # in-memory responses: url -&gt; (status_code, payload)
    data_store = {
        &quot;mem://users/1&quot;: (200, {&quot;id&quot;: 1, &quot;name&quot;: &quot;Ada&quot;}),
        &quot;mem://users/2&quot;: (200, {&quot;id&quot;: 2, &quot;name&quot;: &quot;Lin&quot;}),
        &quot;mem://users/3&quot;: (429, {&quot;detail&quot;: &quot;rate limited&quot;}),
        &quot;mem://users/4&quot;: (500, {&quot;detail&quot;: &quot;server error&quot;}),
        &quot;mem://users/5&quot;: (404, {&quot;detail&quot;: &quot;not found&quot;}),
    }
    
    urls = list(data_store.keys())
    
    scraper = WebScraper(
        data_store=data_store,
        max_rate_limits=2,
        max_failures=2,
        rate_limit_sleep=2.0,
        failure_sleep=1.0,
    )
    
    results = await scraper.scrape(urls)
    
    success = sum(1 for r in results if r.status == &quot;success&quot;)
    failed = sum(1 for r in results if r.status in (&quot;server_error&quot;,))
    skipped = sum(1 for r in results if r.status == &quot;skipped&quot;)
    
    print(f&quot;Results: {success} success, {failed} failed, {skipped} skipped&quot;)
    print(f&quot;Stats: {scraper.get_stats()}&quot;)
    
    if scraper.failure_circuit.broken:
        print(&quot;Circuit broke, will reset and retry later...&quot;)
        scraper.reset()


if __name__ == &quot;__main__&quot;:
    asyncio.run(main())</code></pre>
</section>
