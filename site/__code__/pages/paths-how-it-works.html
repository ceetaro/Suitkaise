<div class="module-bar" data-module="paths">
    <button class="module-bar-title">suitkaise.paths</button>
    <nav class="module-bar-nav">
        <a href="#paths-why" class="module-bar-link" data-page="paths-why">why</a>
        <a href="#paths-quick-start" class="module-bar-link" data-page="paths-quick-start">quick start</a>
        <a href="#paths" class="module-bar-link" data-page="paths">how to use</a>
        <a href="#paths-how-it-works" class="module-bar-link active" data-page="paths-how-it-works">how it works</a>
        <a href="#paths-examples" class="module-bar-link" data-page="paths-examples">examples</a>
        <a href="#paths-videos" class="module-bar-link" data-page="paths-videos">videos</a>
        <a href="#paths-tests" class="module-bar-link" data-page="paths-tests">tests</a>
        <a href="#paths-learn" class="module-bar-link" data-page="paths-learn">learn</a>
    </nav>
</div>
<section class="module-page">
    <h1>How <code>paths</code> actually works</h1>
    <p><code>paths</code> provides project-aware path handling, streamlining how you handle paths and ensuring cross-platform compatibility.</p>
    <ul>
        <li><code>Skpath</code> - enhanced path object with automatic project root detection</li>
        <li><code>autopath</code> - decorator for automatic path type conversion</li>
        <li><code>AnyPath</code> - streamline path handling using this union type</li>
        <li>utility functions for project paths, validation, and sanitization</li>
    </ul>
    <p>All paths use normalized separators (<code>/</code>) internally for cross-platform consistency.</p>
    <h2><code>Skpath</code></h2>
    <p>Enhanced path object that wraps <code>pathlib.Path</code>.</p>
    <p>Arguments <code>path</code>: Path to wrap.</p>
    <ul>
        <li><code>str | Path | Skpath | None = None</code></li>
        <li>If <code>None</code>, uses the caller&#x27;s file path</li>
    </ul>
    <p>Returns <code>Skpath</code>: A new <code>Skpath</code> object.</p>
    <p>When you create an <code>Skpath</code>, it automatically:</p>
    <ol>
        <li>Detects the project root</li>
        <li>Computes the absolute path (<code>ap</code>)</li>
        <li>Computes the relative path to root (<code>rp</code>)</li>
        <li>Generates a reversible encoded ID (<code>id</code>)</li>
    </ol>
    <pre><code class="language-python">Skpath(&quot;feature/file.txt&quot;) → detects root → computes ap, rp, id</code></pre>
    <p><code>Skpath</code> defines a module-level <code>threading.RLock</code> (<code>_skpath_lock</code>) for potential thread-safe operations.</p>
    <h3>Tracking state</h3>
    <p><code>_path: Path</code> The underlying <code>pathlib.Path</code> object. Always resolved to an absolute path.</p>
    <p><code>_root: Path | None</code> Cached project root. Lazily detected on first access.</p>
    <p><code>_ap: str | None</code> Cached absolute path with normalized separators. Lazily computed.</p>
    <p><code>_rp: str | None</code> Cached relative path to project root. Lazily computed.</p>
    <p><code>_id: str | None</code> Cached base64url encoded ID. Lazily computed.</p>
    <p><code>_hash: int | None</code> Cached hash value for use in sets and dicts.</p>
    <h3><code>__init__(path: str | Path | Skpath | None = None)</code></h3>
    <p>The constructor handles four input types.</p>
    <pre><code class="language-python">def __init__(self, path: str | Path | Skpath | None = None):
    # initialize cached values
    self._path: Path
    self._root: Path | None = None
    self._ap: str | None = None
    self._rp: str | None = None
    self._id: str | None = None
    self._hash: int | None = None
    
    if path is None:
        # detect caller&#x27;s file path using frame inspection
        self._path = detect_caller_path()
    
    elif isinstance(path, Skpath):
        # copy all values from source (avoids recomputation)
        self._path = path._path
        self._root = path._root
        self._ap = path._ap
        self._rp = path._rp
        self._id = path._id
        self._hash = path._hash
    
    elif isinstance(path, Path):
        # resolve to absolute path
        self._path = path.resolve()
    
    elif isinstance(path, str):
        # try multiple interpretations
        self._path = self._resolve_string_path(path)</code></pre>
    <p>If <code>path</code> is <code>None</code>: Uses <code>detect_caller_path()</code> which inspects the call stack to find the file that called <code>Skpath()</code>. This allows <code>Skpath()</code> to return a path to &quot;this file&quot; without passing any argument.</p>
    <p>If <code>path</code> is <code>Skpath</code>: Copies all cached values directly. This is an optimization - if someone passes an existing Skpath, we don&#x27;t recompute <code>ap</code>, <code>rp</code>, <code>id</code>, etc.</p>
    <p>If <code>path</code> is <code>Path</code>: Calls <code>.resolve()</code> to get an absolute path with symlinks resolved.</p>
    <p>If <code>path</code> is <code>str</code>: Calls <code>_resolve_string_path()</code> which tries multiple interpretations (see below).</p>
    <h3>String path resolution</h3>
    <p><code>_resolve_string_path()</code> tries multiple interpretations.</p>
    <ol>
        <li>If string contains <code>/</code> or <code>\</code>:</li>
    </ol>
    <ul>
        <li>Treat as path, resolve to absolute</li>
    </ul>
    <ol start="2">
        <li>If string exists as a file/directory:</li>
    </ol>
    <ul>
        <li>Treat as relative path, resolve to absolute</li>
    </ul>
    <ol start="3">
        <li>If string looks like a base64url encoded ID:</li>
    </ol>
    <ul>
        <li>Try to decode it</li>
        <li>If decoded path is relative, resolve from project root</li>
        <li>Use the resolved path even if it doesn&#x27;t exist yet</li>
    </ul>
    <ol start="4">
        <li>Fall back to treating as path (may not exist)</li>
    </ol>
    <h3>Core properties</h3>
    <h4><code>ap</code> (absolute path)</h4>
    <p>Absolute path with normalized separators (<code>/</code>).</p>
    <pre><code class="language-python">@property
def ap(self) -&gt; str:
    if self._ap is None:
        self._ap = normalize_separators(str(self._path))
    return self._ap</code></pre>
    <p>Always available, even for paths outside project root.</p>
    <h4><code>rp</code> (relative path)</h4>
    <p>Path relative to project root with normalized separators.</p>
    <pre><code class="language-python">@property
def rp(self) -&gt; str:
    if self._rp is None:
        self._rp = self._compute_rp()
    return self._rp

def _compute_rp(self) -&gt; str:
    try:
        root = self.root_path
        rel_path = self._path.relative_to(root)
        return normalize_separators(str(rel_path))
    except (ValueError, PathDetectionError):
        return &quot;&quot;  # outside project root</code></pre>
    <p>Returns empty string if path is outside project root.</p>
    <h4><code>id</code> (encoded ID)</h4>
    <p>Reversible base64url encoded ID.</p>
    <pre><code class="language-python">@property
def id(self) -&gt; str:
    if self._id is None:
        path_to_encode = self.rp if self.rp else self.ap
        self._id = encode_path_id(path_to_encode)
    return self._id</code></pre>
    <p>Uses <code>rp</code> if available (for cross-platform compatibility), otherwise <code>ap</code>.</p>
    <p>Can be used to reconstruct the path: <code>Skpath(encoded_id)</code>.</p>
    <h4><code>root</code>, <code>root_str</code>, <code>root_path</code></h4>
    <p>Project root access in different formats.</p>
    <ul>
        <li><code>root</code> → <code>Skpath</code> object</li>
        <li><code>root_str</code> → <code>str</code> with normalized separators</li>
        <li><code>root_path</code> → <code>pathlib.Path</code> object</li>
    </ul>
    <h3>pathlib compatibility</h3>
    <p><code>Skpath</code> mirrors most <code>pathlib.Path</code> properties and methods, including file IO helpers like <code>read_text()</code>, <code>write_text()</code>, <code>read_bytes()</code>, and <code>write_bytes()</code>.</p>
    <p>Properties: <code>name</code>, <code>stem</code>, <code>suffix</code>, <code>suffixes</code>, <code>parent</code>, <code>parents</code>, <code>parts</code>, <code>exists</code>, <code>is_file</code>, <code>is_dir</code>, <code>is_symlink</code>, <code>is_empty</code>, <code>stat</code>, <code>lstat</code></p>
    <p>Methods: <code>iterdir()</code>, <code>glob()</code>, <code>rglob()</code>, <code>relative_to()</code>, <code>with_name()</code>, <code>with_stem()</code>, <code>with_suffix()</code>, <code>mkdir()</code>, <code>touch()</code>, <code>rmdir()</code>, <code>unlink()</code>, <code>resolve()</code>, <code>absolute()</code></p>
    <p>Additional methods: <code>copy_to()</code>, <code>move_to()</code> (with <code>overwrite</code> and <code>parents</code> options)</p>
    <p>Additional properties:</p>
    <ul>
        <li><code>as_dict</code>: Dictionary representation with <code>ap</code>, <code>rp</code>, <code>root</code>, <code>name</code>, <code>exists</code></li>
        <li><code>platform</code>: Absolute path with OS-native separators (backslash on Windows)</li>
    </ul>
    <h3>Path joining</h3>
    <p><code>Skpath</code> supports the <code>/</code> operator for joining paths.</p>
    <pre><code class="language-python">def __truediv__(self, other: str | Path | Skpath) -&gt; Skpath:
    return Skpath(self._path / other_str)</code></pre>
    <h3>Equality and hashing</h3>
    <p>Equality compares <code>rp</code> first (for cross-platform consistency), then falls back to <code>ap</code>.</p>
    <pre><code class="language-python">def __eq__(self, other: Any) -&gt; bool:
    if self.rp and other_skpath.rp and self.rp == other_skpath.rp:
        return True
    return self.ap == other_skpath.ap</code></pre>
    <p>Hashing uses MD5 of <code>rp</code> (or <code>ap</code> if outside project root).</p>
    <h3><code>__fspath__</code> compatibility</h3>
    <p><code>Skpath</code> implements <code>__fspath__()</code> to work with <code>open()</code>, <code>os.path</code>, etc.:</p>
    <pre><code class="language-python">def __fspath__(self) -&gt; str:
    return to_os_separators(self.ap)</code></pre>
    <p>Returns OS-native separators (<code>\</code> on Windows, <code>/</code> elsewhere).</p>
    <h2>Project Root Detection</h2>
    <p>Root detection walks up from a path looking for project indicators.</p>
    <h3>Detection priority</h3>
    <ol>
        <li>Custom root (if set via <code>set_custom_root()</code>)</li>
        <li><code>setup.sk</code> file (<code>suitkaise</code> marker - highest priority)</li>
        <li>Definitive indicators: <code>setup.py</code>, <code>setup.cfg</code>, <code>pyproject.toml</code></li>
        <li>Strong indicators: <code>.git</code>, <code>.gitignore</code></li>
        <li>License files: <code>LICENSE</code>, <code>LICENSE.txt</code>, etc. (case-insensitive)</li>
        <li>README files: <code>README.md</code>, <code>README.txt</code>, etc. (case-insensitive)</li>
        <li>Requirements files: <code>requirements.txt</code>, etc.</li>
    </ol>
    <h3>Algorithm</h3>
    <pre><code class="language-python">def _find_root_from_path(start_path: Path) -&gt; Path | None:
    # First pass: look for setup.sk specifically
    check_path = current
    while check_path != check_path.parent:
        if (check_path / &quot;setup.sk&quot;).exists():
            return check_path
        check_path = check_path.parent
    
    # Second pass: look for any indicator
    # Keep going up to find outermost root (handles nested projects)
    check_path = current
    best_root = None
    while check_path != check_path.parent:
        if _has_indicator(check_path):
            best_root = check_path
        check_path = check_path.parent
    
    return best_root</code></pre>
    <h3>Caching</h3>
    <p>Detected roots are cached to avoid repeated filesystem walks.</p>
    <pre><code class="language-python">_cached_root: Path | None = None
_cached_root_source: Path | None = None  # path used to detect cached root</code></pre>
    <p>Cache is invalidated when searching from a path outside the cached root.</p>
    <p>Use <code>clear_root_cache()</code> to manually clear the cache.</p>
    <h3>Custom root management</h3>
    <p><code>set_custom_root(path)</code>: Override automatic detection.</p>
    <p><code>get_custom_root()</code>: Get current custom root (or <code>None</code>).</p>
    <p><code>clear_custom_root()</code>: Revert to automatic detection.</p>
    <p><code>CustomRoot(path)</code>: Context manager for temporary override.</p>
    <p>All operations are thread-safe using <code>threading.RLock</code>.</p>
    <h2><code>autopath</code> Decorator</h2>
    <p>Decorator that automatically converts path parameters based on type annotations.</p>
    <p>Arguments <code>use_caller</code>: If True, parameters that accept <code>Skpath</code> or <code>Path</code> will use the caller&#x27;s file path if no value was provided.</p>
    <ul>
        <li><code>bool = False</code></li>
        <li>keyword only</li>
    </ul>
    <p><code>debug</code>: If True, print messages when conversions occur.</p>
    <ul>
        <li><code>bool = False</code></li>
        <li>keyword only</li>
    </ul>
    <p><code>only</code>: Only apply autopath to specific params.</p>
    <ul>
        <li><code>str | list[str] | None = None</code></li>
        <li>If None, all path-like params are normalized (strs, Paths, Skpaths). If a param accepts str or list[str] and is listed in only, autopath will apply. If only is not None AND a param is not listed in only, autopath will not be applied to values being passed into that param.</li>
    </ul>
    <h3>How it works</h3>
    <ol>
        <li>Inspects function signature and type hints</li>
        <li>Identifies parameters annotated with path types</li>
        <li>Wraps the function to convert inputs before calling</li>
    </ol>
    <pre><code class="language-python">@autopath()
def process(path: Skpath):
    # path is guaranteed to be Skpath
    ...

# Equivalent to:
def process(path):
    path = Skpath(path) # conversion happens here
    ...</code></pre>
    <h3>Type detection</h3>
    <p>The decorator recognizes:</p>
    <ul>
        <li>Direct types: <code>Skpath</code>, <code>Path</code>, <code>str</code></li>
        <li>Union types: <code>str | Path | Skpath</code> (AnyPath)</li>
        <li>Iterables: <code>list[Skpath]</code>, <code>tuple[Path, ...]</code>, <code>set[str]</code></li>
    </ul>
    <p>For union types, it picks the richest type.</p>
    <ul>
        <li>If <code>Skpath</code> is in the union → convert to <code>Skpath</code></li>
        <li>Else if <code>Path</code> is in the union → convert to <code>Path</code></li>
        <li>Else if <code>str</code> is in the union → convert to <code>str</code></li>
    </ul>
    <h3>Conversion</h3>
    <p>All path-like inputs flow through <code>Skpath</code> for normalization.</p>
    <pre><code class="language-python">input → Skpath → target type</code></pre>
    <p>This ensures:</p>
    <ul>
        <li>Resolved absolute paths</li>
        <li>Normalized separators (always <code>/</code>)</li>
        <li>Cross-platform consistency</li>
    </ul>
    <pre><code class="language-python">def _convert_value(value, target_type, ...):
    if target_type is Skpath:
        return Skpath(value)
    elif target_type is Path:
        return Path(Skpath(value).ap)
    elif target_type is str:
        return Skpath(value).ap</code></pre>
    <h3><code>use_caller</code> option</h3>
    <p>When <code>use_caller=True</code>, missing path parameters are filled with the caller&#x27;s file path.</p>
    <pre><code class="language-python">@autopath(use_caller=True)
def log_from(path: Skpath = None):
    print(f&quot;Logging from: {path.rp}&quot;)

# Called without argument - uses caller&#x27;s file
log_from() # logs the file that called log_from()</code></pre>
    <h3><code>only</code> option</h3>
    <p>Restrict conversion to specific parameters.</p>
    <pre><code class="language-python">@autopath(only=&quot;file_path&quot;)
def process(file_path: str, names: list[str]):
    # only file_path is normalized
    # names is left unchanged (faster for large lists)
    ...</code></pre>
    <h2>General Utility Functions</h2>
    <h3><code>get_project_root()</code></h3>
    <p>Get the project root directory.</p>
    <pre><code class="language-python">def get_project_root(expected_name: str | None = None) -&gt; Skpath:
    root_path = detect_project_root(expected_name=expected_name)
    return Skpath(root_path)</code></pre>
    <p>Arguments <code>expected_name</code>: If provided, detected root must have this name.</p>
    <ul>
        <li><code>str | None = None</code></li>
        <li>positional or keyword</li>
    </ul>
    <p>Returns <code>Skpath</code>: Project root directory.</p>
    <p>Raises <code>PathDetectionError</code>: If root cannot be detected or doesn&#x27;t match expected name.</p>
    <h3><code>get_caller_path()</code></h3>
    <p>Get the file path of the caller.</p>
    <pre><code class="language-python">def get_caller_path() -&gt; Skpath:
    caller = detect_caller_path(skip_frames=1)
    return Skpath(caller)</code></pre>
    <p>Uses <code>detect_caller_path()</code> which inspects the call stack, skipping internal frames to find the actual caller.</p>
    <p>Returns <code>Skpath</code>: Caller&#x27;s file path.</p>
    <p>Raises <code>PathDetectionError</code>: If caller detection fails.</p>
    <h3><code>get_current_dir()</code></h3>
    <p>Get the directory containing the caller&#x27;s file.</p>
    <pre><code class="language-python">def get_current_dir() -&gt; Skpath:
    caller = detect_caller_path(skip_frames=1)
    return Skpath(caller.parent)</code></pre>
    <p>Returns <code>Skpath</code>: Caller&#x27;s directory.</p>
    <h3><code>get_cwd()</code></h3>
    <p>Get the current working directory.</p>
    <pre><code class="language-python">def get_cwd() -&gt; Skpath:
    return Skpath(get_cwd_path())</code></pre>
    <p>Uses <code>Path.cwd()</code> internally.</p>
    <p>Returns <code>Skpath</code>: Current working directory.</p>
    <h3><code>get_module_path()</code></h3>
    <p>Get the file path where an object is defined.</p>
    <pre><code class="language-python">def get_module_path(obj: Any) -&gt; Skpath | None:
    path = get_module_file_path(obj)
    if path is None:
        return None
    return Skpath(path)</code></pre>
    <p>Arguments <code>obj</code>: Object to inspect (module, class, function, etc.).</p>
    <ul>
        <li><code>Any</code></li>
        <li>required</li>
    </ul>
    <p>The function handles:</p>
    <ul>
        <li>Module objects: Uses <code>__file__</code> attribute</li>
        <li>Module name strings: Imports the module, then uses <code>__file__</code></li>
        <li>Objects with <code>__module__</code>: Gets the module, then uses <code>__file__</code></li>
    </ul>
    <p>Returns <code>Skpath | None</code>: Module file path, or None if not found.</p>
    <p>Raises <code>ImportError</code>: If obj is a module name string that cannot be imported.</p>
    <h3><code>get_id()</code></h3>
    <p>Get the reversible encoded ID for a path.</p>
    <pre><code class="language-python">def get_id(path: str | Path | Skpath) -&gt; str:
    if isinstance(path, Skpath):
        return path.id
    return Skpath(path).id</code></pre>
    <p>Arguments <code>path</code>: Path to generate ID for.</p>
    <ul>
        <li><code>str | Path | Skpath</code></li>
        <li>required</li>
    </ul>
    <p>Returns <code>str</code>: Base64url encoded ID.</p>
    <h3><code>get_project_paths()</code></h3>
    <p>Get all paths in the project.</p>
    <pre><code class="language-python">def get_project_paths(
    root: str | Path | Skpath | None = None,
    exclude: str | Path | Skpath | list[...] | None = None,
    as_strings: bool = False,
    use_ignore_files: bool = True,
) -&gt; list[Skpath] | list[str]:
    return _get_project_paths(
        root=root,
        exclude=exclude,
        as_strings=as_strings,
        use_ignore_files=use_ignore_files,
    )</code></pre>
    <p>Arguments <code>root</code>: Custom root directory (defaults to detected project root).</p>
    <ul>
        <li><code>str | Path | Skpath | None = None</code></li>
        <li>keyword only</li>
    </ul>
    <p><code>exclude</code>: Paths to exclude (single path or list).</p>
    <ul>
        <li><code>str | Path | Skpath | list[...] | None = None</code></li>
        <li>keyword only</li>
    </ul>
    <p><code>as_strings</code>: Return string paths instead of Skpath objects.</p>
    <ul>
        <li><code>bool = False</code></li>
        <li>keyword only</li>
    </ul>
    <p><code>use_ignore_files</code>: Respect .gitignore, .cursorignore, etc.</p>
    <ul>
        <li><code>bool = True</code></li>
        <li>keyword only</li>
    </ul>
    <p>The function:</p>
    <ol>
        <li>Detects or uses provided root</li>
        <li>Walks the directory tree</li>
        <li>Filters out paths matching <code>.*ignore</code> patterns (if enabled)</li>
        <li>Filters out explicitly excluded paths</li>
        <li>Returns as Skpath objects or strings</li>
    </ol>
    <p>Returns <code>list[Skpath] | list[str]</code>: All project paths.</p>
    <p>Raises <code>PathDetectionError</code>: If project root cannot be detected.</p>
    <h3><code>get_project_structure()</code></h3>
    <p>Get a nested dict representing the project structure.</p>
    <pre><code class="language-python">def get_project_structure(
    root: str | Path | Skpath | None = None,
    exclude: str | Path | Skpath | list[...] | None = None,
    use_ignore_files: bool = True,
) -&gt; dict:
    return _get_project_structure(
        root=root,
        exclude=exclude,
        use_ignore_files=use_ignore_files,
    )</code></pre>
    <p>Arguments <code>root</code>: Custom root directory.</p>
    <ul>
        <li><code>str | Path | Skpath | None = None</code></li>
        <li>keyword only</li>
    </ul>
    <p><code>exclude</code>: Paths to exclude.</p>
    <ul>
        <li><code>str | Path | Skpath | list[...] | None = None</code></li>
        <li>keyword only</li>
    </ul>
    <p><code>use_ignore_files</code>: Respect .gitignore, .cursorignore, etc.</p>
    <ul>
        <li><code>bool = True</code></li>
        <li>keyword only</li>
    </ul>
    <p>Returns a nested dict where:</p>
    <ul>
        <li>Keys are directory/file names</li>
        <li>Values are empty dicts for files, nested dicts for directories</li>
    </ul>
    <pre><code class="language-python">{
    &quot;myproject&quot;: {
        &quot;src&quot;: {
            &quot;main.py&quot;: {},
            &quot;utils.py&quot;: {}
        },
        &quot;tests&quot;: {...}
    }
}</code></pre>
    <p>Returns <code>dict</code>: Nested dictionary of project structure.</p>
    <p>Raises <code>PathDetectionError</code>: If project root cannot be detected.</p>
    <h3><code>get_formatted_project_tree()</code></h3>
    <p>Get a formatted tree string for the project structure.</p>
    <pre><code class="language-python">def get_formatted_project_tree(
    root: str | Path | Skpath | None = None,
    exclude: str | Path | Skpath | list[...] | None = None,
    use_ignore_files: bool = True,
    depth: int | None = None,
    include_files: bool = True,
) -&gt; str:
    return _get_formatted_project_tree(
        root=root,
        exclude=exclude,
        use_ignore_files=use_ignore_files,
        depth=depth,
        include_files=include_files,
    )</code></pre>
    <p>Arguments <code>root</code>: Custom root directory.</p>
    <ul>
        <li><code>str | Path | Skpath | None = None</code></li>
        <li>keyword only</li>
    </ul>
    <p><code>exclude</code>: Paths to exclude.</p>
    <ul>
        <li><code>str | Path | Skpath | list[...] | None = None</code></li>
        <li>keyword only</li>
    </ul>
    <p><code>use_ignore_files</code>: Respect .gitignore, .cursorignore, etc.</p>
    <ul>
        <li><code>bool = True</code></li>
        <li>keyword only</li>
    </ul>
    <p><code>depth</code>: Maximum depth to display (None = no limit).</p>
    <ul>
        <li><code>int | None = None</code></li>
        <li>keyword only</li>
    </ul>
    <p><code>include_files</code>: Include files in the tree.</p>
    <ul>
        <li><code>bool = True</code></li>
        <li>keyword only</li>
    </ul>
    <p>Uses box-drawing characters (<code>│</code>, <code>├─</code>, <code>└─</code>) to create visual hierarchy:</p>
    <pre><code class="language-python">myproject/
├── src/
│   ├── main.py
│   └── utils/
└── tests/
    └── test_main.py</code></pre>
    <p>Returns <code>str</code>: Formatted tree string.</p>
    <p>Raises <code>PathDetectionError</code>: If project root cannot be detected.</p>
    <h2>Path ID Encoding</h2>
    <p>Path IDs use base64url encoding for safe transport.</p>
    <pre><code class="language-python">def encode_path_id(path_str: str) -&gt; str:
    # normalize path separators first
    normalized = normalize_separators(path_str)
    encoded = base64.urlsafe_b64encode(normalized.encode(&quot;utf-8&quot;))
    # remove padding for cleaner IDs
    return encoded.decode(&quot;utf-8&quot;).rstrip(&quot;=&quot;)

def decode_path_id(encoded_id: str) -&gt; str | None:
    try:
        # add back padding if needed
        padding = 4 - (len(encoded_id) % 4)
        if padding != 4:
            encoded_id += &quot;=&quot; * padding
        
        decoded = base64.urlsafe_b64decode(encoded_id.encode(&quot;utf-8&quot;))
        return decoded.decode(&quot;utf-8&quot;)
    except Exception:
        return None</code></pre>
    <p>The encoding is:</p>
    <ul>
        <li>URL-safe (uses <code>-</code> and <code>_</code> instead of <code>+</code> and <code>/</code>)</li>
        <li>Reversible (can reconstruct original path)</li>
        <li>Padding-stripped (for cleaner IDs)</li>
        <li>Path separators normalized to <code>/</code> before encoding</li>
    </ul>
    <h2>Path Validation and Sanitization</h2>
    <h3><code>is_valid_filename()</code></h3>
    <p>Arguments <code>filename</code>: Filename to validate.</p>
    <ul>
        <li><code>str</code></li>
        <li>required</li>
    </ul>
    <p>Returns <code>bool</code>: True if valid, False otherwise.</p>
    <p>Checks if a filename is valid across common operating systems.</p>
    <ol>
        <li>Not empty or whitespace-only</li>
        <li>No invalid characters: <code>&lt;&gt;:&quot;/\|?*\0</code></li>
        <li>No problematic characters: <code>\t\n\r</code></li>
        <li>Not a Windows reserved name: <code>CON</code>, <code>PRN</code>, <code>AUX</code>, <code>NUL</code>, <code>COM1-9</code>, <code>LPT1-9</code></li>
        <li>Doesn&#x27;t end with space or period</li>
    </ol>
    <h3><code>streamline_path()</code></h3>
    <p>Sanitizes a path by replacing invalid characters.</p>
    <p>Arguments <code>path</code>: Path to sanitize.</p>
    <ul>
        <li><code>str</code></li>
        <li>required</li>
    </ul>
    <p><code>max_len</code>: Maximum length to truncate to.</p>
    <ul>
        <li><code>int | None = None</code></li>
        <li>keyword only</li>
        <li>If None, no truncation is performed.</li>
    </ul>
    <p><code>replacement_char</code>: Character to replace invalid characters with.</p>
    <ul>
        <li><code>str = &quot;_&quot;</code></li>
        <li>keyword only</li>
    </ul>
    <p><code>lowercase</code>: Convert to lowercase.</p>
    <ul>
        <li><code>bool = False</code></li>
        <li>keyword only</li>
    </ul>
    <p><code>strip_whitespace</code>: Strip whitespace.</p>
    <ul>
        <li><code>bool = True</code></li>
        <li>keyword only</li>
    </ul>
    <p><code>chars_to_replace</code>: Extra characters to replace.</p>
    <ul>
        <li><code>str | list[str] | None = None</code></li>
        <li>keyword only</li>
    </ul>
    <p><code>allow_unicode</code>: Allow unicode characters.</p>
    <ul>
        <li><code>bool = True</code></li>
        <li>keyword only</li>
    </ul>
    <p>Returns <code>str</code>: Sanitized path.</p>
    <ol>
        <li>Strip whitespace (if enabled)</li>
        <li>Replace extra specified characters</li>
        <li>Replace invalid characters with replacement char</li>
        <li>Replace problematic characters</li>
        <li>Replace non-ASCII characters (if <code>allow_unicode=False</code>)</li>
        <li>Lowercase (if enabled)</li>
        <li>Truncate to max length (preserving suffix)</li>
        <li>Clean up trailing spaces/periods</li>
    </ol>
    <h3><code>streamline_path_quick()</code></h3>
    <p>Simple version of <code>streamline_path</code> with common defaults.</p>
    <pre><code class="language-python">def streamline_path_quick(
    path: str,
    max_len: int | None = None,
    replacement_char: str = &quot;_&quot;,
    lowercase: bool = False
) -&gt; str:
    return streamline_path(
        path,
        max_len=max_len,
        replacement_char=replacement_char,
        lowercase=lowercase,
        strip_whitespace=True,
        chars_to_replace=&quot; &quot;,
        allow_unicode=False,
    )</code></pre>
    <p>Arguments <code>path</code>: Path to sanitize.</p>
    <ul>
        <li><code>str</code></li>
        <li>required</li>
    </ul>
    <p><code>max_len</code>: Maximum length.</p>
    <ul>
        <li><code>int | None = None</code></li>
        <li>positional or keyword</li>
    </ul>
    <p><code>replacement_char</code>: Character to replace invalid chars with.</p>
    <ul>
        <li><code>str = &quot;_&quot;</code></li>
        <li>positional or keyword</li>
    </ul>
    <p><code>lowercase</code>: Convert to lowercase.</p>
    <ul>
        <li><code>bool = False</code></li>
        <li>positional or keyword</li>
    </ul>
    <p>Returns <code>str</code>: Sanitized path.</p>
    <p>This version:</p>
    <ul>
        <li>Always strips whitespace</li>
        <li>Replaces spaces with replacement char</li>
        <li>Disallows unicode (ASCII only)</li>
    </ul>
    <h2>Exceptions</h2>
    <h3><code>PathDetectionError</code></h3>
    <p>Raised when path or project root detection fails.</p>
    <p>Examples:</p>
    <ul>
        <li>Project root cannot be detected (no indicators found)</li>
        <li>Custom root path doesn&#x27;t exist or isn&#x27;t a directory</li>
        <li>Expected root name doesn&#x27;t match detected root</li>
    </ul>
    <h3><code>NotAFileError</code></h3>
    <p>Raised when a file operation is attempted on a directory.</p>
    <p>Example: Calling <code>Skpath.unlink()</code> on a directory.</p>
    <h2>Types</h2>
    <h3><code>AnyPath</code></h3>
    <p>Type alias for path parameters that accept multiple types.</p>
    <pre><code class="language-python">from typing import Union

# using Union for forward reference compatibility at runtime
AnyPath = Union[str, Path, &quot;Skpath&quot;]</code></pre>
    <p>Note: Does NOT include <code>None</code> - use <code>AnyPath | None</code> when <code>None</code> is acceptable.</p>
    <p>Use in function annotations to indicate a parameter accepts any path type:</p>
    <pre><code class="language-python">def process(path: AnyPath) -&gt; None:
    ...</code></pre>
    <p>When used with <code>@autopath()</code>, parameters annotated with <code>AnyPath</code> are converted to <code>Skpath</code> (the richest type in the union).</p>
    <h2>Thread Safety</h2>
    <p>Module-level state is protected by <code>threading.RLock</code> instances.</p>
    <ul>
        <li><code>_root_lock</code>: Protects custom root state (<code>_custom_root</code>)</li>
        <li><code>_cache_lock</code>: Protects cached root state (<code>_cached_root</code>, <code>_cached_root_source</code>)</li>
        <li><code>_skpath_lock</code>: Defined for potential Skpath operations (currently unused)</li>
        <li><code>_autopath_lock</code>: Defined for potential autopath operations (currently unused)</li>
        <li><code>_id_lock</code>: Defined in id_utils for potential ID operations (currently unused)</li>
    </ul>
    <p>RLock (reentrant lock) is used because operations may call each other (e.g., <code>detect_project_root()</code> is called from both <code>Skpath()</code> and custom root validation).</p>
    <p>The root detection functions (<code>set_custom_root</code>, <code>get_custom_root</code>, <code>clear_custom_root</code>, <code>detect_project_root</code>) actively use locks to protect shared state.</p>
</section>
