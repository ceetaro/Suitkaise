<div class="module-bar" data-module="sktime">
    <span class="module-bar-title">suitkaise.sktime</span>
    <nav class="module-bar-nav">
        <a href="#sktime" class="module-bar-link" data-page="sktime">how to use</a>
        <a href="#sktime-how-it-works" class="module-bar-link active" data-page="sktime-how-it-works">how it works</a>
        <a href="#sktime-videos" class="module-bar-link" data-page="sktime-videos">videos</a>
        <a href="#sktime-tests" class="module-bar-link" data-page="sktime-tests">tests</a>
        <a href="#sktime-examples" class="module-bar-link" data-page="sktime-examples">examples</a>
        <a href="#sktime-why" class="module-bar-link" data-page="sktime-why">why</a>
    </nav>
</div>
<section class="module-page">
    <h1>How <code>sktime</code> actually works</h1>
    
    <p><code>sktime</code> has no dependencies outside of the standard library.</p>
    <ul>
        <li>Uses Unix timestamp (seconds since January 1, 1970)</li>
        <li>Only calculates times using floats, no datetime objects are used</li>
    </ul>

    <h3><code>now()</code> and <code>get_current_time()</code></h3>
    <p><code>now()</code> and <code>get_current_time()</code> are the same function, just with different names.</p>
    <p>These call Python's <code>time.time()</code> function, and return the current time as a float.</p>
    <ul>
        <li>Use real world time, not performance counter time</li>
    </ul>

    <hr>

    <h3><code>sleep()</code></h3>
    <p><code>sleep()</code> is an enhanced version of Python's <code>time.sleep()</code> function.</p>
    <p>It pauses the current thread for a given number of seconds, just like <code>time.sleep()</code>, and then returns the current time.</p>
    <p><strong>Arguments:</strong></p>
    <ul>
        <li><code>seconds</code>: Number of seconds to sleep (can be fractional)</li>
    </ul>
    <p><strong>Returns:</strong></p>
    <ul>
        <li>Current time after sleeping</li>
    </ul>
<pre><code class="language-python">from suitkaise import sktime

# 2 ways to use sleep()

start_time = sktime.now()
end_time = sktime.sleep(2) # sleeps and returns the current time

# or ...

start_time = sktime.now()
sktime.sleep(2) # just sleeps, doesn't return
end_time = sktime.now()</code></pre>
    <ol>
        <li>Calls Python's <code>time.sleep()</code> function with the given number of seconds</li>
        <li>After sleeping, calls <code>now()</code> to get the current time</li>
        <li>Returns the current time after sleeping as a float</li>
    </ol>

    <hr>

    <h3><code>elapsed()</code></h3>
    <p>Calculates how much time has passed between two times. Order doesn't matter - always returns a positive float time.</p>
    <p><strong>Arguments:</strong></p>
    <ul>
        <li><code>time1</code>: First time</li>
        <li><code>time2</code>: Second time (defaults to current time if <code>None</code>)</li>
    </ul>
    <p><strong>Returns:</strong></p>
    <ul>
        <li>Positive elapsed time (in seconds) as a float</li>
    </ul>
<pre><code class="language-python">from suitkaise import sktime

# 2 ways to use elapsed()

start_time = sktime.now()
end_time = sktime.sleep(2)

elapsed = sktime.elapsed(start_time, end_time)

# or ...

start_time = sktime.now()
sktime.sleep(2)
elapsed = sktime.elapsed(start_time)</code></pre>
    <ol>
        <li>If <code>time2</code> is <code>None</code>, <code>elapsed()</code> uses the current time as the end time (calls <code>time.time()</code>)</li>
        <li>Calculates absolute difference using <code>math.fabs(time2 - time1)</code>
            <ul><li><code>math.fabs()</code> is used instead of <code>abs()</code> for best precision with float numbers</li></ul>
        </li>
        <li>Returns the positive difference in seconds as a float</li>
    </ol>
    <p><code>fabs()</code> is a built-in function in the <code>math</code> module that returns the absolute value of a number, and is more precise than <code>abs()</code> for floating point numbers.</p>

    <hr>

    <h2><code>Yawn</code> Class</h2>
    <p>The <code>Yawn</code> class is a sleep controller that only sleeps after being called a certain number of times.</p>
    <p><strong>Initialize with:</strong></p>
    <ul>
        <li><code>sleep_duration</code>: how long to sleep when threshold is reached (float)</li>
        <li><code>yawn_threshold</code>: number of yawns needed before sleeping (int)</li>
        <li><code>log_sleep</code>: whether to print messages when sleeping (bool, default <code>False</code>)</li>
    </ul>
    <p>For readability, I recommend using keyword arguments when initializing the <code>Yawn</code> class.</p>
<pre><code class="language-python">from suitkaise import sktime

y = sktime.Yawn(sleep_duration=2, yawn_threshold=3, log_sleep=True)</code></pre>
    <ol>
        <li>Creates a <code>Yawn</code> instance</li>
        <li>Stores the following attributes:
            <ul>
                <li><code>sleep_duration</code>: how long to sleep when threshold is reached (float)</li>
                <li><code>yawn_threshold</code>: number of yawns needed before sleeping (int)</li>
                <li><code>log_sleep</code>: whether to print messages when sleeping</li>
                <li><code>yawn_count</code>: counter starting at 0</li>
                <li><code>total_sleeps</code>: tracks how many times we've slept (starts at 0)</li>
                <li><code>_lock</code>: creates a <code>threading.RLock()</code> for thread safety</li>
            </ul>
        </li>
    </ol>
    <p>The lock ensures multiple threads can safely use the same <code>Yawn</code> instance without race conditions.</p>

    <h3><code>Yawn.yawn()</code></h3>
    <p>Registers a yawn and possibly sleeps if the threshold is reached.</p>
    <p><strong>Arguments:</strong> None</p>
    <p><strong>Returns:</strong> <code>True</code> if sleep occurred, <code>False</code> otherwise</p>
    <ol>
        <li>Acquires the thread lock</li>
        <li>Increments <code>yawn_count</code> by 1</li>
        <li>Checks if <code>yawn_count >= yawn_threshold</code>:
            <ul>
                <li><strong>If True:</strong>
                    <ul>
                        <li>If <code>log_sleep</code> is True, prints a message about sleeping</li>
                        <li>Calls <code>time.sleep(sleep_duration)</code> to actually sleep</li>
                        <li>Resets <code>yawn_count</code> to 0</li>
                        <li>Increments <code>total_sleeps</code> by 1</li>
                        <li>Returns <code>True</code></li>
                    </ul>
                </li>
                <li><strong>If False:</strong> Returns <code>False</code></li>
            </ul>
        </li>
        <li>Releases the thread lock</li>
    </ol>
    <p>The automatic counter reset means you don't have to manually reset it after sleeping.</p>

    <h3><code>Yawn.reset()</code></h3>
    <p>Resets the yawn counter without sleeping.</p>
    <p><strong>Arguments:</strong> None</p>
    <p><strong>Returns:</strong> None</p>
    <ol>
        <li>Acquires the thread lock</li>
        <li>Resets <code>yawn_count</code> to 0</li>
        <li>Releases the thread lock</li>
    </ol>
    <p>This is useful if you want to restart the counting without waiting for a sleep to happen.</p>

    <h3><code>Yawn.get_stats()</code></h3>
    <p>Returns a dictionary with current yawn statistics.</p>
    <p><strong>Arguments:</strong> None</p>
    <p><strong>Returns:</strong> Dictionary with:</p>
    <ul>
        <li><code>current_yawns</code>: current yawn counter value</li>
        <li><code>yawn_threshold</code>: the threshold setting</li>
        <li><code>total_sleeps</code>: how many times we've slept so far</li>
        <li><code>sleep_duration</code>: how long each sleep lasts</li>
        <li><code>yawns_until_sleep</code>: calculated as <code>yawn_threshold - yawn_count</code></li>
    </ul>
    <ol>
        <li>Acquires the thread lock</li>
        <li>Creates a dictionary with the current values</li>
        <li>Releases the thread lock</li>
        <li>Returns the dictionary</li>
    </ol>
    <p>All reads happen under the lock to ensure you get a consistent snapshot of the stats.</p>

    <hr>

    <h2><code>Timer</code> Class</h2>
    <p>The <code>Timer</code> is an advanced timer that can be used to time code execution, complete with statistics and pause/resume functionality.</p>
    <p>It is also the base for the context manager <code>TimeThis</code>, the timing decorator <code>@timethis</code>, and the <code>processing</code> module's <code>@timesection</code> decorator.</p>
    <p>No arguments are needed to initialize the <code>Timer</code> class.</p>
<pre><code class="language-python">from suitkaise import sktime

t = sktime.Timer()</code></pre>
    <ol>
        <li>Creates a <code>Timer</code> instance</li>
        <li>Stores the following attributes:
            <ul>
                <li><code>original_start_time</code>: set to <code>None</code> (will be set on first <code>start()</code>)</li>
                <li><code>times</code>: empty list to store all recorded measurements</li>
                <li><code>_paused_durations</code>: empty list to track pause time for each measurement</li>
                <li><code>_lock</code>: creates a <code>threading.RLock()</code> for thread safety</li>
                <li><code>_sessions</code>: empty dictionary to track timing sessions per thread (keyed by thread ID)</li>
            </ul>
        </li>
    </ol>
    <p>Each timing operation is tracked separately. If you start timing from multiple places at once (like in parallel code), they won't interfere with each other — each gets its own independent tracking.</p>

    <h3><code>Timer.start()</code></h3>
    <p>Starts timing a new measurement.</p>
    <p><strong>Arguments:</strong> None</p>
    <p><strong>Returns:</strong> Time (in seconds) when the measurement started, as a float</p>
    <ol>
        <li>Gets or creates a <code>TimerSession</code> for the current thread by calling <code>_get_or_create_session()</code>
            <ul>
                <li>Uses <code>threading.get_ident()</code> to get current thread ID</li>
                <li>Looks up session in <code>_sessions</code> dictionary</li>
                <li>If not found, creates new <code>TimerSession</code> and stores it</li>
            </ul>
        </li>
        <li>Calls <code>session.start()</code> which:
            <ul>
                <li>Acquires session lock</li>
                <li>Creates a new "frame" (measurement context) with:
                    <ul>
                        <li><code>start_time</code>: current time from <code>perf_counter()</code></li>
                        <li><code>paused</code>: <code>False</code></li>
                        <li><code>pause_started_at</code>: <code>None</code></li>
                        <li><code>total_paused</code>: <code>0.0</code></li>
                    </ul>
                </li>
                <li>Pushes frame onto the session's stack (supports nested timings)</li>
                <li>Releases session lock</li>
            </ul>
        </li>
        <li>If this is the first start ever, sets <code>original_start_time</code> to the start timestamp</li>
        <li>Returns the start timestamp</li>
    </ol>

    <details>
        <summary>What is <code>perf_counter()</code> and why is it used?</summary>
        <div class="dropdown-content">
            <p>Python has two main ways to get the current time:</p>
            <ul>
                <li><code>time.time()</code> — gives you the real-world clock time (like "3:45 PM"). But if your computer's clock gets adjusted (daylight saving, syncing with the internet, etc.), this number can jump forward or backward unexpectedly.</li>
                <li><code>time.perf_counter()</code> — gives you a "stopwatch" time that only counts upward. It doesn't know what time of day it is, but it's extremely precise and never gets adjusted.</li>
            </ul>
            <p>For measuring how long code takes to run, <code>perf_counter()</code> is the better choice because you want consistent, accurate measurements — not times that might suddenly shift because your computer synced its clock.</p>
        </div>
    </details>

    <details>
        <summary>What is a frame and a stack?</summary>
        <div class="dropdown-content">
            <p>Think of a stack like a stack of plates. You can only add plates to the top, and you can only remove plates from the top.</p>
            <p>A <strong>frame</strong> is one "plate" — it represents a single timing measurement that's currently in progress.</p>
            <p>A <strong>stack</strong> of frames lets you nest timings inside each other:</p>
<pre><code class="language-python">timer.start()          # Frame 1 added to stack
  # do some work
  timer.start()        # Frame 2 added on top
    # do inner work
  timer.stop()         # Frame 2 removed, returns inner time
  # do more work
timer.stop()           # Frame 1 removed, returns total time</code></pre>
            <p>Each <code>start()</code> pushes a new frame onto the stack. Each <code>stop()</code> pops the top frame off and calculates how long that specific measurement took. This lets you measure the total time of something while also measuring individual pieces inside it.</p>
        </div>
    </details>

    <h3><code>Timer.stop()</code></h3>
    <p>Stops timing the current measurement and returns the elapsed time.</p>
    <p><strong>Arguments:</strong> None</p>
    <p><strong>Returns:</strong> Elapsed time (in seconds) as a float</p>
    <ol>
        <li>Gets the current thread's session</li>
        <li>Calls <code>session.stop()</code> which:
            <ul>
                <li>Acquires session lock</li>
                <li>Gets the top frame from the stack</li>
                <li>Calculates elapsed time:
                    <ul>
                        <li>Gets current time from <code>perf_counter()</code></li>
                        <li>If currently paused, adds the current pause duration</li>
                        <li>Formula: <code>(end_time - start_time) - (total_paused + current_pause_duration)</code></li>
                    </ul>
                </li>
                <li>Calculates total pause duration</li>
                <li>Pops the frame from the stack</li>
                <li>Returns tuple of <code>(elapsed_time, total_paused)</code></li>
                <li>Releases session lock</li>
            </ul>
        </li>
        <li>Acquires the <code>Timer</code> manager lock</li>
        <li>Appends elapsed time to <code>times</code> list</li>
        <li>Appends pause duration to <code>_paused_durations</code> list</li>
        <li>Releases the lock</li>
        <li>Returns just the elapsed time (unwraps the tuple)</li>
    </ol>
    <p>The elapsed time excludes any paused periods, giving you only the total time the timer was running.</p>

    <h3><code>Timer.lap()</code></h3>
    <p>Records a lap time without stopping the timer.</p>
    <p><strong>Arguments:</strong> None</p>
    <p><strong>Returns:</strong> Elapsed time (in seconds) as a float</p>
    <ol>
        <li>Gets the current thread's session</li>
        <li>Calls <code>session.lap()</code> which:
            <ul>
                <li>Acquires session lock</li>
                <li>Gets the top frame from the stack</li>
                <li>Calculates elapsed time just like <code>session.stop()</code></li>
                <li>Calculates total pause duration</li>
                <li><strong>Restarts the frame</strong> by:
                    <ul>
                        <li>Setting <code>start_time</code> to current time</li>
                        <li>Resetting <code>total_paused</code> to <code>0.0</code></li>
                        <li>Setting <code>paused</code> to <code>False</code></li>
                        <li>Setting <code>pause_started_at</code> to <code>None</code></li>
                    </ul>
                </li>
                <li>Returns tuple of <code>(elapsed_time, total_paused)</code></li>
                <li>Releases session lock</li>
            </ul>
        </li>
        <li>Acquires the <code>Timer</code> manager lock</li>
        <li>Appends elapsed time to <code>times</code> list</li>
        <li>Appends pause duration to <code>_paused_durations</code> list</li>
        <li>Releases the lock</li>
        <li>Returns just the elapsed time</li>
    </ol>
    <p>The key difference from <code>stop()</code> is the frame stays on the stack and restarts, so timing continues. It's as if you called <code>Timer.start()</code> the instant after the previous <code>Timer.stop()</code> call.</p>

    <h3><code>Timer.pause()</code></h3>
    <p>Pauses the current timing measurement.</p>
    <p><strong>Arguments:</strong> None</p>
    <p><strong>Returns:</strong> None</p>
    <ol>
        <li>Gets the current thread's session</li>
        <li>Calls <code>session.pause()</code> which:
            <ul>
                <li>Acquires session lock</li>
                <li>Gets the top frame from the stack</li>
                <li>Checks if already paused:
                    <ul>
                        <li>If yes, issues a warning and returns</li>
                        <li>If no, sets <code>paused</code> to <code>True</code> and <code>pause_started_at</code> to current time</li>
                    </ul>
                </li>
                <li>Releases session lock</li>
            </ul>
        </li>
    </ol>
    <p>The pause time is tracked but not included in the final elapsed time calculation.</p>

    <h3><code>Timer.resume()</code></h3>
    <p>Resumes a paused timing measurement.</p>
    <p><strong>Arguments:</strong> None</p>
    <p><strong>Returns:</strong> None</p>
    <ol>
        <li>Gets the current thread's session</li>
        <li>Calls <code>session.resume()</code> which:
            <ul>
                <li>Acquires session lock</li>
                <li>Gets the top frame from the stack</li>
                <li>Checks if not paused:
                    <ul>
                        <li>If not paused, issues a warning and returns</li>
                    </ul>
                </li>
                <li>Calculates pause duration: <code>current_time - pause_started_at</code></li>
                <li>Adds pause duration to <code>total_paused</code></li>
                <li>Sets <code>paused</code> to <code>False</code></li>
                <li>Sets <code>pause_started_at</code> to <code>None</code></li>
                <li>Releases session lock</li>
            </ul>
        </li>
    </ol>
    <p>Each pause/resume cycle accumulates in <code>total_paused</code>, which is subtracted from the final elapsed time.</p>

    <h3><code>Timer.add_time()</code></h3>
    <p>Manually adds a pre-measured time to the statistics (a float).</p>
    <p><strong>Arguments:</strong></p>
    <ul>
        <li><code>elapsed_time</code>: time to add to statistics (in seconds) as a float</li>
    </ul>
    <p><strong>Returns:</strong> None</p>
    <ol>
        <li>Acquires the <code>Timer</code> manager lock</li>
        <li>Appends <code>elapsed_time</code> to <code>times</code> list</li>
        <li>Appends <code>0.0</code> to <code>_paused_durations</code> list</li>
        <li>Releases the lock</li>
        <li>Returns None</li>
    </ol>

    <h3><code>Timer</code> property method statistics</h3>
    <p>All properties work similarly by acquiring the lock and calculating from the <code>times</code> list:</p>

    <details>
        <summary>Timer Statistics Properties</summary>
        <div class="dropdown-content">
            <p><strong><code>num_times</code></strong>: Returns <code>len(self.times)</code></p>
            <p><strong><code>original_start_time</code></strong>: Returns the stored timestamp from the first <code>start()</code> call</p>
            <p><strong><code>most_recent</code></strong>: Returns <code>times[-1]</code> (last element) or <code>None</code> if empty</p>
            <p><strong><code>most_recent_index</code></strong>: Returns <code>len(times) - 1</code> or <code>None</code> if empty</p>
            <p><strong><code>result</code></strong>: Alias for <code>most_recent</code></p>
            <p><strong><code>total_time</code></strong>: Returns <code>sum(times)</code> or <code>None</code> if empty</p>
            <p><strong><code>total_time_paused</code></strong>: Returns <code>sum(_paused_durations)</code> or <code>None</code> if empty</p>
            <p><strong><code>mean</code></strong>: Uses <code>statistics.mean(times)</code> or <code>None</code> if empty</p>
            <p><strong><code>median</code></strong>: Uses <code>statistics.median(times)</code> or <code>None</code> if empty</p>
            <p><strong><code>min</code> / <code>fastest_time</code></strong>: Returns <code>min(times)</code> or <code>None</code> if empty</p>
            <p><strong><code>max</code> / <code>slowest_time</code></strong>: Returns <code>max(times)</code> or <code>None</code> if empty</p>
            <p><strong><code>fastest_time_index</code></strong>: Returns the index of the fastest time</p>
            <p><strong><code>slowest_time_index</code></strong>: Returns the index of the slowest time</p>
            <p><strong><code>stdev</code></strong>: Uses <code>statistics.stdev(times)</code>, requires at least 2 measurements, returns <code>None</code> otherwise</p>
            <p><strong><code>variance</code></strong>: Uses <code>statistics.variance(times)</code>, requires at least 2 measurements, returns <code>None</code> otherwise</p>
        </div>
    </details>
    <p>All property accesses acquire the lock to ensure thread-safe reads.</p>

    <h3>Other methods</h3>

    <h4><code>Timer.get_time()</code></h4>
    <p>Gets and returns a specific timing measurement by index.</p>
    <p><strong>Arguments:</strong></p>
    <ul>
        <li><code>index</code>: 0-based index of measurement</li>
    </ul>
    <p><strong>Returns:</strong> timing measurement (in seconds) as a float or <code>None</code> if index is out of range</p>
    <ol>
        <li>Acquires the <code>Timer</code> manager lock</li>
        <li>Checks if <code>0 <= index < len(times)</code></li>
        <li>If valid, returns <code>times[index]</code></li>
        <li>If invalid, returns <code>None</code></li>
        <li>Releases the lock</li>
    </ol>

    <h4><code>Timer.percentile()</code></h4>
    <p>Calculates a percentile of all measurements.</p>
    <p><strong>Arguments:</strong></p>
    <ul>
        <li><code>percent</code>: percentile to calculate (between 0 and 100)</li>
    </ul>
    <p><strong>Returns:</strong> percentile value (in seconds) as a float or <code>None</code> if no measurements</p>
    <ol>
        <li>Acquires the <code>Timer</code> manager lock</li>
        <li>Checks if <code>times</code> is empty - returns <code>None</code> if so</li>
        <li>Validates <code>percent</code> is between 0 and 100 - raises <code>ValueError</code> if not</li>
        <li>Sorts the times list</li>
        <li>Calculates index: <code>(percent / 100) * (len(sorted_times) - 1)</code></li>
        <li>If index is a whole number: Returns the value at that exact index</li>
        <li>If index is fractional:
            <ul>
                <li>Gets values at floor and ceiling indices</li>
                <li>Performs linear interpolation: <code>value = lower * (1 - weight) + upper * weight</code></li>
                <li>Where <code>weight</code> is the fractional part of the index</li>
            </ul>
        </li>
        <li>Releases the lock</li>
        <li>Returns the percentile value</li>
    </ol>
    <p>Linear interpolation provides smooth percentile values between data points.</p>

    <h4><code>Timer.get_statistics()</code></h4>
    <p>Creates a snapshot of all statistics.</p>
    <p><strong>Arguments:</strong> None</p>
    <p><strong>Returns:</strong> a <code>TimerStats</code> object or <code>None</code> if no measurements have been recorded</p>
    <ol>
        <li>Acquires the <code>Timer</code> manager lock</li>
        <li>Returns <code>None</code> if no measurements have been recorded</li>
        <li>Creates a new <code>TimerStats</code> object with:
            <ul>
                <li>Copy of the <code>times</code> list</li>
                <li>The <code>original_start_time</code></li>
                <li>Copy of the <code>_paused_durations</code> list</li>
            </ul>
        </li>
        <li>Releases the lock</li>
        <li>Returns the <code>TimerStats</code> object</li>
    </ol>
    <p>The <code>TimerStats</code> object calculates and stores all statistics at creation time.</p>
    <p>Once created, the <code>TimerStats</code> object is a frozen snapshot. You can access all the same properties and methods (like <code>percentile()</code>) without acquiring locks, making it fast for repeated access.</p>

    <h3><code>Timer.reset()</code></h3>
    <p>Clears all timing data.</p>
    <p><strong>Arguments:</strong> None</p>
    <p><strong>Returns:</strong> None</p>
    <ol>
        <li>Acquires the <code>Timer</code> manager lock</li>
        <li>Clears the <code>times</code> list</li>
        <li>Sets <code>original_start_time</code> to <code>None</code></li>
        <li>Clears the <code>_sessions</code> dictionary (removes all thread sessions)</li>
        <li>Clears the <code>_paused_durations</code> list</li>
        <li>Releases the lock</li>
    </ol>
    <p>This completely resets the timer as if it was just created.</p>

    <hr>

    <h2><code>TimeThis</code> context manager</h2>
    <p>A context manager that automatically starts and stops a timer when entering and exiting a code block.</p>
    <p><strong>Initialize with:</strong></p>
    <ul>
        <li><code>timer</code>: an optional <code>Timer</code> instance to use</li>
    </ul>
    <p>If <code>timer</code> is provided, the context manager will use the provided <code>Timer</code> instance.</p>
    <p>Otherwise, it will create a new <code>Timer</code> instance, which will only be used for this single timing operation.</p>
    <p>You can access this instance like so:</p>
<pre><code class="language-python">from suitkaise import sktime

with sktime.TimeThis() as t:
    # code to time

result = t.timer.get_statistics() # or anything else</code></pre>

    <h3>methods</h3>

    <h4><code>TimeThis.__enter__()</code></h4>
    <p>Entry point for the context manager. Starts timing the code block.</p>
    <ol>
        <li>Calls <code>self.timer.start()</code></li>
        <li>Returns the <code>Timer</code> instance (<code>self.timer</code>)</li>
    </ol>

    <h4><code>TimeThis.__exit__(exc_type, exc_val, exc_tb)</code></h4>
    <p>Exits the context manager. Stops timing the code block.</p>
    <ol>
        <li>Calls <code>self.timer.stop()</code></li>
        <li>Returns <code>None</code> (doesn't suppress exceptions)</li>
    </ol>
    <p>If an exception occurs in the code block, it will be raised after the context manager exits.</p>
    <p>Even if an exception occurs in the code block, the timer is stopped and the measurement is recorded.</p>

    <h4>pausing, resuming, and lapping</h4>
    <p>Pausing, resuming, and lapping are all available as methods on the <code>TimeThis</code> context manager.</p>
    <ul>
        <li><code>pause()</code>: Pauses the timer</li>
        <li><code>resume()</code>: Resumes the timer</li>
        <li><code>lap()</code>: Records a lap time</li>
    </ul>
    <p>These work exactly the same as the ones in the <code>Timer</code> class.</p>

    <hr>

    <h2><code>timethis</code> decorator</h2>
    <p>Decorator that dedicates a <code>Timer</code> instance to the function it decorates, timing the function's execution every time it is called.</p>
    <p><strong>Arguments:</strong></p>
    <ul>
        <li><code>timer_instance</code>: an optional <code>Timer</code> instance to use</li>
    </ul>
    <p>If <code>timer_instance</code> is provided, the decorator will use the provided <code>Timer</code> instance.</p>
    <p>Otherwise, it will create a new <code>Timer</code> instance, dedicated to the function it decorates.</p>

    <h3>Mode 1: Explicit timer (<code>timer_instance</code> provided)</h3>
    <p>When you pass a <code>Timer</code> to the decorator, it uses that timer directly.</p>
    <ol>
        <li>At decoration time:
            <ul>
                <li>Receives your provided <code>Timer</code> instance</li>
                <li>Creates a wrapper function around your original function</li>
            </ul>
        </li>
        <li>At call time (every time the decorated function runs):
            <ul>
                <li>Calls <code>timer_instance.start()</code> before the function runs</li>
                <li>Runs your original function</li>
                <li>Calls <code>timer_instance.stop()</code> after the function completes (even if it throws an error)</li>
                <li>Returns the function's result</li>
            </ul>
        </li>
    </ol>
    <p>This is useful when you want multiple functions to share the same timer for combined statistics.</p>

    <h3>Mode 2: Auto-created global function timer</h3>
    <p>When <code>timer_instance</code> is <code>None</code> (the default), the decorator creates and manages a timer for you.</p>
    <ol>
        <li>At decoration time:
            <ul>
                <li>Uses Python's <code>inspect</code> module to figure out where the function is defined</li>
                <li>Extracts the module name from <code>frame.f_back.f_globals.get('__name__')</code></li>
                <li>If the module name has dots (like <code>mypackage.submodule</code>), takes only the last part (<code>submodule</code>)</li>
            </ul>
        </li>
        <li>Builds a unique timer name based on the function's location:
            <ul>
                <li>Checks <code>func.__qualname__</code> to see if the function is inside a class</li>
                <li>If inside a class (qualname contains a dot like <code>MyClass.my_method</code>): Timer name becomes <code>{module}_{ClassName}_{method}_timer</code></li>
                <li>If at module level (no dot in qualname): Timer name becomes <code>{module}_{function}_timer</code></li>
            </ul>
        </li>
        <li>Creates or retrieves the global timer:
            <ul>
                <li>The <code>timethis</code> function itself stores a dictionary <code>_global_timers</code> and a lock <code>_timers_lock</code></li>
                <li>Acquires the lock (thread-safe)</li>
                <li>If a timer with this name doesn't exist yet, creates a new <code>Timer()</code></li>
                <li>Retrieves the timer from the dictionary</li>
                <li>Releases the lock</li>
            </ul>
        </li>
        <li>Creates the wrapper function (same as Mode 1)</li>
        <li>Attaches the timer to the wrapper function:
            <ul>
                <li>Sets <code>wrapper.timer = the_timer</code></li>
                <li>This lets you access statistics via <code>your_function.timer.mean</code>, etc.</li>
            </ul>
        </li>
        <li>At call time (every time the decorated function runs):
            <ul>
                <li>Same as Mode 1: <code>start()</code>, run function, <code>stop()</code></li>
            </ul>
        </li>
    </ol>

    <h3>Why this design?</h3>
    <p>The auto-created timer is stored globally (attached to the <code>timethis</code> function itself), not recreated each time. This means:</p>
    <ul>
        <li>The timer persists across all calls to the decorated function</li>
        <li>Statistics accumulate over the lifetime of your program</li>
        <li>You can access the timer anytime via <code>your_function.timer</code></li>
        <li>Thread-safe: multiple threads can call the decorated function, and each gets its own timing session</li>
    </ul>

    <h3><code>clear_global_timers()</code></h3>
    <p>Clears all auto-created global timers.</p>
    <ol>
        <li>Checks if <code>_global_timers</code> and <code>_timers_lock</code> exist on the <code>timethis</code> function</li>
        <li>If they do:
            <ul>
                <li>Acquires the lock</li>
                <li>Calls <code>.clear()</code> on the <code>_global_timers</code> dictionary</li>
                <li>Releases the lock</li>
            </ul>
        </li>
    </ol>
    <p>This is useful for long-running programs or test environments where you want to start fresh.</p>

    <hr>

    <h3>Thread Safety</h3>
    <p>All timing classes use <code>threading.RLock()</code> (reentrant locks) for thread safety.</p>

    <details>
        <summary>What is a reentrant lock?</summary>
        <div class="dropdown-content">
            <p>A reentrant lock is a lock that can be acquired by the same thread multiple times without deadlocking.</p>
            <p>This is useful for thread safety, as it allows the same thread to acquire the lock multiple times from different code or methods.</p>
        </div>
    </details>

    <h3>Memory Management</h3>
    <p>The <code>Timer</code> stores all measurements in memory:</p>
    <ul>
        <li>Each measurement is a single float (8 bytes)</li>
        <li>Each pause duration is a single float (8 bytes)</li>
        <li>1 million measurements ≈ 16 MB of memory</li>
    </ul>
    <p>Use <code>reset()</code> periodically if running indefinitely.</p>

    <h3>Error Handling</h3>
    <ul>
        <li>Timer operations raise <code>RuntimeError</code> if called in wrong state (e.g., <code>stop()</code> without <code>start()</code>)</li>
        <li>Pause/resume issues a <code>UserWarning</code> if called in wrong state (e.g., <code>pause()</code> when already paused)</li>
        <li>Percentile calculations raise <code>ValueError</code> if percent is not in range 0-100</li>
        <li>The <code>@timethis</code> decorator always records timing, even if the function raises an exception</li>
    </ul>
</section>
