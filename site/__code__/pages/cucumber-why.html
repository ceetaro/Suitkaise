<div class="module-bar" data-module="cucumber">
    <button class="module-bar-title">suitkaise.cucumber</button>
    <nav class="module-bar-nav">
        <a href="#cucumber-why" class="module-bar-link active" data-page="cucumber-why">why</a>
        <a href="#cucumber-quick-start" class="module-bar-link" data-page="cucumber-quick-start">quick start</a>
        <a href="#cucumber" class="module-bar-link" data-page="cucumber">how to use</a>
        <a href="#cucumber-how-it-works" class="module-bar-link" data-page="cucumber-how-it-works">how it works</a>
        <a href="#cucumber-supported-types" class="module-bar-link" data-page="cucumber-supported-types">supported types</a>
        <a href="#cucumber-performance" class="module-bar-link" data-page="cucumber-performance">performance</a>
        <a href="#cucumber-worst-possible-object" class="module-bar-link" data-page="cucumber-worst-possible-object">worst possible object</a>
        <a href="#cucumber-videos" class="module-bar-link" data-page="cucumber-videos">videos</a>
        <a href="#cucumber-learn" class="module-bar-link" data-page="cucumber-learn">learn</a>
    </nav>
</div>
<section class="module-page why-page">
    <h1>Why you would use <code><suitkaise-api>cucumber</suitkaise-api></code></h1>
    <h2>TLDR</h2>
    <ul>
        <li><strong>Serialize anything</strong> - No more <code>PicklingError</code> ever again</li>
        <li><strong>Handles types others can&#x27;t</strong> - threads, queues, sockets, generators, asyncio, sqlite, regex matches, and more</li>
        <li><strong>Live resource reconnection</strong> - Database connections, sockets, threads reconnect safely with your manual permission</li>
        <li><strong>Classes in <code>__main__</code></strong> - Multiprocessing just works, even in one-file scripts or tests</li>
        <li><strong>Circular references</strong> - All handled automatically</li>
        <li><strong>Debug-friendly</strong> - <code>debug=True</code> and <code>verbose=True</code> show exactly what&#x27;s happening</li>
        <li><strong>Surprising speed</strong> - Competes with <code>cloudpickle</code> on basic types while covering vastly more types. Multiple times faster than <code>dill</code></li>
    </ul>
    <hr>
    <p><code><suitkaise-api>cucumber</suitkaise-api></code> is a serialization engine.</p>
    <p>It allows you to serialize and deserialize objects across <code>Python</code> processes.</p>
    <p>It is built for the Python environment, and isn&#x27;t directly meant for use in external or cross-language serialization.</p>
    <p>However, it can do something that no other Python serializer can do: get rid of all of your <code>PicklingErrors</code>.</p>
    <p>If you need super fast speed for simple types, use base <code>pickle</code>. It is literally what Python originally gave us! Of course it&#x27;s the fastest.</p>
    <p>But, if you need to serialize anything else, use <code><suitkaise-api>cucumber</suitkaise-api></code>.</p>
    <h3><code>pickle</code> vs <code><suitkaise-api>cucumber</suitkaise-api></code> — same object, different outcomes</h3>
    <pre><code class="language-python">import threading

class Worker:
    def __init__(self):
        self.lock = threading.Lock()
        self.thread = threading.Thread(target=self.run)
        self.results = []
    
    def run(self):
        self.results.append(&quot;done&quot;)

worker = Worker()</code></pre>
    <p><strong>With <code>pickle</code>:</strong></p>
    <pre><code class="language-python">import pickle
pickle.dumps(worker)
# TypeError: cannot pickle &#x27;_thread.lock&#x27; objects</code></pre>
    <p><strong>With <code>cloudpickle</code>:</strong></p>
    <pre><code class="language-python">import cloudpickle
cloudpickle.dumps(worker)
# TypeError: cannot pickle &#x27;_thread.lock&#x27; objects</code></pre>
    <p><strong>With <code><suitkaise-api>cucumber</suitkaise-api></code>:</strong></p>
    <pre><code class="language-python">from <suitkaise-api>suitkaise</suitkaise-api> import <suitkaise-api>cucumber</suitkaise-api>
        
data = <suitkaise-api>cucumber</suitkaise-api>.<suitkaise-api>serialize</suitkaise-api>(worker)
restored = <suitkaise-api>cucumber</suitkaise-api>.<suitkaise-api>deserialize</suitkaise-api>(data)
# works. lock and thread become Reconnectors, ready to be recreated.
<suitkaise-api>cucumber</suitkaise-api>.<suitkaise-api>reconnect_all</suitkaise-api>(restored)
# lock and thread are live again.</code></pre>
    <p>No errors. No workarounds. No tiptoeing around types that cause <code>PicklingErrors</code>.</p>
    <h3>Serialize anything using <code><suitkaise-api>cucumber</suitkaise-api></code></h3>
    <p><code><suitkaise-api>cucumber</suitkaise-api></code> handles every type that <code>dill</code> and <code>cloudpickle</code> can handle.</p>
    <p>It also handles many more types that are frequently used in higher level programming and parallel processing.</p>
    <p>And, it can handle user created classes, with all of these objects!</p>
    <ul>
        <li>Handles user created classes</li>
        <li>Can handle generators with state</li>
        <li>Handles asyncio</li>
        <li>Handles multiprocessing and threading</li>
    </ul>
    <h4>Types only <code><suitkaise-api>cucumber</suitkaise-api></code> can handle</h4>
    <ul>
        <li><code>threading.local</code></li>
        <li><code>multiprocessing.Queue</code></li>
        <li><code>multiprocessing.Event</code></li>
        <li><code>multiprocessing.Manager</code></li>
        <li><code>queue.SimpleQueue</code></li>
        <li><code>mmap</code></li>
        <li><code>re.Match</code></li>
        <li><code>sqlite3.Connection</code></li>
        <li><code>sqlite3.Cursor</code></li>
        <li><code>socket.socket</code></li>
        <li><code>GeneratorType</code></li>
        <li><code>CoroutineType</code></li>
        <li><code>AsyncGeneratorType</code></li>
        <li><code>asyncio.Task</code></li>
        <li><code>asyncio.Future</code></li>
        <li><code>ThreadPoolExecutor</code></li>
        <li><code>ProcessPoolExecutor</code></li>
        <li><code>ContextVar</code></li>
        <li><code>Token</code></li>
        <li><code>subprocess.Popen</code></li>
        <li><code>FrameType</code></li>
    </ul>
    <h4>User created classes</h4>
    <p><code><suitkaise-api>cucumber</suitkaise-api></code> has a way to dissect your class instances, allowing you to serialize essentially anything.</p>
    <h4>Classes defined in <code>__main__</code></h4>
    <p><code><suitkaise-api>cucumber</suitkaise-api></code> can handle classes defined in <code>__main__</code>.</p>
    <ul>
        <li>Enables multiprocessing when quickly prototyping in one file</li>
        <li>Allows for easy testing using CodeRunners</li>
    </ul>
    <h4>Circular references</h4>
    <p><code><suitkaise-api>cucumber</suitkaise-api></code> handles all circular references in your objects.</p>
    <h3>Superior speed</h3>
    <p><code><suitkaise-api>cucumber</suitkaise-api></code> is faster than <code>cloudpickle</code> and <code>dill</code> for most simple types.</p>
    <p>Additionally, it is multiple times faster that both of them for many types.</p>
    <ul>
        <li><code>NamedTemporaryFile</code> — 33x faster</li>
        <li><code>TextIOWrapper</code> — 21x faster</li>
        <li><code>threading.Thread</code> — 5x faster</li>
        <li><code>dataclass</code> — 2.5x faster</li>
        <li><code>int</code> — 2x faster</li>
        <li>And more</li>
    </ul>
    <p>For a full performance breakdown, head to the performance page.</p>
    <h3>Actually reconstructs objects</h3>
    <p><code><suitkaise-api>cucumber</suitkaise-api></code> intelligently reconstructs complex objects using custom handlers.</p>
    <ul>
        <li>Easy reconnection to live resources like database connections, sockets, threads, and more while maintaining security</li>
    </ul>
    <p>All you have to do after deserializing is call <code><suitkaise-api>reconnect_all</suitkaise-api>()</code> and provide any authentication needed, and all of your live resources will be recreated automatically.</p>
    <p>You can even start threads automatically if you use <code><suitkaise-api>cucumber</suitkaise-api></code>.</p>
    <h4>The <code>Reconnector</code> pattern — nothing else does this</h4>
    <p>When <code><suitkaise-api>cucumber</suitkaise-api></code> encounters a live resource (a database connection, an open socket, a running thread), it doesn&#x27;t try to freeze and resume it -- that would be unsafe and often impossible. Instead, it creates a <code>Reconnector</code> object that stores the information needed to recreate the resource.</p>
    <pre><code class="language-python">import psycopg2
from <suitkaise-api>suitkaise</suitkaise-api> import <suitkaise-api>cucumber</suitkaise-api>

# serialize a live database connection
conn = psycopg2.connect(host=&#x27;localhost&#x27;, database=&#x27;mydb&#x27;, password=&#x27;secret&#x27;)
data = <suitkaise-api>cucumber</suitkaise-api>.<suitkaise-api>serialize</suitkaise-api>(conn)

# deserialize it in another process
restored = <suitkaise-api>cucumber</suitkaise-api>.<suitkaise-api>deserialize</suitkaise-api>(data)
# restored.connection is a Reconnector, not a live connection yet

# reconnect with credentials (password is never stored in serialized data)
<suitkaise-api>cucumber</suitkaise-api>.<suitkaise-api>reconnect_all</suitkaise-api>(restored, password=&#x27;secret&#x27;)
# now restored.connection is a live psycopg2 connection again</code></pre>
    <p>This is a security-conscious design: authentication credentials are never stored in the serialized bytes. You provide them at reconnection time, so serialized data can be stored or transferred without leaking secrets.</p>
    <p>No other Python serializer has this concept. Most either crash on live resources or silently produce broken objects.</p>
    <p>Additionally, objects that don&#x27;t need auth will be lazily reconstructed on first attribute access.</p>
    <h3>Easy inspection and error analysis</h3>
    <p><code><suitkaise-api>cucumber</suitkaise-api></code> creates an intermediate representation (IR) of the object using <code>pickle</code> native types before using base <code>pickle</code> to serialize it to bytes.</p>
    <pre><code class="language-python">{
    &quot;__cucumber_type__&quot;: &quot;&lt;type_name&gt;&quot;,
    &quot;__handler__&quot;: &quot;&lt;handler_name&gt;&quot;,
    &quot;__object_id__&quot;: &lt;id&gt;,
    &quot;state&quot;: {
        # object&#x27;s state in IR form
    }
}</code></pre>
    <p>This allows everything to be cleanly organized and inspected.</p>
    <p>Additionally, <code><suitkaise-api>cucumber</suitkaise-api></code> functions provide traceable, simple explanations of what went wrong if something fails.</p>
    <pre><code class="language-python"># all you have to do is add debug=True
<suitkaise-api>cucumber</suitkaise-api>.<suitkaise-api>serialize</suitkaise-api>(obj, debug=True)</code></pre>
    <p>It also has an option to see how the object is getting serialized or reconstructed in real time with color-coded output.</p>
    <pre><code class="language-python"># all you have to do is add verbose=True
<suitkaise-api>cucumber</suitkaise-api>.<suitkaise-api>serialize</suitkaise-api>(obj, verbose=True)</code></pre>
    <h2>How do I know that <code><suitkaise-api>cucumber</suitkaise-api></code> can handle any user class?</h2>
    <p><code><suitkaise-api>cucumber</suitkaise-api></code> can serialize any object as long as it contains supported types.</p>
    <p>99% of Python objects only have supported types within them.</p>
    <p>To prove to you that <code><suitkaise-api>cucumber</suitkaise-api></code> can handle any user class, I created a monster.</p>
    <h3>The <code>WorstPossibleObject</code></h3>
    <p><code>WorstPossibleObject</code> is an object I created that would never exist in real life.</p>
    <p>Its only goal: try and break <code><suitkaise-api>cucumber</suitkaise-api></code>.</p>
    <p>It contains every type that <code><suitkaise-api>cucumber</suitkaise-api></code> can handle, in a super nested, circular-referenced, randomly-generated structure.</p>
    <p>Each <code>WorstPossibleObject</code> is different from the last, and they all have ways to verify that they remain intact after being converted to and from bytes.</p>
    <p>Not only does <code><suitkaise-api>cucumber</suitkaise-api></code> handle this object, but it can handle more than 100 different <code>WorstPossibleObjects</code> per second.</p>
    <p><strong>By handle, I mean:</strong></p>
    <ol>
        <li>Serialize it to bytes</li>
        <li>I pass it to a different process</li>
        <li>Deserialize it</li>
        <li>Reconnect everything</li>
    </ol>
    <p>It can then verify that it is the same object as it was when it got created, and that all of its complex objects within still work as expected.</p>
    <p>This test includes a full round trip.</p>
    <pre><code class="language-text">`<suitkaise-api>serialize</suitkaise-api>()` → another process → `<suitkaise-api>deserialize</suitkaise-api>()` → `<suitkaise-api>reconnect_all</suitkaise-api>()` → verify → `<suitkaise-api>serialize</suitkaise-api>()` → back to original process → `<suitkaise-api>deserialize</suitkaise-api>()` → `<suitkaise-api>reconnect_all</suitkaise-api>()` → verify</code></pre>
    <p>To see the full <code>WorstPossibleObject</code> code, head to the worst possible object page. Have fun!</p>
    <h2>Where <code><suitkaise-api>cucumber</suitkaise-api></code> sits in the landscape</h2>
    <p><code><suitkaise-api>cucumber</suitkaise-api></code>&#x27;s real competitor is <code>dill</code>, not <code>cloudpickle</code>. Both <code><suitkaise-api>cucumber</suitkaise-api></code> and <code>dill</code> prioritize type coverage over raw speed. The difference: <code><suitkaise-api>cucumber</suitkaise-api></code> far outclasses <code>dill</code> on speed while exceeding its type coverage.</p>
    <p>The fact that <code><suitkaise-api>cucumber</suitkaise-api></code> also competes with <code>cloudpickle</code> on speed -- despite covering vastly more types -- is the surprising part. <code>cloudpickle</code> is designed for speed with limited types. <code><suitkaise-api>cucumber</suitkaise-api></code> is designed for coverage and still keeps up.</p>
    <ul>
        <li>Need raw speed on simple types? Use base <code>pickle</code>.</li>
        <li>Need slightly more type coverage with great speed? <code>cloudpickle</code> is solid.</li>
        <li>Need everything to just work, with no <code>PicklingError</code> ever, and still competitive speed? That&#x27;s <code><suitkaise-api>cucumber</suitkaise-api></code>.</li>
    </ul>
    <p>For a full performance breakdown, head to the performance page.</p>
    <h2>Works with the rest of <code><suitkaise-api>suitkaise</suitkaise-api></code></h2>
    <p><code><suitkaise-api>cucumber</suitkaise-api></code> is the serialization backbone of the <code><suitkaise-api>suitkaise</suitkaise-api></code> ecosystem.</p>
    <ul>
        <li><code><suitkaise-api>processing</suitkaise-api></code> uses <code><suitkaise-api>cucumber</suitkaise-api></code> by default for all cross-process communication. Every <code><suitkaise-api>Skprocess</suitkaise-api></code>, every <code><suitkaise-api>Pool</suitkaise-api>.<suitkaise-api>map</suitkaise-api></code>, every <code><suitkaise-api>Share</suitkaise-api></code> operation goes through <code><suitkaise-api>cucumber</suitkaise-api></code>. You never think about serialization.</li>
        <li><code><suitkaise-api>@autoreconnect</suitkaise-api></code> from <code><suitkaise-api>processing</suitkaise-api></code> builds on the <code>Reconnector</code> pattern to automatically reconnect live resources (like database connections) when they cross process boundaries.</li>
        <li><code><suitkaise-api>Share</suitkaise-api></code> relies on <code><suitkaise-api>cucumber</suitkaise-api></code> to serialize any object you assign to it. This is what makes <code>share.anything = any_object</code> possible.</li>
        <li>All <code><suitkaise-api>suitkaise</suitkaise-api></code> objects (<code><suitkaise-api>Sktimer</suitkaise-api></code>, <code><suitkaise-api>Circuit</suitkaise-api></code>, <code><suitkaise-api>Skpath</suitkaise-api></code>, etc.) are designed to serialize cleanly through <code><suitkaise-api>cucumber</suitkaise-api></code>.</li>
    </ul>
</section>
