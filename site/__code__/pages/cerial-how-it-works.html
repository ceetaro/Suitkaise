<div class="module-bar" data-module="cerial">
    <button class="module-bar-title">suitkaise.cerial</button>
    <nav class="module-bar-nav">
        <a href="#cerial-why" class="module-bar-link" data-page="cerial-why">why</a>
        <a href="#cerial" class="module-bar-link" data-page="cerial">how to use</a>
        <a href="#cerial-how-it-works" class="module-bar-link active" data-page="cerial-how-it-works">how it works</a>
        <a href="#cerial-supported-types" class="module-bar-link" data-page="cerial-supported-types">supported types</a>
        <a href="#cerial-tests" class="module-bar-link" data-page="cerial-tests">tests</a>
        <a href="#cerial-examples" class="module-bar-link" data-page="cerial-examples">examples</a>
        <a href="#cerial-videos" class="module-bar-link" data-page="cerial-videos">videos</a>
        <a href="#cerial-learn" class="module-bar-link" data-page="cerial-learn">learn</a>
    </nav>
</div>
<section class="module-page">
    <h1>How <code>cerial</code> actually works</h1>

    <p><code>cerial</code> has no dependencies outside of the standard library.</p>

    <p>It is a serialization engine that handles complex Python objects that <code>pickle</code>, <code>cloudpickle</code>, and <code>dill</code> cannot.</p>

    <hr>

    <h2>Overview</h2>

    <p><code>cerial</code> uses a two-phase approach.</p>

    <ol>
        <li><strong>Transform</strong> — Convert unpickleable objects into an intermediate representation (IR) using handlers for complex objects</li>
        <li><strong>Serialize</strong> — Use standard <code>pickle.dumps()</code> on the IR</li>
    </ol>

    <p>Deserialization is the reverse.</p>

    <ol>
        <li><strong>Deserialize</strong> — Use <code>pickle.loads()</code> to get the IR</li>
        <li><strong>Reconstruct</strong> — Convert the IR back into the original objects using the handlers</li>
    </ol>

<pre><code>Object → Handler(s) → IR (nested dicts) → pickle.dumps() → bytes

bytes → pickle.loads() → IR → Handler(s) → Object</code></pre>

    <hr>

    <h2>Intermediate Representation (IR)</h2>

    <p>The intermediate representation is a nested <code>dict</code> containing only pickle native types.</p>

    <ul>
        <li>dicts, lists, tuples, sets</li>
        <li>ints, strings, bools, None</li>
        <li>other pickle-native types (datetime, Decimal, etc.)</li>
    </ul>

    <p>Complex objects get converted to dicts with special markers.</p>

<pre><code class="language-python">{
    "__cerial_type__": "lock",           # type identifier
    "__handler__": "LockHandler",        # which handler serialized it
    "__object_id__": 140234567890,       # for circular reference tracking
    "state": {                           # actual data (handler-specific)
        "locked": False
    }
}</code></pre>

    <ul>
        <li>Mirrors the original object structure</li>
        <li>Can nest infinitely deep</li>
        <li>Lets primitive types pass through untouched</li>
        <li>Gives complex types their own dict at each level</li>
    </ul>

    <p>When you use <code>__serialize__</code> and <code>__deserialize__</code>, you are responsible for converting the object to a <code>dict</code> with only native <code>pickle</code> types. Do not convert to bytes, <code>cerial</code> will do that for you.</p>

    <hr>

    <h2>Handlers</h2>

    <p>Handlers are responsible for serializing and deserializing specific object types.</p>

    <p>Each handler:</p>
    <ul>
        <li>Defines a <code>type_name</code> (e.g., "lock", "logger", "class_instance")</li>
        <li>Implements <code>can_handle(obj)</code> to check if it handles this type</li>
        <li>Implements <code>extract_state(obj)</code> to extract serializable state</li>
        <li>Implements <code>reconstruct(state)</code> to rebuild the object</li>
    </ul>

    <h3>Handler Priority</h3>

    <p>Handlers are checked in order. Specialized handlers (locks, loggers, etc.) are checked before general ones:</p>

    <ol>
        <li>function handlers</li>
        <li>logging handlers</li>
        <li>threading handlers</li>
        <li>queue handlers</li>
        <li>file handlers</li>
        <li>database handlers</li>
        <li>network handlers</li>
        <li>generator and iterator handlers</li>
        <li>subprocess handlers</li>
        <li>async handlers</li>
        <li>context manager handlers</li>
        <li>module handlers</li>
        <li>class object handlers</li>
        <li>class instance handler</li>
    </ol>

    <p>For more info on exactly what is covered under each handler, navigate down to "What Can <code>cerial</code> Handle?"</p>

    <hr>

    <h2>Main Serializer (<code>Cerializer</code>)</h2>

    <p>Coordinates the entire process.</p>

    <h3>Serialization Flow</h3>

    <ol>
        <li><strong>Reset state</strong> — Clear circular reference tracker, depth counter, etc.</li>
        <li><strong>Recursive serialization</strong> — Build the IR by walking the object tree</li>
        <li><strong>Pickle</strong> — Call <code>pickle.dumps()</code> on the IR</li>
        <li><strong>Return bytes</strong></li>
    </ol>

    <h3><code>_serialize_recursive()</code></h3>

    <p>This is the main function that builds the intermediate representation.</p>

    <ol>
        <li><strong>Check recursion depth</strong> — Prevent stack overflow on deeply nested objects</li>
        <li><strong>Check for circular references</strong>
            <ul>
                <li>If we've seen this exact object before, return a reference marker</li>
                <li>If not, mark it as seen and continue</li>
            </ul>
        </li>
        <li><strong>Check if pickle-native</strong>
            <ul>
                <li>Primitives (int, str, None, etc.) → return as-is</li>
                <li>Collections (dict, list, tuple, set) → recursively serialize contents</li>
            </ul>
        </li>
        <li><strong>Find handler</strong> — Match the object to a handler</li>
        <li><strong>Extract state</strong> — Handler converts object to a dict/list</li>
        <li><strong>Recursively serialize state</strong> — The extracted state might contain more complex objects!</li>
        <li><strong>Wrap in metadata</strong> — Add <code>__cerial_type__</code>, <code>__handler__</code>, <code>__object_id__</code></li>
        <li><strong>Return</strong> — The fully serialized structure</li>
    </ol>

    <p>Step 6 is especially important in the quest to serialize any complex object. Some objects may have other complex objects inside them.</p>

    <p><code>cerial</code> recursively processes everything until the entire representation is pickle native.</p>

    <hr>

    <h2>Circular Reference Handling</h2>

    <p>Objects can reference each other or themselves:</p>

<pre><code class="language-python">obj.self_ref = obj  # self-reference
obj_a.ref = obj_b   # mutual reference
obj_b.ref = obj_a</code></pre>

    <p><code>cerial</code> handles this with object ID tracking:</p>

    <h3>During Serialization</h3>

    <ol>
        <li>Each object gets a unique ID (<code>id(obj)</code>)</li>
        <li>Before serializing, check if we've seen this ID</li>
        <li>If yes, return a reference marker instead of re-serializing</li>
        <li>If no, add to seen set and continue</li>
    </ol>

    <p>Reference markers look like:</p>

<pre><code class="language-python">{"__cerial_ref__": 140234567890}</code></pre>

    <h3>Deserialization</h3>

    <p>Some circular structures need two passes.</p>

    <p><strong>Pass 1: Create shells</strong></p>
    <ul>
        <li>Create empty/placeholder objects</li>
        <li>Store by object ID in a lookup table</li>
    </ul>

    <p><strong>Pass 2: Fill in state</strong></p>
    <ul>
        <li>Now that all objects exist, populate their state</li>
        <li>References can be resolved because all objects are in the lookup</li>
    </ul>

    <p>This handles cases like:</p>

<pre><code class="language-python">a = SomeClass()
b = SomeClass()
a.ref = b
b.ref = a  # both need to exist before either can be fully populated</code></pre>

    <hr>

    <h2>Class Instance Handler</h2>

    <p>The most complex handler — handles all user-defined class instances.</p>

    <h3>Extraction Strategy Hierarchy</h3>

    <ol>
        <li><strong>Custom methods</strong> — <code>__serialize__</code> / <code>__deserialize__</code> (highest priority)</li>
        <li><strong>Common patterns</strong> — <code>to_dict()</code> / <code>from_dict()</code></li>
        <li><strong>Fallback</strong> — <code>__dict__</code> access</li>
    </ol>

    <h3>Strategy 1: Custom Serialize</h3>

    <p>If a class has <code>__serialize__</code> and <code>__deserialize__</code>:</p>

<pre><code class="language-python">class MyClass:
    def __serialize__(self):
        return {"custom": "state"}
    
    @classmethod
    def __deserialize__(cls, state):
        obj = cls.__new__(cls)
        obj.custom = state["custom"]
        return obj</code></pre>

    <p>This gives you full control over what gets serialized.</p>

    <h3>Strategy 2: to_dict / from_dict</h3>

    <p>Common pattern in many libraries:</p>

<pre><code class="language-python">class Config:
    def to_dict(self):
        return {"key": self.key, "value": self.value}
    
    @classmethod
    def from_dict(cls, data):
        return cls(key=data["key"], value=data["value"])</code></pre>

    <h3>Strategy 3: __dict__ Fallback</h3>

    <p>Works for most simple classes:</p>

<pre><code class="language-python"># Extraction
state = obj.__dict__.copy()

# Reconstruction
new_obj = SomeClass.__new__(SomeClass)
new_obj.__dict__.update(state)</code></pre>

    <h3>Handling Special Cases</h3>

    <ul>
        <li><strong>Nested classes</strong> — Stores module and qualname for lookup</li>
        <li><strong>Classes in <code>__main__</code></strong> — Handled specially by embedding class definitions for reconstruction</li>
        <li><strong>Classes with <code>__slots__</code></strong> — Iterates over slot names</li>
        <li><strong>Classes with both <code>__dict__</code> and <code>__slots__</code></strong> — Handles both</li>
    </ul>

    <hr>

    <details>
        <summary><h3 style="display: inline;">What Can <code>cerial</code> Handle?</h3></summary>

        <h3>Functions</h3>
        <ul>
            <li>Regular functions</li>
            <li>Nested functions</li>
            <li>Functions in <code>__main__</code></li>
            <li>Lambdas</li>
            <li><code>functools.partial</code> functions</li>
            <li>Bound methods</li>
            <li><code>@staticmethod</code> and <code>@classmethod</code></li>
            <li><code>@property</code> methods</li>
        </ul>

        <h3>Classes and Instances</h3>
        <ul>
            <li>Dataclasses</li>
            <li>Enums</li>
            <li>Instances with <code>__dict__</code></li>
            <li>Instances with <code>__slots__</code></li>
            <li>Instances with both</li>
            <li>Nested classes</li>
            <li>Dynamic classes (created with <code>type()</code>)</li>
            <li>NamedTuples</li>
        </ul>

        <h3>Threading</h3>
        <ul>
            <li><code>Lock</code> and <code>RLock</code></li>
            <li><code>Semaphore</code> and <code>BoundedSemaphore</code></li>
            <li><code>Barrier</code></li>
            <li><code>Condition</code></li>
            <li><code>Event</code></li>
            <li><code>threading.local</code></li>
        </ul>

        <h3>Queues</h3>
        <ul>
            <li><code>queue.Queue</code>, <code>LifoQueue</code>, <code>PriorityQueue</code></li>
            <li><code>multiprocessing.Queue</code>, <code>Event</code></li>
        </ul>

        <h3>File and I/O</h3>
        <ul>
            <li>File handles (open files)</li>
            <li>Temporary files (<code>tempfile.NamedTemporaryFile</code>)</li>
            <li><code>StringIO</code></li>
            <li><code>BytesIO</code></li>
            <li>Memory-mapped files (<code>mmap</code>)</li>
        </ul>

        <h3>Logging</h3>
        <ul>
            <li><code>Logger</code></li>
            <li><code>StreamHandler</code>, <code>FileHandler</code></li>
            <li><code>Formatter</code></li>
        </ul>

        <h3>Database</h3>
        <ul>
            <li>SQLite connections and cursors</li>
        </ul>

        <h3>Network</h3>
        <ul>
            <li>HTTP sessions (<code>requests.Session</code>)</li>
            <li>Sockets</li>
        </ul>

        <h3>Subprocess</h3>
        <ul>
            <li><code>subprocess.Popen</code></li>
            <li><code>subprocess.CompletedProcess</code></li>
        </ul>

        <h3>Async</h3>
        <ul>
            <li>Coroutines</li>
            <li>Async generators</li>
            <li><code>asyncio.Task</code></li>
            <li><code>asyncio.Future</code></li>
        </ul>

        <h3>Advanced Python</h3>
        <ul>
            <li>Generators (with state)</li>
            <li>Iterators</li>
            <li>Regex patterns (<code>re.Pattern</code>)</li>
            <li>Weak references</li>
            <li>Code objects</li>
            <li>Properties and descriptors</li>
            <li>Context variables</li>
            <li>Pipes</li>
            <li>Shared memory</li>
            <li>Executors</li>
        </ul>

        <p>For a full list of supported types, see the supported-types page.</p>
    </details>

    <hr>

    <h2>Debug and Verbose Modes</h2>

    <h3><code>verbose=True</code></h3>

    <p>Prints the path through your object as it serializes:</p>

<pre><code>  [1] MyService
    [2] MyService → config
      [3] MyService → config → dict
        [4] ... → config → dict → database</code></pre>

    <p>Color-coded by depth for easy reading.</p>

    <h3><code>debug=True</code></h3>

    <p>Provides detailed error messages when something fails:</p>

<pre><code>======================================================================
SERIALIZATION ERROR
======================================================================

Error: Cannot serialize object

Path: MyService → config → handler

Type: custom_object
Handler: ClassInstanceHandler

Object repr: &lt;MyHandler at 0x...&gt;
======================================================================</code></pre>

    <p>The path tells you exactly where in your nested object the failure occurred.</p>

    <hr>

    <h2>Performance Considerations</h2>

    <ul>
        <li><strong>Primitive types</strong> — Pass through with minimal overhead</li>
        <li><strong>Collections</strong> — Contents are processed recursively</li>
        <li><strong>Complex objects</strong> — Handler lookup + state extraction + recursion</li>
        <li><strong>Circular references</strong> — Handled with O(1) lookup in seen set</li>
    </ul>

    <p><code>cerial</code> is optimized for coverage over raw speed. If you need the fastest serialization for simple types, use base <code>pickle</code>. Otherwise, use <code>cerial</code>. It is better than <code>cloudpickle</code> and <code>dill</code> in most cases, other than pure speed with simple functions.</p>

    <hr>

    <h2>Thread Safety</h2>

    <p>The serializer is designed for single-threaded use within a single serialize/deserialize call. Each call gets fresh state (seen objects, depth counter, etc.).</p>

    <p>If you need to serialize from multiple threads, create separate calls — don't share state between them.</p>

</section>
