<div class="module-bar" data-module="sk">
    <button class="module-bar-title">suitkaise.sk</button>
    <nav class="module-bar-nav">
        <a href="#sk-why" class="module-bar-link" data-page="sk-why">why</a>
        <a href="#sk-quick-start" class="module-bar-link" data-page="sk-quick-start">quick start</a>
        <a href="#sk" class="module-bar-link active" data-page="sk">how to use</a>
        <a href="#sk-how-it-works" class="module-bar-link" data-page="sk-how-it-works">how it works</a>
        <a href="#sk-examples" class="module-bar-link" data-page="sk-examples">examples</a>
        <a href="#sk-blocking-calls" class="module-bar-link" data-page="sk-blocking-calls">blocking calls</a>
        <a href="#sk-videos" class="module-bar-link" data-page="sk-videos">videos</a>
        <a href="#sk-learn" class="module-bar-link" data-page="sk-learn">learn</a>
    </nav>
</div>
<section class="module-page">
    <h1>How to use <code><suitkaise-api>sk</suitkaise-api></code></h1>
    <p><code><suitkaise-api>sk</suitkaise-api></code> adds powerful modifiers to your functions and classes. No wrapper objects, no changed calls.</p>
    <p><code><suitkaise-api>sk</suitkaise-api></code>: works as a decorator or a regular function.</p>
    <ul>
        <li>Works on functions and classes</li>
        <li>adds <code>.<suitkaise-api>asynced</suitkaise-api>()</code>, <code>.<suitkaise-api>retry</suitkaise-api>()</code>, <code>.<suitkaise-api>timeout</suitkaise-api>()</code>, <code>.<suitkaise-api>background</suitkaise-api>()</code>, <code>.rate_limit()</code></li>
        <li>Generates <code>_shared_meta</code> for <code>Share</code> compatibility</li>
        <li>Auto-detects blocking code</li>
    </ul>
    <p><code><suitkaise-api>@blocking</suitkaise-api></code> decorator: explicitly mark blocking code.</p>
    <ul>
        <li>Use when AST detection misses CPU-intensive work</li>
        <li>Skips AST analysis (faster)</li>
    </ul>
    <h2>Importing</h2>
    <pre><code class="language-python">from <suitkaise-api>suitkaise</suitkaise-api> import <suitkaise-api>sk</suitkaise-api>, <suitkaise-api>blocking</suitkaise-api></code></pre>
    <pre><code class="language-python">from <suitkaise-api>suitkaise</suitkaise-api>.<suitkaise-api>sk</suitkaise-api> import <suitkaise-api>FunctionTimeoutError</suitkaise-api>, <suitkaise-api>SkModifierError</suitkaise-api></code></pre>
    <h2><code><suitkaise-api>sk</suitkaise-api></code> on Functions</h2>
    <p>Use as a decorator or call directly.</p>
    <pre><code class="language-python">from <suitkaise-api>suitkaise</suitkaise-api> import <suitkaise-api>sk</suitkaise-api>
import requests

# as a decorator
<suitkaise-api>@sk</suitkaise-api>
def fetch_data(url):
    return requests.get(url).json()

# or as a function
def fetch_data(url):
    return requests.get(url).json()

fetch_data = <suitkaise-api>sk</suitkaise-api>(fetch_data)</code></pre>
    <p>The function works exactly as before:</p>
    <pre><code class="language-python">data = fetch_data(&quot;https://api.example.com/data&quot;)</code></pre>
    <p>But now you have modifiers:</p>
    <pre><code class="language-python"># async version
data = await fetch_data.<suitkaise-api>asynced</suitkaise-api>()(&quot;https://api.example.com/data&quot;)</code></pre>
    <pre><code class="language-python"># with retry
data = fetch_data.<suitkaise-api>retry</suitkaise-api>(times=3, delay=1.0)(&quot;https://api.example.com/data&quot;)</code></pre>
    <pre><code class="language-python"># with timeout
data = fetch_data.<suitkaise-api>timeout</suitkaise-api>(5.0)(&quot;https://api.example.com/data&quot;)</code></pre>
    <pre><code class="language-python"># run in background (returns Future)
future = fetch_data.<suitkaise-api>background</suitkaise-api>()(&quot;https://api.example.com/data&quot;)
result = future.<suitkaise-api>result</suitkaise-api>()</code></pre>
    <pre><code class="language-python"># rate limited
data = fetch_data.rate_limit(2.0)(&quot;https://api.example.com/data&quot;)</code></pre>
    <h3>Chaining Modifiers</h3>
    <p>Modifiers can be chained in any order. The execution order is always consistent:</p>
    <pre><code class="language-python"># these are equivalent
data = fetch_data.<suitkaise-api>retry</suitkaise-api>(3).<suitkaise-api>timeout</suitkaise-api>(5.0)(&quot;https://example.com&quot;)
data = fetch_data.<suitkaise-api>timeout</suitkaise-api>(5.0).<suitkaise-api>retry</suitkaise-api>(3)(&quot;https://example.com&quot;)</code></pre>
    <p>Both will retry up to 3 times, with a 5-second timeout per attempt.</p>
    <h3>Checking for Blocking Calls</h3>
    <pre><code class="language-python"><suitkaise-api>@sk</suitkaise-api>
def slow_fetch(url):
    return requests.get(url).text

print(slow_fetch.<suitkaise-api>has_blocking_calls</suitkaise-api>) # True
print(slow_fetch.<suitkaise-api>blocking_calls</suitkaise-api>) # [&#x27;requests.get&#x27;]</code></pre>
    <h2><code><suitkaise-api>sk</suitkaise-api></code> on Classes</h2>
    <p>Use as a decorator or call directly.</p>
    <pre><code class="language-python">from <suitkaise-api>suitkaise</suitkaise-api> import <suitkaise-api>sk</suitkaise-api>

# as a decorator
<suitkaise-api>@sk</suitkaise-api>
class DataProcessor:
    def __init__(self, config):
        self.config = config
        self.results = []
    
    def process(self, data):
        # heavy processing
        return transform(data)
    
    def save(self, path):
        with open(path, &#x27;w&#x27;) as f:
            f.write(json.dumps(self.results))

# or as a function
class DataProcessor:
    # your code here

DataProcessor = <suitkaise-api>sk</suitkaise-api>(DataProcessor)</code></pre>
    <p>Use normally:</p>
    <pre><code class="language-python">processor = DataProcessor(config)
processor.process(data)
processor.save(&quot;output.json&quot;)</code></pre>
    <p>Use with modifiers:</p>
    <pre><code class="language-python"># async
await processor.<suitkaise-api>process.asynced()</suitkaise-api>(data)

# with timeout
processor.save.<suitkaise-api>timeout</suitkaise-api>(10.0)(&quot;output.json&quot;)

# with retry
processor.<suitkaise-api>process.retry(</suitkaise-api>3)(data)

# in background
future = processor.save.<suitkaise-api>background</suitkaise-api>()(&quot;output.json&quot;)</code></pre>
    <h3>Class Level Async</h3>
    <p>Get an async version of the entire class:</p>
    <pre><code class="language-python">AsyncProcessor = DataProcessor.<suitkaise-api>asynced</suitkaise-api>()
processor = AsyncProcessor(config)

# all blocking methods are now async
await processor.process(data)
await processor.save(&quot;output.json&quot;)</code></pre>
    <p>Only available if the class has blocking calls:</p>
    <pre><code class="language-python"><suitkaise-api>@sk</suitkaise-api>
class Counter:
    def __init__(self):
        self.value = 0
    
    def increment(self):
        self.value += 1

Counter.<suitkaise-api>asynced</suitkaise-api>()  # raises SkModifierError - no blocking calls</code></pre>
    <h3><code><suitkaise-api>Share</suitkaise-api></code> Compatibility</h3>
    <p><code><suitkaise-api>@sk</suitkaise-api></code> generates <code>_shared_meta</code> automatically.</p>
    <pre><code class="language-python">from <suitkaise-api>suitkaise</suitkaise-api>.<suitkaise-api>processing</suitkaise-api> import <suitkaise-api>Share</suitkaise-api>

<suitkaise-api>@sk</suitkaise-api>
class Counter:
    def __init__(self):
        self.value = 0
    
    def increment(self):
        self.value += 1

<suitkaise-api>share</suitkaise-api> = <suitkaise-api>Share(</suitkaise-api>)
share.counter = Counter()

# works across processes
share.counter.increment()
print(share.counter.value)</code></pre>
    <h2><code><suitkaise-api>@blocking</suitkaise-api></code> Decorator</h2>
    <p>Explicitly mark code as blocking when AST detection doesn&#x27;t catch it.</p>
    <h3>On Functions</h3>
    <pre><code class="language-python">from <suitkaise-api>suitkaise</suitkaise-api> import <suitkaise-api>sk</suitkaise-api>, <suitkaise-api>blocking</suitkaise-api>

<suitkaise-api>@sk</suitkaise-api>
<suitkaise-api>@blocking</suitkaise-api>
def heavy_computation():
    # CPU intensive work that AST can&#x27;t detect
    return sum(x**2 for x in range(10_000_000))

# now .asynced() and .background() are available
result = await heavy_computation.<suitkaise-api>asynced</suitkaise-api>()()</code></pre>
    <h3>On Methods</h3>
    <pre><code class="language-python"><suitkaise-api>@sk</suitkaise-api>
class Worker:
    <suitkaise-api>@blocking</suitkaise-api>
    def compute(self):
        # CPU-intensive work
        return complex_calculation()
    
    def quick_check(self):
        # not blocking
        return self.ready

# compute is blocking, quick_check is not
print(Worker._blocking_methods)  # {&#x27;compute&#x27;: [&#x27;@blocking&#x27;]}</code></pre>
    <h3>Why use <code><suitkaise-api>@blocking</suitkaise-api></code>?</h3>
    <p>AST detection looks for known patterns like <code>time.sleep()</code>, <code>requests.get()</code>, file I/O, database calls, etc.</p>
    <p>But it can&#x27;t detect:</p>
    <ul>
        <li>Pure CPU work (tight loops, number crunching)</li>
        <li>C extensions that block</li>
        <li>Custom blocking functions</li>
    </ul>
    <p>Use <code><suitkaise-api>@blocking</suitkaise-api></code> when you know code will block the event loop.</p>
    <h2>Modifiers reference</h2>
    <h3><code>.<suitkaise-api>asynced</suitkaise-api>()</code></h3>
    <p>Run the function asynchronously using <code>asyncio.to_thread()</code>.</p>
    <pre><code class="language-python">result = await fetch_data.<suitkaise-api>asynced</suitkaise-api>()(&quot;https://example.com&quot;)</code></pre>
    <p>Requirements:</p>
    <ul>
        <li>Function must have blocking calls</li>
        <li>Or be decorated with <code><suitkaise-api>@blocking</suitkaise-api></code></li>
    </ul>
    <p>Raises:</p>
    <ul>
        <li><code><suitkaise-api>SkModifierError</suitkaise-api></code> if function has no blocking calls</li>
    </ul>
    <h3><code>.<suitkaise-api>retry</suitkaise-api>(times, delay, backoff_factor, exceptions)</code></h3>
    <p>Retry on failure with configurable backoff.</p>
    <pre><code class="language-python"># basic: 3 attempts, 1 second delay
result = fetch_data.<suitkaise-api>retry</suitkaise-api>(times=3)(&quot;https://example.com&quot;)

# with exponential backoff
result = fetch_data.<suitkaise-api>retry</suitkaise-api>(
    times=5,
    delay=1.0,
    backoff_factor=2.0,  # 1s, 2s, 4s, 8s between retries
)(&quot;https://example.com&quot;)

# only retry specific exceptions
result = fetch_data.<suitkaise-api>retry</suitkaise-api>(
    times=3,
    exceptions=(ConnectionError, TimeoutError),
)(&quot;https://example.com&quot;)</code></pre>
    <p>Arguments:</p>
    <ul>
        <li><code>times</code>: Maximum attempts (default: 3)</li>
        <li><code>delay</code>: Initial delay between retries in seconds (default: 1.0)</li>
        <li><code>backoff_factor</code>: Multiply delay after each retry (default: 1.0)</li>
        <li><code>exceptions</code>: Exception types to retry on (default: all)</li>
    </ul>
    <h3><code>.<suitkaise-api>timeout</suitkaise-api>(seconds)</code></h3>
    <p>Raise error if execution exceeds time limit.</p>
    <pre><code class="language-python">try:
    result = fetch_data.<suitkaise-api>timeout</suitkaise-api>(5.0)(&quot;https://slow-api.com&quot;)
except <suitkaise-api>FunctionTimeoutError</suitkaise-api>:
    print(&quot;Request timed out&quot;)</code></pre>
    <p>Arguments:</p>
    <ul>
        <li><code>seconds</code>: Maximum execution time</li>
    </ul>
    <p>Raises:</p>
    <ul>
        <li><code><suitkaise-api>FunctionTimeoutError</suitkaise-api></code> if timeout exceeded</li>
    </ul>
    <h3><code>.<suitkaise-api>background</suitkaise-api>()</code></h3>
    <p>Run in a background thread, return <code>Future</code> immediately.</p>
    <pre><code class="language-python">future = fetch_data.<suitkaise-api>background</suitkaise-api>()(&quot;https://example.com&quot;)

# do other work...

# block when you need the result
result = future.<suitkaise-api>result</suitkaise-api>()</code></pre>
    <p>Returns:</p>
    <ul>
        <li><code>concurrent.futures.Future</code></li>
    </ul>
    <h3><code>.rate_limit(per_second)</code></h3>
    <p>Throttle calls to a maximum rate.</p>
    <pre><code class="language-python"># max 2 calls per second
result = fetch_data.rate_limit(2.0)(&quot;https://example.com&quot;)</code></pre>
    <p>Arguments:</p>
    <ul>
        <li><code>per_second</code>: Maximum calls per second</li>
    </ul>
    <h2>Async Modifiers</h2>
    <p>When using <code>.<suitkaise-api>asynced</suitkaise-api>()</code>, you can chain async-compatible modifiers:</p>
    <pre><code class="language-python"># async with timeout
result = await fetch_data.<suitkaise-api>asynced</suitkaise-api>().<suitkaise-api>timeout</suitkaise-api>(5.0)(&quot;https://example.com&quot;)

# async with retry
result = await fetch_data.<suitkaise-api>asynced</suitkaise-api>().<suitkaise-api>retry</suitkaise-api>(3)(&quot;https://example.com&quot;)

# async with rate limit
result = await fetch_data.<suitkaise-api>asynced</suitkaise-api>().rate_limit(2.0)(&quot;https://example.com&quot;)

# chain multiple
result = await fetch_data.<suitkaise-api>asynced</suitkaise-api>().<suitkaise-api>retry</suitkaise-api>(3).<suitkaise-api>timeout</suitkaise-api>(10.0)(&quot;https://example.com&quot;)</code></pre>
    <h2>Modifier Execution Order</h2>
    <p>Modifiers always execute in this order, regardless of chain order:</p>
    <ol>
        <li>Rate limit (outermost) - throttle before each attempt</li>
        <li>Retry - retry loop</li>
        <li>Timeout - per-attempt timeout</li>
        <li>Function call (innermost)</li>
    </ol>
    <p>This means:</p>
    <pre><code class="language-python"># both of these:
fn.<suitkaise-api>retry</suitkaise-api>(3).<suitkaise-api>timeout</suitkaise-api>(5.0)
fn.<suitkaise-api>timeout</suitkaise-api>(5.0).<suitkaise-api>retry</suitkaise-api>(3)

# execute as:
# 1. for each of 3 attempts:
# 2.   start 5-second timer
# 3.   call function
# 4.   if timeout or error, retry</code></pre>
    <h2>Error Handling</h2>
    <h3><code><suitkaise-api>SkModifierError</suitkaise-api></code></h3>
    <p>Raised when an invalid modifier is used.</p>
    <pre><code class="language-python">from <suitkaise-api>suitkaise</suitkaise-api>.<suitkaise-api>sk</suitkaise-api> import <suitkaise-api>SkModifierError</suitkaise-api>

<suitkaise-api>@sk</suitkaise-api>
def quick_fn():
    return 42

try:
    await quick_fn.<suitkaise-api>asynced</suitkaise-api>()()
except <suitkaise-api>SkModifierError</suitkaise-api> as e:
    print(e)  # &quot;quick_fn has no blocking calls&quot;</code></pre>
    <h3><code><suitkaise-api>FunctionTimeoutError</suitkaise-api></code></h3>
    <p>Raised when <code>.<suitkaise-api>timeout</suitkaise-api>()</code> is exceeded.</p>
    <pre><code class="language-python">from <suitkaise-api>suitkaise</suitkaise-api>.<suitkaise-api>sk</suitkaise-api> import <suitkaise-api>FunctionTimeoutError</suitkaise-api>

try:
    result = slow_fn.<suitkaise-api>timeout</suitkaise-api>(1.0)()
except <suitkaise-api>FunctionTimeoutError</suitkaise-api> as e:
    print(e)  # &quot;slow_fn timed out after 1.0 seconds&quot;</code></pre>
    <h2>Properties</h2>
    <h3>On Functions</h3>
    <p>After <code><suitkaise-api>@sk</suitkaise-api></code>:</p>
    <pre><code class="language-python"><suitkaise-api>@sk</suitkaise-api>
def my_fn():
    time.sleep(1)

my_fn.<suitkaise-api>has_blocking_calls</suitkaise-api> # True
my_fn.<suitkaise-api>blocking_calls</suitkaise-api> # [&#x27;time.sleep&#x27;]</code></pre>
    <h3>On Classes</h3>
    <p>After <code><suitkaise-api>@sk</suitkaise-api></code>:</p>
    <pre><code class="language-python"><suitkaise-api>@sk</suitkaise-api>
class MyClass:
    def blocking_method(self):
        time.sleep(1)
    
    def quick_method(self):
        return 42

MyClass.<suitkaise-api>has_blocking_calls</suitkaise-api> # True
MyClass._blocking_methods # {&#x27;blocking_method&#x27;: [&#x27;time.sleep&#x27;]}
MyClass._shared_meta # {&#x27;methods&#x27;: {...}, &#x27;properties&#x27;: {...}}</code></pre>
</section>
