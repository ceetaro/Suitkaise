<div class="module-bar" data-module="skpath">
    <button class="module-bar-title">suitkaise.skpath</button>
    <nav class="module-bar-nav">
        <a href="#skpath" class="module-bar-link active" data-page="skpath">how to use</a>
        <a href="#skpath-how-it-works" class="module-bar-link" data-page="skpath-how-it-works">how it works</a>
        <a href="#skpath-videos" class="module-bar-link" data-page="skpath-videos">videos</a>
        <a href="#skpath-tests" class="module-bar-link" data-page="skpath-tests">tests</a>
        <a href="#skpath-examples" class="module-bar-link" data-page="skpath-examples">examples</a>
        <a href="#skpath-why" class="module-bar-link" data-page="skpath-why">why</a>
    </nav>
</div>
<section class="module-page">
    <h1>How to use <code>skpath</code></h1>

    <p><code>skpath</code> makes file paths much easier to work with.</p><br>

    <h2><code>SKPath</code> class</h2>

    <p>Special path object. Automatically detects your project root and uses it to normalize paths.</p>

    <ul>
        <li><code>SKPath.ap</code> - absolute path. All slashes are streamlined to <code>/</code> for cross-platform compatibility.
            <br><code>"Users/john/Documents/projects/myproject/feature1/file.txt"</code>
        </li>
        <li><code>SKPath.np</code> - normalized path, relative to project root
            <br><code>"myproject/feature1/file.txt"</code>
        </li>
    </ul>

<pre><code class="language-python">from suitkaise.skpath import SKPath

# create SKPath with caller file path
path = SKPath()

# create SKPath with a Path object
existing_path_from_old_code = Path("feature1/file.txt")

path = SKPath(existing_path_from_old_code)

# create with string 
path = SKPath("feature1/file.txt")</code></pre>

    <p>Recommend not relying on just on file name, add at least the directory too.</p>

<pre><code class="language-python">path = SKPath("file.txt") # DON'T DO THIS!</code></pre>

    <details>
        <summary><code>SKPath</code> Properties and Methods</summary>

        <ul>
            <li><code>ap</code> - absolute path</li>
            <li><code>np</code> - path normalized to project root</li>
        </ul>

        <p><strong>Unique to <code>SKPath</code></strong></p>

        <ul>
            <li><code>id</code> - reversible base64url encoded ID (can be used to reconstruct the path)</li>
            <li><code>root</code> - project root</li>
        </ul>

        <p><strong><code>pathlib</code> Compatible</strong></p>

        <ul>
            <li><code>name</code> - complete filename (<code>"file.txt"</code> → <code>"file.txt"</code>)</li>
            <li><code>stem</code> - filename without suffix (<code>"file.txt"</code> → <code>"file"</code>)</li>
            <li><code>suffix</code> - suffix of last part of path (<code>"file.txt"</code> → <code>".txt"</code>)</li>
            <li><code>suffixes</code> - list of all suffixes (<code>"file.tar.gz"</code> → <code>[".tar", ".gz"]</code>)</li>
            <li><code>parent</code> - parent directory of the path</li>
            <li><code>parts</code> - path parts as a tuple</li>
            <li><code>exists</code> - whether the path exists</li>
            <li><code>is_file</code> - whether the path is a file</li>
            <li><code>is_dir</code> - whether the path is a directory</li>
        </ul>

<pre><code class="language-python">path = SKPath("myproject/feature1")

# convert SKPath to a string
path_as_string = str(path)

# get the string representation of the path
path_as_repr = repr(path)

# __hash__ method uses md5 instead of SKPath.id's encoding
path_hash = hash(path)

# '==' works with Paths and strings as well
if path == other_path:
    # ...

# truediv to join paths
child_path = path / "content" / "file.txt"

# os.fspath()
with open(path, "r") as f:
    # ...</code></pre>

        <p><code>__hash__</code> method creates a md5 hash of the path (1-way hash)</p>
        <p><code>id</code> encodes the path to a string, which can be decoded.</p>

        <p><strong>Uncommon</strong></p>

        <ul>
            <li><code>is_symlink</code> - whether the path is a symlink</li>
        </ul>

        <details>
            <summary>What is a symlink?</summary>
            <p>A <em>symlink</em> (symbolic link) is like a shortcut or alias to another file or folder.</p>
            <p>Think of it like a sticky note that says "the real file is over there →". When you open a symlink, your computer automatically follows it to the real file.</p>
            <p>You might have a symlink at <code>~/Desktop/project</code> that points to <code>/Users/me/Documents/work/important-project</code>. Opening either path opens the same folder.</p>
            <p>Sometimes you need to know if you're looking at the real file or just a shortcut. The <code>is_symlink</code> property tells you this. The <code>stat</code> and <code>lstat</code> properties behave differently with symlinks (see below).</p>
        </details>

        <ul>
            <li><code>stat</code> - stat information for the path</li>
            <li><code>lstat</code> - lstat information for the path</li>
        </ul>

        <details>
            <summary><code>stat</code> and <code>lstat</code></summary>
            <p><code>stat</code> gives you detailed information about a file: its size, when it was created, when it was last modified, who owns it, and its permissions.</p>

<pre><code class="language-python">info = path.stat
print(info.st_size)    # File size in bytes
print(info.st_mtime)   # Last modified time (Unix timestamp)
print(info.st_ctime)   # Creation time (Unix timestamp)
print(info.st_mode)    # Permissions (octal)
print(info.st_uid)     # Owner ID
print(info.st_gid)     # Group ID
print(info.st_dev)     # Device ID
print(info.st_ino)     # Inode number
print(info.st_nlink)   # Number of links</code></pre>

            <ul>
                <li><code>stat</code> follows symlinks — gives you info about the <em>target</em> file</li>
                <li><code>lstat</code> doesn't follow symlinks — gives you info about the <em>symlink itself</em></li>
            </ul>

            <p><strong>Example</strong>: If <code>shortcut.txt</code> is a symlink pointing to a 1MB file:</p>
            <ul>
                <li><code>shortcut.stat.st_size</code> → 1,000,000 (size of the target file)</li>
                <li><code>shortcut.lstat.st_size</code> → 50 (size of the symlink itself)</li>
            </ul>
            <p>For regular files (not symlinks), <code>stat</code> and <code>lstat</code> return the same thing.</p>
        </details>

        <ul>
            <li><code>as_dict</code> - get the dict view of the path</li>
        </ul>

<pre><code class="language-python"># iterate over the directory contents
for item in path.iterdir():
    # ...

# find all paths matching a pattern
matching_paths = path.glob("*.txt")

# recursively find all paths matching a pattern
matching_paths = path.rglob("*.txt")

# get the path relative to another path
relative_path = path.relative_to(other_path)

# get the path with a different name (pathlib compatible)
new_path = path.with_name("new_name.txt")
new_path = path.with_stem("new_name")
new_path = path.with_suffix(".md")

# create directory
path.mkdir(parents=True, exist_ok=True)

# create/touch file
path.touch(exist_ok=True)</code></pre>

        <details>
            <summary><code>glob</code> and <code>rglob</code></summary>
            <p><code>glob</code> finds files matching a pattern in a directory.</p>
            <p>Think of it like a search with wildcards:</p>
            <ul>
                <li><code>*</code> matches anything (except path separators)</li>
                <li><code>?</code> matches any single character</li>
                <li><code>[abc]</code> matches any character in the brackets</li>
            </ul>

<pre><code class="language-python">folder = SKPath("myproject/data")

# Find all .txt files in the data folder
for file in folder.glob("*.txt"):
    print(file.name)

# Find all files starting with "report"
for file in folder.glob("report*"):
    print(file.name)</code></pre>

            <p><code>rglob</code> does the same thing, but <em>recursively</em> — it searches the folder AND all subfolders.</p>

<pre><code class="language-python">folder = SKPath("myproject")

# Find ALL .py files anywhere in the project
for file in folder.rglob("*.py"):
    print(file.np)</code></pre>

            <p>The "r" stands for "recursive". Use <code>glob</code> for the current folder only, <code>rglob</code> for everything underneath.</p>
        </details>

        <details>
            <summary><code>relative_to</code></summary>
            <p><code>relative_to</code> gives you the path from one location to another.</p>
            <p>Imagine you're in <code>/Users/me/projects</code> and want to describe how to get to <code>/Users/me/projects/app/src/main.py</code>. The relative path would be <code>app/src/main.py</code>.</p>

<pre><code class="language-python">base = SKPath("/Users/me/projects")
file = SKPath("/Users/me/projects/app/src/main.py")

relative = file.relative_to(base)
print(relative.ap)  # "app/src/main.py"</code></pre>

            <ul>
                <li>Display shorter, cleaner paths</li>
                <li>Create portable paths that work on different machines</li>
                <li>Find the "distance" between two paths</li>
            </ul>

            <p><strong>NOTE</strong>: The file must actually be inside the base path. If you try <code>file.relative_to(unrelated_folder)</code>, it raises a <code>ValueError</code>.</p>
        </details>

        <details>
            <summary><code>mkdir</code> and <code>touch</code></summary>
            <p><code>mkdir</code> creates a directory (folder).</p>

<pre><code class="language-python">folder = SKPath("myproject/new_folder")
folder.mkdir()  # Creates the folder</code></pre>

            <ul>
                <li><code>parents=True</code> — also creates parent folders if they don't exist</li>
                <li><code>exist_ok=True</code> — don't raise an error if folder already exists</li>
            </ul>

<pre><code class="language-python"># Create nested folders, don't fail if they exist
deep_folder = SKPath("myproject/a/b/c/d")
deep_folder.mkdir(parents=True, exist_ok=True)</code></pre>

            <p><code>touch</code> creates an empty file, or updates its "last modified" time if it exists.</p>

<pre><code class="language-python">file = SKPath("myproject/new_file.txt")
file.touch()  # Creates empty file (or updates timestamp)</code></pre>

            <p>The name "touch" comes from the idea of "touching" a file to update its timestamp, like leaving fingerprints showing you were there.</p>
        </details>
    </details>

    <h3>Root Detection</h3>

    <p><code>SKPath</code> objects attempt to automatically detect your project root and use it to normalize paths.</p>

    <ul>
        <li>Gets rid of issues where 2 people have the same project in different locations</li>
        <li>Gets rid of cross-platform file path issues, as the project itself won't change just because of a different operating system.</li>
    </ul>

    <p>If the file path given is outside of the project root, <code>SKPath.np</code> will be an empty string <code>""</code>. However, all <code>SKPaths</code> will still have their absolute path, <code>SKPath.ap</code>.</p>

    <ol>
        <li>Uses custom root if set via <code>set_custom_root()</code></li>
        <li>Uses <code>setup.sk</code> file if found walking up directories</li>
        <li>Uses standard detection (see below)</li>
    </ol>

    <p><strong>Definitive Indicators</strong></p>
    <ul>
        <li><code>setup.sk</code></li>
        <li><code>setup.py</code></li>
        <li><code>setup.cfg</code></li>
        <li><code>pyproject.toml</code></li>
    </ul>

    <p><strong>Strong Indicators</strong></p>
    <ul>
        <li><code>.gitignore</code></li>
        <li>License: <code>LICENSE</code>, <code>LICENSE.txt</code>, <code>license</code>, ...</li>
        <li>README: <code>README</code>, <code>README.md</code>, <code>readme.txt</code>, ...</li>
        <li>Requirements: <code>requirements.txt</code>, <code>requirements.pip</code>, ...</li>
    </ul>

    <h4>Set Project Root</h4>

    <p>You have a couple of ways to manually set the project root.</p>

    <p><strong>Functions</strong></p>
    <ul>
        <li><code>set_custom_root(path)</code> - set the project root to a custom path instead of automatically detecting it</li>
        <li><code>clear_custom_root()</code> - clear the custom project root</li>
        <li><code>get_custom_root()</code> - get the custom project root</li>
    </ul>

<pre><code class="language-python">from suitkaise import skpath

skpath.set_custom_root("Documents/projects/myproject")

current_root = skpath.get_custom_root()

skpath.clear_custom_root()</code></pre>

    <p><code>CustomRoot</code> Context Manager</p>

<pre><code class="language-python">from suitkaise import skpath

with skpath.CustomRoot("Documents/projects/myproject"):
    # normalizes to given custom root
    path = SKPath("feature1/file.txt")</code></pre>

    <h3>Creating an SKPath from an ID</h3>

<pre><code class="language-python">from suitkaise import skpath

id = # the path's id from a previous operation

path = SKPath(id)</code></pre>

    <h3><code>AnyPath</code> Type</h3>

    <p>The <code>AnyPath</code> type is a union of <code>str</code>, <code>Path</code>, and <code>SKPath</code>. You can use this type to maintain clear code and type safety.</p>

    <h2><code>@autopath</code> Decorator</h2>

    <p>Automatically converts paths to the types that a function expects.</p>
    
    <ul>
        <li>Paths get normalized through <code>SKPath</code> first</li>
        <li>Converts before passing, avoiding <code>TypeErrors</code></li>
        <li>Works with iterables</li>
        <li><code>SKPath</code>, <code>Path</code>, and <code>str</code> can be used interchangeably</li>
    </ul>

<pre><code class="language-python">from suitkaise.skpath import autopath, AnyPath, SKPath

# automatically convert Paths and strings to SKPaths
@autopath()
def path_pvp(path1: AnyPath, path2: AnyPath):
    # guaranteed to work now - path.id is a property of SKPath
    id1 = path1.id
    id2 = path2.id

    return id1 > id2

# also works with iterables of valid types
@autopath()
def path_royale(paths: list[AnyPath]):
    # guaranteed to work now - path.id is a property of SKPath
    ids = [path.id for path in paths]

    winning_path = SKPath(sorted(ids)[-1])
    return winning_path</code></pre>

<pre><code class="language-python"># automatically convert SKPaths and strings to Paths
@autopath()
def i_like_pathlib(pathlib_path: Path):
    # if SKPaths or strings are passed in, they are converted to Path objects
    return pathlib_path.name  # use standard Path methods</code></pre>

<pre><code class="language-python"># convert SKPaths and Paths to strings
@autopath()
def i_like_strings(string_path: str):

    # All inputs are normalized: "./data\\file.txt" → "/abs/path/data/file.txt"

    return string_path.upper()  # it's a regular string now</code></pre>

    <h3><code>only</code></h3>

    <p>Tells <code>@autopath</code> to only focus on given parameters.</p>
    
    <p>Use this for performance when you have <code>str</code> or <code>list[str]</code> parameters that aren't actually file paths.</p>
    
    <p>When not using <code>only</code>, all parameters accepting <code>SKPath</code>, <code>Path</code>, or <code>str</code> will be normalized and converted.</p>
    
    <p>When using <code>only</code>, ONLY the parameters specified will do this.</p>

<pre><code class="language-python">from suitkaise.skpath import autopath

@autopath(only="file_path")
def process_with_data(file_path: str, names: list[str], ids: list[str]):

    # Only file_path is normalized
    # names and ids are passed through unchanged (much faster!)
    return file_path</code></pre>

<pre><code class="language-python"># Multiple parameters
@autopath(only=["input_path", "output_path"])
def copy_file(input_path: str, output_path: str, metadata: list[str]):

    # input_path and output_path are normalized
    # metadata is left unchanged
    ...</code></pre>

    <h3><code>use_caller</code></h3>

    <p>If <code>use_caller</code> is <code>True</code>, parameters that accept <code>SKPath</code> or <code>Path</code> will use the caller's file path if no value was provided.</p>
    <p>This occurs before the parameter's default value is used.</p>

<pre><code class="language-python">from suitkaise.skpath import autopath, AnyPath

@autopath(use_caller=True)
def process_file(path: AnyPath):
    # path will never be None because of use_caller
    # all paths will be converted to SKPaths

# uses file that called this function
process_file() 

# uses given file and converts to SKPath
process_file("myproject/feature1/file.txt")</code></pre>

<pre><code class="language-python">from suitkaise.skpath import autopath, AnyPath

@autopath() # use_caller=False
def process_file(path: AnyPath):
    # path could be None if no value was provided

# path will be None
process_file() 

# uses given file and converts to SKPath
process_file("myproject/feature1/file.txt")</code></pre>

    <h3><code>debug</code></h3>

    <p>If <code>debug</code> is <code>True</code>, <code>@autopath</code> will output a message when a conversion is made or a path string is normalized.</p>

<pre><code class="language-python">from suitkaise.skpath import autopath, AnyPath

@autopath(debug=True)
def process_file(path: AnyPath):
    return path.id</code></pre>

    <p>Output when a string got converted to a SKPath: <code>"@autopath: Converted path: str → SKPath"</code></p>
    <p>Output when a string was normalized: <code>"@autopath: Normalized path: './file.txt' → '/abs/path/file.txt'"</code></p>

    <h2>Functions</h2>

    <h3><code>get_project_root()</code></h3>

    <p><strong>Arguments:</strong></p>
    <ul>
        <li><code>expected_name</code>: Expected project root name. If provided, the detected root must match this name.</li>
    </ul>

    <p><strong>Returns:</strong></p>
    <ul>
        <li><code>SKPath</code> object pointing to project root.</li>
    </ul>

    <p><strong>Raises:</strong></p>
    <ul>
        <li><code>PathDetectionError</code>: If project root detection fails.</li>
    </ul>

    <p>Get the project root.</p>
    <ol>
        <li>Checks if there is a custom root set.</li>
        <li>If not 1, attempts to automatically detect the project root using the project root indicators. If the expected name is provided and doesn't match, move to step 3.</li>
        <li>If not 1 or 2, raises a <code>PathDetectionError</code>.</li>
    </ol>

<pre><code class="language-python">from suitkaise import skpath

root = skpath.get_project_root()</code></pre>

    <p>You can also get the project root like this:</p>

<pre><code class="language-python">from suitkaise.skpath import SKPath

root = SKPath().root</code></pre>

    <h3><code>get_caller_path()</code></h3>

    <p><strong>Returns:</strong></p>
    <ul>
        <li><code>SKPath</code> object pointing to the caller's file.</li>
    </ul>

    <p><strong>Raises:</strong></p>
    <ul>
        <li><code>PathDetectionError</code>: If caller detection fails.</li>
    </ul>

    <p>Get the path of the file that called the current function.</p>

<pre><code class="language-python">from suitkaise import skpath

caller = skpath.get_caller_path()</code></pre>

    <p>You can also get the caller path like this:</p>

<pre><code class="language-python">from suitkaise.skpath import SKPath

caller = SKPath()</code></pre>

    <h3><code>get_module_path()</code></h3>

    <p><strong>Arguments:</strong></p>
    <ul>
        <li><code>obj</code>: Object to inspect, module name string, or module object</li>
    </ul>

    <p><strong>Returns:</strong></p>
    <ul>
        <li><code>SKPath</code> object pointing to the module file, or <code>None</code> if not found</li>
    </ul>

    <p><strong>Raises:</strong></p>
    <ul>
        <li><code>ImportError</code>: If <code>obj</code> is a module name string that cannot be imported</li>
    </ul>

    <p>Get the path of the module that the given object is defined in.</p>

<pre><code class="language-python">from suitkaise import skpath

path = skpath.get_module_path(UnknownObject)</code></pre>

    <h3><code>get_current_dir()</code></h3>

    <p><strong>Returns:</strong></p>
    <ul>
        <li><code>SKPath</code> object pointing to the current directory.</li>
    </ul>

    <p>Get the directory of the current calling file.</p>

<pre><code class="language-python">from suitkaise import skpath

path = skpath.get_current_dir()</code></pre>

    <p>You can also get the current directory like this:</p>

<pre><code class="language-python">from suitkaise.skpath import SKPath

path = SKPath(path="...").parent</code></pre>

    <h3><code>get_cwd()</code></h3>

    <p><strong>Returns:</strong></p>
    <ul>
        <li><code>SKPath</code> object pointing to the current working directory.</li>
    </ul>

    <p>Get the current working directory.</p>

<pre><code class="language-python">from suitkaise import skpath

path = skpath.get_cwd()</code></pre>

    <h3><code>get_id()</code></h3>

    <p><strong>Arguments:</strong></p>
    <ul>
        <li><code>path</code>: Path to generate ID for</li>
    </ul>

    <p><strong>Returns:</strong></p>
    <ul>
        <li>Base64url encoded ID string (reversible - can be used to reconstruct the path)</li>
    </ul>

    <p>Get the reversible ID of a path. The ID can be used to reconstruct the SKPath later.</p>

<pre><code class="language-python">from suitkaise import skpath

path_id = skpath.get_id(path="myproject/feature1/file.txt")

# Later, reconstruct the path from the ID
path = skpath.SKPath(path_id)</code></pre>

    <p>You can also get the ID like this:</p>

<pre><code class="language-python">from suitkaise.skpath import SKPath

path_id = SKPath(path="...").id  # id is a property, not a method</code></pre>

    <h3><code>get_project_paths()</code></h3>

    <p><strong>Arguments:</strong></p>
    <ul>
        <li><code>root</code>: Custom root directory (defaults to current project root)</li>
        <li><code>exclude</code>: Paths to exclude from results.</li>
        <li><code>as_strings</code>: Return string paths instead of <code>SKPath</code> objects (memory efficiency)</li>
        <li><code>use_ignore_files</code>: Respect .*ignore files (default True)</li>
    </ul>

    <p><strong>Returns:</strong></p>
    <ul>
        <li>List of paths in the project (<code>SKPath</code>s or strings based on <code>as_strings</code>)</li>
    </ul>

    <p><strong>Raises:</strong></p>
    <ul>
        <li><code>PathDetectionError</code>: If something goes wrong getting the project root.</li>
    </ul>

    <p>Get all paths in the project as a list. This also can automatically ignore all paths that are in <code>.*ignore</code> files without requiring you to exclude them yourself.</p>

<pre><code class="language-python">from suitkaise import skpath

# get all paths (use_ignore_files=True, auto detected root)
paths = skpath.get_project_paths()


# get all paths as strings
paths = skpath.get_project_paths(as_strings=True)


# exclude some paths (list of AnyPaths)
    unwanted_paths = [
    "this/one/path/i/dont/want", 
    Path("another/path/i/dont/want"),
    SKPath("yet/another/path/i/dont/want"),
    ]
paths = skpath.get_project_paths(exclude=unwanted_paths)

# use a custom root to start from a subdirectory
paths = skpath.get_project_paths(root="myproject/feature1")</code></pre>

    <h3><code>get_project_structure()</code></h3>

    <p><strong>Arguments:</strong></p>
    <ul>
        <li><code>root</code>: Custom root directory (defaults to current project root) (<code>AnyPath</code>)</li>
        <li><code>exclude</code>: Paths to exclude from results. (<code>AnyPath</code> or list of <code>AnyPaths</code>)</li>
        <li><code>use_ignore_files</code>: Respect .*ignore files (default <code>True</code>)</li>
    </ul>

    <p><strong>Returns:</strong></p>
    <ul>
        <li>Nested dictionary representing the project structure.</li>
    </ul>

    <p><strong>Raises:</strong></p>
    <ul>
        <li><code>PathDetectionError</code>: If something goes wrong getting the project root.</li>
    </ul>

    <p>Provides a hierarchical representation of your project structure, in dictionary form.</p>

<pre><code class="language-python">from suitkaise import skpath

structure = skpath.get_project_structure()</code></pre>

<pre><code class="language-python">{
    "myproject": {
        "feature1": {
            "file.txt": {},
            "another_file.txt": {}
        }
    }
}</code></pre>

    <h3><code>get_formatted_project_tree()</code></h3>

    <p><strong>Arguments:</strong></p>
    <ul>
        <li><code>root</code>: Custom root directory (defaults to current project root) (<code>AnyPath</code>)</li>
        <li><code>exclude</code>: Paths to exclude from results. (<code>AnyPath</code> or list of <code>AnyPaths</code>)</li>
        <li><code>use_ignore_files</code>: Respect .*ignore files (default <code>True</code>)</li>
        <li><code>depth</code>: Maximum depth of the tree to format (default 3) (<code>int</code>)</li>
        <li><code>include_files</code>: Include files in the tree (default <code>True</code>)</li>
    </ul>

    <p><strong>Returns:</strong></p>
    <ul>
        <li>String representing the project tree.</li>
    </ul>

    <p><strong>Raises:</strong></p>
    <ul>
        <li><code>PathDetectionError</code>: If something goes wrong getting the project root.</li>
    </ul>

    <p>Returns a readable, formatted string using <code>│</code>, <code>├─</code>, and <code>└─</code> characters to create a tree-like visual hierarchy.</p>

<pre><code class="language-python">from suitkaise import skpath

tree = skpath.get_formatted_project_tree()
print(tree)</code></pre>

<pre><code>root_directory/
├── __pycache__/
│   └── main.cpython-39.pyc
├── docs/
│   ├── api/
│   ├── development/
│   └── user_guide/
└── src/
    ├── __init__.py
    ├── main.py
    └── utils/</code></pre>

</section>
