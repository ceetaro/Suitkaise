<div class="module-bar" data-module="skpath">
    <button class="module-bar-title">suitkaise.skpath</button>
    <nav class="module-bar-nav">
        <a href="#skpath-why" class="module-bar-link active" data-page="skpath-why">why</a>
        <a href="#skpath" class="module-bar-link" data-page="skpath">how to use</a>
        <a href="#skpath-how-it-works" class="module-bar-link" data-page="skpath-how-it-works">how it works</a>
        <a href="#skpath-videos" class="module-bar-link" data-page="skpath-videos">videos</a>
        <a href="#skpath-tests" class="module-bar-link" data-page="skpath-tests">tests</a>
        <a href="#skpath-examples" class="module-bar-link" data-page="skpath-examples">examples</a>
    </nav>
</div>
<section class="module-page why-page">
    <h1>Why <code>skpath</code>?</h1>

    <p>File paths are a pain to work with.</p>

    <p>Sometimes pure hell, even.</p>

    <p>I got gutted the moment I started trying to write cross-platform code. Slashes going the wrong way, paths breaking when my teammate ran the same script, logs full of absolute paths that meant nothing on another machine. Oops.</p>

    <p>Find the project root, resolve the path, make it relative, normalize the slashes, cast to string, pass it in. Over and over.</p>

    <p>So I made <code>skpath</code>.</p>

    <br>

    <h2><code>SKPath</code> paths</h2>

    <p>Every <code>SKPath</code> stores three paths:</p>

    <ul>
        <li><code>ap</code> — absolute path, always forward slashes (<code>/Users/me/project/data/file.txt</code>)</li>
        <li><code>np</code> — normalized path relative to project root (<code>data/file.txt</code>)</li>
        <li><code>platform</code> — absolute path with the correct separators for the current platform</li>
    </ul>

    <p><code>np</code> is the same on every machine, every OS, as long as the project structure is the same.</p>

    <p>This changes everything, and is a huge jump in path standardization.</p>

    <br>

    <h2>What about <code>pathlib</code>?</h2>

    <p><code>pathlib</code> is great. It handles slash differences internally and gives you a nice object to work with.</p>

    <p>But it doesn't know about your project. It doesn't auto-detect the root. It doesn't give you a consistent path that works everywhere. And it doesn't convert types for you.</p>

    <p><code>skpath</code> wraps <code>pathlib</code> and adds project awareness, so you don't have to make it aware yourself.</p>

    <p>It also adds a bunch of cool things like <code>@autopath</code> and <code>AnyPath</code> to help you in your quest to make paths easy.</p>

    <p><code>pathlib.Path</code> handles this internally, but the moment you convert to string (for logging, storing, or passing to a library), you're back to platform-specific slashes.</p>

<pre><code class="language-python">path = Path("config/settings.yaml")
str(path)

# "config/settings.yaml" on Mac, "config\\settings.yaml" on Windows</code></pre>

<br>

<p>Here is a set of problems that <code>skpath</code> solves.</p>

    <details>
        <summary>1. <code>\</code> vs <code>/</code></summary>
        <div class="dropdown-content">

    <p>Windows uses <code>\</code>, everything else uses <code>/</code>.</p>

    <p>You write code on a Mac, push it, and your teammate on Windows gets broken paths.</p>

<pre><code class="language-python"># You write this on Mac
config_path = "config/settings.yaml"

# Works fine on Mac
open(config_path)  # ✓

# Your teammate on Windows logs the resolved path
print(Path(config_path).resolve())

# C:\Users\teammate\project\config\settings.yaml

# Later, that path gets stored or compared somewhere
# Now you have mixed slashes in your system</code></pre>

    <h3>With <code>skpath</code></h3>

<pre><code class="language-python">path = SKPath("config/settings.yaml")

path.ap  # Always forward slashes: /Users/me/project/config/settings.yaml

path.np  # Always forward slashes: config/settings.yaml

path.platform  # platform specific

str(path)  # Always forward slashes (same as ap)</code></pre>

    <p>Need to pass a path to a Windows-specific tool or open a file? Use <code>path.platform</code>. Want to log or store paths consistently? Use <code>path.ap</code> or <code>path.np</code>.</p>

    <p><code>SKPath</code> normalizes to forward slashes everywhere, except for <code>platform</code>.</p>

        </div>
    </details>

    <details>
        <summary>2. Relative paths</summary>
        <div class="dropdown-content">

    <p>Writing out the full path to a file sucks.</p>

    <p>But relative paths are inconsistent and unclear.</p>

    <p>Is the <code>data/file.txt</code> path relative to the root? The cwd? What if there are multiple files of the same name under different <code>/data</code> directories?</p>

    <p>So, you have to do something like this every time.</p>

<pre><code class="language-python">path = Path("data/file.txt")
path = path.resolve()
path = str(path)</code></pre>

    <p>You could do it in one long line if you want, I guess.</p>

<pre><code class="language-python">path = str(Path("data/file.txt").resolve())</code></pre>

    <h3>With <code>skpath</code></h3>

<pre><code class="language-python">path = SKPath("data/file.txt")</code></pre>

    <p>So much cleaner.</p>

    <p><code>SKPaths</code> are awesome because they actually store 3 paths.</p>

    <ul>
        <li>stores absolute path</li>
        <li>also auto detects the project root and stores the path relative to it</li>
        <li>(also stores platform specific separator absolute path)</li>
    </ul>

    <p><code>SKPaths</code> are automatically cross-platform compatible.</p>

    <p>When you work with <code>SKPath</code> objects across machines or even operating systems, as long as the project root is the same, the paths will work the same.</p>

    <p>So now you can just <code>SKPath</code> everything and not have to worry about platform issues, or having to manually relate paths to the root.</p>

        </div>
    </details>

    <details>
        <summary>3. Project root related issues</summary>
        <div class="dropdown-content">

    <p>Finding the project root recursively is not standardized at all.</p>

    <p>Also a drag to do.</p>

    <p>Each dev does it slightly differently, and there are inconsistencies.</p>

    <p>You end up having to copy paste something like this every time:</p>

<pre><code class="language-python">def find_project_root():
    current = Path(__file__).resolve().parent
    while current != current.parent:
        if (current / "pyproject.toml").exists():
            return current
        if (current / ".git").exists():
            return current
        current = current.parent
    raise RuntimeError("Could not find project root")

PROJECT_ROOT = find_project_root()</code></pre>

    <p>Which is cloudy and relies on exact indicators.</p>

    <h3>With <code>skpath</code> - <em>1 line</em> (2 different ways)</h3>

<pre><code class="language-python">PROJECT_ROOT = get_project_root()</code></pre>

<pre><code class="language-python">PROJECT_ROOT = SKPath().root</code></pre>

    <p>With <code>skpath</code> you can also use different roots quickly and easily.</p>

    <ul>
        <li>you can add a <code>setup.sk</code> file to your project root to guarantee detection (it will look for things like <code>setup.py</code> even if you don't do this)</li>
        <li>you can use <code>set_custom_root</code> to set a custom root that all <code>SKPath</code> objects will use</li>
        <li>you can use the <code>CustomRoot</code> context manager to temporarily set a custom root for a code block for things like testing</li>
    </ul>

    <p>Note that <code>SKPaths</code> are created with the project root they were given, so either use a custom root or don't.</p>

        </div>
    </details>

    <details>
        <summary>4. Figuring out if you need to use a <code>Path</code> or a <code>str</code></summary>
        <div class="dropdown-content">

    <p>Even if you are in an IDE/code editor, figuring out what type of path you need to use for what function across a whole project base is tedious and annoying.</p>

    <p>You have to make everyone use either <code>Path</code> or <code>str</code>, or let everyone code how they want and then hover over every function using paths to see the expected types.</p>

    <h3><code>@autopath</code> does this for you.</h3>

<pre><code class="language-python">from suitkaise.skpath import autopath

@autopath()
def function_that_uses_strs(path: str, ...):

    # changes all Paths to strings for you before passing them in


@autopath()
def function_that_uses_paths(path: Path, ...):

    # changes all strings to Paths for you before passing them in</code></pre>

    <p>All you have to do is slap <code>@autopath()</code> on the function and it will automatically convert the paths to the types that you expect, and automatically normalize them as well.</p>

    <p>There is also another way to do this: the <code>AnyPath</code> type.</p>

    <p><code>AnyPath</code> is a union of <code>str</code>, <code>Path</code>, and <code>SKPath</code>.</p>

    <p>This allows you to quickly update your code to use the superior <code>SKPath</code> type, while not breaking previous code.</p>

<pre><code class="language-python">from suitkaise.skpath import AnyPath

def function_that_uses_any_paths(path: AnyPath, ...):

    # allows you to accept all 3 path types 
    # without having to create unions every time</code></pre>

    <p>And when you combine them...</p>

<pre><code class="language-python">from suitkaise.skpath import autopath, AnyPath

@autopath()
def function_that_uses_any_paths(path: AnyPath, ...):

    # automatically converts strs and Paths to SKPaths for you
    # gives you access to the more awesome SKPath quickly</code></pre>

    <p>I do a lot of solo coding, and even I was having trouble standardizing path code! When working in a team, don't even get me started.</p>

    <p>I think this is a game changer.</p>

        </div>
    </details>

    <details>
        <summary>5. Comparing paths</summary>
        <div class="dropdown-content">

    <p>Say you're writing a script that processes files and saves which ones are done to a log file, so you can skip them on future runs.</p>

<pre><code class="language-python">from pathlib import Path
import json

LOG_FILE = "processed_files.json"

def load_processed():
    if Path(LOG_FILE).exists():
        return set(json.load(open(LOG_FILE)))
    return set()

def save_processed(processed):
    json.dump(list(processed), open(LOG_FILE, "w"))

def process_file(path, processed):
    path_str = str(Path(path).resolve())
    if path_str in processed:
        print(f"Skipping {path}, already processed")
        return
    
    # ... do the actual processing ...
    
    processed.add(path_str)
    save_processed(processed)</code></pre>

    <br>

    <p>Murphy runs the script on his Mac:</p>

<pre><code class="language-python">processed = load_processed()
process_file("data/report.csv", processed)</code></pre>

    <p>The log file now contains:</p>

<pre><code class="language-json">["/Users/murphy/projects/myapp/data/report.csv"]</code></pre>

    <br>

    <p>Gurphy pulls the latest changes and runs the same script on his Windows machine:</p>

<pre><code class="language-python">processed = load_processed()
process_file("data/report.csv", processed)</code></pre>

    <p>His resolved path is <code>C:\Users\gurphy\projects\myapp\data\report.csv</code>, which doesn't match Murphy's path in the log.</p>

    <p>The same file gets processed twice because absolute paths don't match across machines or operating systems.</p>

    <p>You could try to fix this by storing paths relative to the project root:</p>

<pre><code class="language-python">def process_file(path, processed):
    path_resolved = Path(path).resolve()
    path_relative = str(path_resolved.relative_to(PROJECT_ROOT))
    if path_relative in processed:
        # ...</code></pre>

    <p>But now you need to find <code>PROJECT_ROOT</code> consistently and correctly, and fix the separators to be consistent.</p>

    <p>The funniest thing here is that the log file might not even load in the first place because the paths are different.</p>

    <h3>With <code>skpath</code></h3>

<pre><code class="language-python">from suitkaise.skpath import SKPath, autopath
import json

LOG_FILE = "processed_files.json"

@autopath()
def process_file(path: SKPath, processed: set[SKPath]):

    if path.np in processed:
        print(f"Skipping {path.np}, already processed")
        return
    
    # ... do the actual processing ...
    
    processed.add(path.np)
    save_processed(processed)</code></pre>

    <p>The log file now contains:</p>

<pre><code class="language-json">["data/report.csv"]</code></pre>

    <p>Same on Murphy's Mac. Same on Gurphy's Windows PC. Same on someone else's Linux desktop.</p>

        </div>
    </details>

    <details>
        <summary>6. Caller file pathfinding</summary>
        <div class="dropdown-content">

    <p>Sometimes you need to know which file called your function — for logging, for relative path resolution, for debugging.</p>

    <h3>Without <code>skpath</code> - <em>13 lines</em></h3>

<pre><code class="language-python">import inspect # 1
from pathlib import Path # 2

def get_caller_file(): # 3
    stack = inspect.stack() # 4
    
    for frame in stack[1:]: # 5
        filename = frame.filename # 6
        
        # Skip built-in/frozen modules # 7
        if filename.startswith("<"): # 8
            continue # 9
        
        more_filtering_logic() # 10
        
        return Path(filename).resolve() # 11
    
    raise RuntimeError("Could not detect caller") # 12

caller = get_caller_file() # 13</code></pre>

    <p>And this doesn't even handle edge cases like notebook environments, compiled code, or filtering out your own library's frames.</p>

    <h3>With <code>skpath</code> - <em>1 line</em> (3 ways)</h3>

<pre><code class="language-python">caller = SKPath()</code></pre>

<pre><code class="language-python">caller = get_caller_path()</code></pre>

<pre><code class="language-python">@autopath(use_caller=True)  # 1
def function_that_uses_caller_path(path: SKPath):

    # path will be the caller's file path if not explicitly provided</code></pre>

        </div>
    </details>

    <details>
        <summary>7. Using paths as dict keys or in sets</summary>
        <div class="dropdown-content">

    <p>You want to track which files you've seen. Simple, right?</p>

    <h3>Without <code>skpath</code> - <em>8 lines</em></h3>

<pre><code class="language-python">from pathlib import Path # 1

seen = set() # 2

def mark_seen(path: str):

    # Normalize to avoid duplicates
    normalized = Path(path) # 3
    normalized = normalized.resolve() # 4
    normalized = str(normalized) # 5
    seen.add(normalized)

def is_seen(path: str):
    normalized = Path(path) # 6
    normalized = normalized.resolve() # 7
    normalized = str(normalized) # 8
    return normalized in seen</code></pre>

<pre><code class="language-python"># this might mess up and have duplicate paths
len(seen)</code></pre>

    <p>You have to manually normalize every time you add or check. And if you forget once, you get duplicates or missed lookups.</p>

    <h3>With <code>skpath</code></h3>

<pre><code class="language-python">from suitkaise import skpath # 1

seen = set() # 2

@skpath.autopath() # 3
def mark_seen(path: skpath.AnyPath):
    seen.add(path)

@skpath.autopath() # 4
def is_seen(path: skpath.AnyPath):
    return path in seen</code></pre>

<pre><code class="language-python"># no duplicates
len(seen) 
</code></pre>

    <p><code>SKPath</code> objects hash and compare using their normalized path (<code>np</code>), so different representations of the same file are recognized as equal.</p>

    <p>Works in sets, works as dict keys, no extra effort.</p>

        </div>
    </details>

</section>
