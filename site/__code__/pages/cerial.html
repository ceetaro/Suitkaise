<div class="module-bar" data-module="cerial">
    <button class="module-bar-title">suitkaise.cerial</button>
    <nav class="module-bar-nav">
        <a href="#cerial-why" class="module-bar-link" data-page="cerial-why">why</a>
        <a href="#cerial" class="module-bar-link active" data-page="cerial">how to use</a>
        <a href="#cerial-how-it-works" class="module-bar-link" data-page="cerial-how-it-works">how it works</a>
        <a href="#cerial-supported-types" class="module-bar-link" data-page="cerial-supported-types">supported types</a>
        <a href="#cerial-tests" class="module-bar-link" data-page="cerial-tests">tests</a>
        <a href="#cerial-examples" class="module-bar-link" data-page="cerial-examples">examples</a>
        <a href="#cerial-videos" class="module-bar-link" data-page="cerial-videos">videos</a>
        <a href="#cerial-learn" class="module-bar-link" data-page="cerial-learn">learn</a>
    </nav>
</div>
<section class="module-page">
    <h1>How to use <code>cerial</code></h1>

    <p><code>cerial</code> is a serialization engine that handles complex Python objects that <code>pickle</code>, <code>cloudpickle</code>, and <code>dill</code> cannot.</p>

    <p>Meant for internal, cross-process communication, not for external or cross-language serialization.</p><br>

    <h2>API Functions</h2>

    <p>Cerial contains 2 API functions:</p>

    <ul>
        <li><code>cerial.serialize(obj)</code> - serialize an object to bytes</li>
        <li><code>cerial.deserialize(bytes)</code> - deserialize bytes back to an object</li>
    </ul>

<pre><code class="language-python">from suitkaise import cerial

obj = MyClass()
bytes = cerial.serialize(obj)
my_class = cerial.deserialize(bytes)</code></pre>

    <h2>Custom serialization and deserialization</h2>

    <p>Sometimes, <code>cerial</code> might not be able to serialize/deserialize an object correctly.</p>

    <p>If this happens, you can override the default behavior.</p>

    <p>Use <code>__serialize__</code> and <code>__deserialize__</code> methods in your classes to override the default behavior.</p>

    <p>In order for <code>__serialize__</code> to work, data must be reduced down to a <code>dict</code> with only native <code>pickle</code> types. Do not convert to bytes, <code>cerial</code> will do that for you.</p>

    <p><code>__deserialize__</code> needs to take this representation and reconstruct the object.</p>

<pre><code class="language-python">from suitkaise import cerial

class MyClass:
    def __serialize__(self):
        return {"custom": "state"}
    
    @classmethod
    def __deserialize__(cls, state):
        obj = cls.__new__(cls)
        # custom reconstruction logic...
        return obj

bytes = cerial.serialize(MyClass())
my_class = cerial.deserialize(cerial.serialize(MyClass()))

assert my_class.custom == "state"</code></pre>

    <h2>Debugging with <code>debug</code> and <code>verbose</code> modes</h2>

    <p>The <code>serialize</code> and <code>deserialize</code> functions have 2 optional params:</p>

    <ul>
        <li><code>debug</code> - when True, provides detailed error messages showing exactly where serialization/deserialization failed, including path breadcrumbs</li>
        <li><code>verbose</code> - when True, prints color-coded progress as it walks through nested structures</li>
    </ul>

<pre><code class="language-python">data = cerial.serialize(obj, debug=True, verbose=True)

obj = cerial.deserialize(data, debug=True, verbose=True)</code></pre>

    <details>
        <summary><code>verbose</code> output example</summary>
        <p>When <code>verbose=True</code>, cerial prints the path it's taking through your object, color-coded by depth:</p>

<pre><code>  [1] MyService
    [2] MyService → config
      [3] MyService → config → dict
        [4] ... → config → dict → database
        [4] ... → config → dict → api_keys
    [2] MyService → lock
    [2] MyService → logger</code></pre>

        <p>This helps you see exactly which attributes are being serialized.</p>
    </details>

    <details>
        <summary><code>debug</code> error example</summary>
        <p>When something goes wrong and <code>debug=True</code>, cerial shows you where it happened:</p>

<pre><code>======================================================================
DESERIALIZATION ERROR
======================================================================

Error: AttributeError: type object 'MyClass' has no attribute 'from_state'

Path: MyService → config → handler

Type: custom_object
Handler: CustomObjectHandler

IR Data: {'__cerial_type__': 'custom_object', '__module__': 'myapp.handlers'...
======================================================================</code></pre>

        <p>The path tells you exactly where in your nested object the failure occurred.</p>
    </details>

    <h2>Printing a serialized nested <code>dict</code> for a complex object</h2>

    <p>To see what cerial's intermediate representation looks like, serialize the object with <code>cerial</code> and deserialize it with <code>pickle</code>.</p>

    <p>This is useful for understanding how cerial transforms your objects.</p>

<pre><code class="language-python">from suitkaise import cerial
import pickle

class GameState:
    def __init__(self):
        self.player = "Gurphy"
        self.score = 100
        self.items = ["sword", "shield"]

obj = GameState()

# Serialize with cerial
data = cerial.serialize(obj)

# Deserialize with pickle to see the intermediate representation
ir = pickle.loads(data)
print(ir)</code></pre>

    <details>
        <summary>Output (simplified)</summary>

<pre><code class="language-python">{
    '__cerial_type__': 'class_instance',
    '__handler__': 'ClassInstanceHandler',
    '__object_id__': 4371208656,
    'state': {
        '__cerial_type__': 'dict',
        'items': [
            ('module', '__main__'),
            ('qualname', 'GameState'),
            ('strategy', 'dict'),
            ('instance_dict', {
                '__cerial_type__': 'dict',
                'items': [
                    ('player', 'Gurphy'),
                    ('score', 100),
                    ('items', {
                        '__cerial_type__': 'list',
                        'items': ['sword', 'shield']
                    })
                ]
            })
        ]
    }
}</code></pre>

        <p>The representation includes:</p>
        <ul>
            <li><code>__cerial_type__</code> - the type of object (class_instance, dict, list, lock, logger, etc.)</li>
            <li><code>__handler__</code> - which handler serialized/deserializes this object</li>
            <li><code>__object_id__</code> - unique ID for handling circular references</li>
            <li><code>state</code> or <code>items</code> - the actual data</li>
        </ul>

        <p>For objects with locks, loggers, or other unpicklables, you'll see how cerial represents them in a pickle-safe format.</p>

        <p>Simple class instances and functions may look slightly different, as they are not subjected to the entire process.</p>
    </details>

</section>
