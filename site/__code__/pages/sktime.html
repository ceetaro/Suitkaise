<div class="module-bar" data-module="sktime">
    <span class="module-bar-title">suitkaise.sktime</span>
    <nav class="module-bar-nav">
        <a href="#sktime" class="module-bar-link active" data-page="sktime">how to use</a>
        <a href="#sktime-how-it-works" class="module-bar-link" data-page="sktime-how-it-works">how it works</a>
        <a href="#sktime-videos" class="module-bar-link" data-page="sktime-videos">videos</a>
        <a href="#sktime-tests" class="module-bar-link" data-page="sktime-tests">tests</a>
        <a href="#sktime-examples" class="module-bar-link" data-page="sktime-examples">examples</a>
        <a href="#sktime-why" class="module-bar-link" data-page="sktime-why">why</a>
    </nav>
</div>
<section class="module-page">
    <h1>How to use the <code>sktime</code> module</h1>
    
    <h2><code>sktime</code> saves you time.</h2>
    <ul>
        <li>Functionality far beyond basic <code>time.time()</code> calls</li>
        <li>Utilities for both real-world time tracking and code performance timing</li>
        <li>Automatically thread safe</li>
    </ul>

    <h2><code>@timethis</code> - 1 line</h2>
    
    <p>The core feature of <code>sktime</code>.</p>
    <p>Automatically times a function every time it is called.</p>
    <ul>
        <li>1 line, zero setup</li>
        <li>thread safe</li>
        <li>large set of statistics that you can access to monitor performance</li>
    </ul>

<pre><code class="language-python">from suitkaise import sktime

@sktime.timethis() # just this 1 line!
def my_function():
    # Your code here
    pass

# run my_function many times
for i in range(100):
    my_function()

# get stats via the organized stats namespace
mean = my_function.timer.stats.mean
stdev = my_function.timer.stats.stdev

# or get a frozen snapshot
snapshot = my_function.timer.get_stats()</code></pre>

    <p>You can also use the <code>@timethis</code> decorator with a given <code>Timer</code> object.</p>

<pre><code class="language-python">from suitkaise import sktime

# time multiple functions with this one timer
t = sktime.Timer()

def MyClass:
    @sktime.timethis(timer=t)
    def my_function(self):
        # Your code here
        pass

    @sktime.timethis(timer=t)
    def my_function_2(self):
        # Your code here
        pass

# a bunch of MyClass instances are created and their functions are called

# get stats on my_function and my_function_2 execution times
print(t.stats.mean)
print(t.stats.percentile(95))</code></pre>

    <p>You can stack <code>@timethis</code> decorators on the same function.</p>

<pre><code class="language-python">from suitkaise import sktime

t = sktime.Timer()

@sktime.timethis()
@sktime.timethis(timer=t)
def my_function():
    # Your code here
    pass

@sktime.timethis()
@sktime.timethis(timer=t)
def my_function_2():
    # Your code here
    pass

# ...

# get stats on my_function and my_function_2 execution times
print(t.stats.mean)

# get stats only on my_function
print(my_function.timer.stats.mean)

# get stats only on my_function_2
print(my_function_2.timer.stats.mean)</code></pre>

    <hr>

    <h2><code>Timer</code> class</h2>
    
    <p>Class that allows you to easily time parts of your code.</p>
    <p>Powers the <code>@timethis</code> decorator and the <code>TimeThis</code> context manager (below)</p>

    <h3><code>start()</code> and <code>stop()</code></h3>

<pre><code class="language-python">from suitkaise import sktime

timer = sktime.Timer()

timer.start()
sktime.sleep(60)
time_after_sleeping = timer.stop() # returns a float</code></pre>

    <p>When you call <code>start()</code>, the timer starts recording the time.</p>
    <p>When you call <code>stop()</code>, the timer stops recording the time and returns the difference between the stop and start times as a float.</p>
    <p>Note: calling <code>start()</code> while timing is already in progress will issue a <code>UserWarning</code>.</p>

    <p>Timing multiple times over:</p>

<pre><code class="language-python">from suitkaise import sktime

timer = sktime.Timer()

for i in range(100):

    timer.start()
    sktime.sleep(60)
    timer.stop()

# access stats through the stats namespace
mean = timer.stats.mean
std = timer.stats.stdev
p95 = timer.stats.percentile(95)

# or get a frozen snapshot
snapshot = timer.get_stats()</code></pre>

    <h3><code>discard()</code></h3>
    
    <p>Stop timing but do NOT record the measurement. Useful when an error occurs or for warm-up runs.</p>

<pre><code class="language-python">from suitkaise import sktime

timer = sktime.Timer()

timer.start()
try:
    result = risky_operation()
    timer.stop()  # Record successful timing
except Exception:
    timer.discard()  # Stop but don't pollute stats with failed run</code></pre>

    <h3><code>lap()</code></h3>

<pre><code class="language-python">from suitkaise import sktime

timer = sktime.Timer()
timer.start()

for i in range(100):

    my_function()

    # stops and instantly starts a new measurement
    timer.lap()

# 100 measurements recorded
print(timer.stats.mean)</code></pre>

    <h3><code>pause()</code> and <code>resume()</code></h3>

<pre><code class="language-python">from suitkaise import sktime

timer = sktime.Timer()
timer.start()

# Unzip and load a large file
current_file = unzip_and_load_file("Users/joe/Documents/large_file.zip")

# Pause timer while user decides what to do next
timer.pause()

# time user takes to answer won't be counted - we are paused!
user_choice = input(f"Process {current_file} now? (y/n): ")  

# Resume once input is received
timer.resume()

# Process the file
if user_choice.lower().strip() == 'y':
    process_loaded_file()

elapsed = timer.stop()  # Records measurement in statistics
print(f"Total processing time: {elapsed:.2f}s (excluding user input)")</code></pre>

    <h3><code>add_time()</code></h3>
    
    <p>Add a float time to the timer.</p>

<pre><code class="language-python">from suitkaise import sktime

timer = sktime.Timer()
timer.add_time(10.0)
timer.add_time(15.0)

print(timer.stats.mean)  # 12.5</code></pre>

    <h3><code>reset()</code></h3>
    
    <p>Reset the timer back to its initial state as if it was just created.</p>

    <h3>All <code>Timer</code> statistics (via <code>timer.stats</code>)</h3>
    
    <p>All statistics are accessed through the organized <code>stats</code> namespace:</p>
    
    <p><strong>Properties:</strong></p>
    <ul>
        <li><code>timer.stats.num_times</code> - Number of times recorded</li>
        <li><code>timer.stats.most_recent</code> - Most recent time</li>
        <li><code>timer.stats.most_recent_index</code> - Index of most recent time</li>
        <li><code>timer.stats.result</code> - Most recent time (alias)</li>
        <li><code>timer.stats.total_time</code> - Sum of all times</li>
        <li><code>timer.stats.total_time_paused</code> - Total time spent paused</li>
        <li><code>timer.stats.mean</code> - Average of all times</li>
        <li><code>timer.stats.median</code> - Median of all times</li>
        <li><code>timer.stats.min</code> / <code>timer.stats.fastest_time</code> - Minimum time</li>
        <li><code>timer.stats.max</code> / <code>timer.stats.slowest_time</code> - Maximum time</li>
        <li><code>timer.stats.stdev</code> - Standard deviation</li>
        <li><code>timer.stats.variance</code> - Variance</li>
        <li><code>timer.stats.slowest_index</code> - Index of slowest time</li>
        <li><code>timer.stats.fastest_index</code> - Index of fastest time</li>
        <li><code>timer.stats.original_start_time</code> - Original start time of the timer</li>
    </ul>
    
    <p><strong>Methods:</strong></p>
    <ul>
        <li><code>timer.stats.get_time(index)</code> - Get time by standard 0-based index</li>
        <li><code>timer.stats.percentile(percent)</code> - Calculate any percentile (0-100)</li>
    </ul>

<pre><code class="language-python"># to get the real world time passed since the timer started, you can use:

real_world_time = sktime.now() - timer.stats.original_start_time</code></pre>

    <h3><code>get_statistics()</code> / <code>get_stats()</code></h3>
    
    <p>Get a frozen snapshot of all timer statistics. The snapshot won't change even if the timer continues recording.</p>

<pre><code class="language-python">from suitkaise import sktime

timer = sktime.Timer()

# ... record some timings ...

# get a frozen snapshot
snapshot = timer.get_stats()  # or timer.get_statistics()

# access all the same properties
print(snapshot.mean)
print(snapshot.stdev)
print(snapshot.percentile(95))</code></pre>

    <hr>

    <h2><code>TimeThis</code> context manager</h2>
    
    <p>For the cases when the code you want to time is not a function, you can use the <code>TimeThis</code> context manager.</p>
    <p>The context manager automatically starts the timer when the context is entered and stops it when the context is exited.</p>
    <ul>
        <li>cleaner than manually starting and stopping the timer</li>
        <li>error proof</li>
        <li>clear indication of what is being timed</li>
    </ul>

<pre><code class="language-python">from suitkaise import sktime

with sktime.TimeThis() as timer:
    # Your code here
    pass

# get the time that was just recorded (returns the Timer object)
print(timer.stats.most_recent)</code></pre>

    <p>When using it like this, a new timer is created each time.</p>
    <p>If you want to use the same timer every time that code is ran, you can create a timer and pass it to the context manager.</p>

<pre><code class="language-python">from suitkaise import sktime

timer = sktime.Timer()

# uses your "timer" every time
# lets you gather multiple measurements
with sktime.TimeThis(timer=timer):
    # Your code here
    pass

print(timer.stats.mean)</code></pre>

    <hr>

    <h2><code>now()</code> and <code>get_current_time()</code></h2>
    
    <p><code>now()</code> and <code>get_current_time()</code> use <code>time.time()</code>.</p>
    <p>They are simply here so you don't have to import <code>time</code> as well as <code>sktime</code>.</p>

<pre><code class="language-python">from suitkaise import sktime

current_timestamp = sktime.now()</code></pre>

    <hr>

    <h2><code>sleep()</code></h2>
    
    <p><code>sleep()</code> is built off of <code>time.sleep()</code>, but it can optionally return the current time after sleeping in the same line.</p>
    <p><strong>Arguments:</strong></p>
    <ul>
        <li><code>seconds</code>: Number of seconds to sleep (can be fractional)</li>
    </ul>
    <p><strong>Returns:</strong></p>
    <ul>
        <li>Current time after sleeping as a float</li>
    </ul>

    <p>without <code>sktime</code>: <strong><em>3 lines</em></strong></p>

<pre><code class="language-python">import time # 1

time.sleep(1) # 2

current_timestamp = time.time() # 3</code></pre>

    <p>with <code>sktime</code>: <strong><em>2 lines</em></strong></p>

<pre><code class="language-python">from suitkaise import sktime # 1

current_timestamp = sktime.sleep(1) # 2</code></pre>

    <hr>

    <h2><code>elapsed()</code></h2>
    
    <p>Easy way to calculate elapsed time.</p>
    <p><strong>Arguments:</strong></p>
    <ul>
        <li><code>time1</code>: First timestamp</li>
        <li><code>time2</code>: Second timestamp (defaults to current time if <code>None</code>)</li>
    </ul>
    <p><strong>Returns:</strong></p>
    <ul>
        <li>Elapsed time as a float</li>
    </ul>

    <p>without <code>sktime</code>: <strong><em>8 lines</em></strong></p>

<pre><code class="language-python">import time # 1
from math import fabs # 2

start_time = time.time() # 3
# ... do work ...
end_time = time.time() # 4

try: # 5

    # have to use absolute value to avoid negative values when order is wrong
    elapsed = fabs(end_time - start_time) # 6

except TypeError: # 7
    print("Error: start_time and end_time must be of type float") # 8</code></pre>

    <p>with <code>sktime</code>: <strong><em>3-4 lines</em></strong></p>
    <ul>
        <li>if giving two times, order doesn't matter</li>
        <li>if giving one time, current time is used as end time automatically</li>
        <li>error handling for type mismatches</li>
    </ul>

<pre><code class="language-python">from suitkaise import sktime # 1

start_time = sktime.now() # 2

# ... do work ...

# current time is end time automatically
time_to_complete = sktime.elapsed(start_time) # 3</code></pre>

<pre><code class="language-python"># or give 2 times
from suitkaise import sktime # 1

start_time = sktime.now() # 2
end_time = sktime.now() + 60 # 3

time_to_complete = sktime.elapsed(start_time, end_time) # 4</code></pre>

    <hr>

    <h2><code>Yawn</code> class</h2>
    
    <p>Sleep controller that sleeps after a specified number of "yawns".</p>
    <p>Unlike <code>Circuit</code> (which breaks and stops), <code>Yawn</code> sleeps and continues. The counter auto-resets after each sleep.</p>
    <p><strong>Arguments:</strong></p>
    <ul>
        <li><code>sleep_duration</code>: How long to sleep when threshold is reached (<code>float</code>)</li>
        <li><code>yawn_threshold</code>: Number of yawns before sleeping (<code>int</code>)</li>
        <li><code>log_sleep</code>: Whether to print when sleep occurs (<code>bool</code>)</li>
    </ul>

<pre><code class="language-python">from suitkaise import sktime

# create the controller
y = sktime.Yawn(sleep_duration=3, yawn_threshold=5)


while something:
    if something_went_wrong():
        y.yawn()  # After 5 yawns, sleeps for 3 seconds, then auto-resets
    else:
        do_work() # run your program code</code></pre>

    <p>If something goes wrong 5 times, the program will sleep for 3 seconds, then continue (counter resets).</p>

</section>
