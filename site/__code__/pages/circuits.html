<div class="module-bar" data-module="circuits">
    <button class="module-bar-title">suitkaise.circuits</button>
    <nav class="module-bar-nav">
        <a href="#circuits-why" class="module-bar-link" data-page="circuits-why">why</a>
        <a href="#circuits-quick-start" class="module-bar-link" data-page="circuits-quick-start">quick start</a>
        <a href="#circuits" class="module-bar-link active" data-page="circuits">how to use</a>
        <a href="#circuits-how-it-works" class="module-bar-link" data-page="circuits-how-it-works">how it works</a>
        <a href="#circuits-examples" class="module-bar-link" data-page="circuits-examples">examples</a>
        <a href="#circuits-videos" class="module-bar-link" data-page="circuits-videos">videos</a>
        <a href="#circuits-tests" class="module-bar-link" data-page="circuits-tests">tests</a>
        <a href="#circuits-learn" class="module-bar-link" data-page="circuits-learn">learn</a>
    </nav>
</div>
<section class="module-page">
    <h1>How to use <code>circuits</code></h1>
    <p><code>circuits</code> provides two circuit breaker classes for managing failures and rate limiting in your code.</p>
    <ul>
        <li><code>Circuit</code> — auto-resets after sleeping. Use for rate limiting and temporary failures.</li>
        <li><code>BreakingCircuit</code> — stays broken until you manually reset. Use for failure thresholds and coordinated shutdown.</li>
    </ul>
    <h2>Importing</h2>
    <pre><code class="language-python">from suitkaise import Circuit, BreakingCircuit</code></pre>
    <h2><code>Circuit</code></h2>
    <h3>Creating a Circuit</h3>
    <pre><code class="language-python">circuit = Circuit(
    num_shorts_to_trip=5,           # shorts before the circuit trips
    sleep_time_after_trip=1.0,      # seconds to sleep on trip
    backoff_factor=1.0,             # multiply sleep time after each trip (1.0 = no backoff)
    max_sleep_time=30.0,            # maximum sleep time cap
    jitter=0.0                      # randomness added to sleep (0.0 to 1.0)
)</code></pre>
    <p>All parameters except <code>num_shorts_to_trip</code> and <code>sleep_time_after_trip</code> have defaults.</p>
    <p>Minimal:</p>
    <pre><code class="language-python">circuit = Circuit(num_shorts_to_trip=5, sleep_time_after_trip=1.0)</code></pre>
    <h3><code>short(custom_sleep=None)</code></h3>
    <p>Record a failure. After <code>num_shorts_to_trip</code> failures, the circuit trips: sleeps, then resets the counter automatically.</p>
    <pre><code class="language-python">try:
    result = call_service()
except ServiceError:
    circuit.short()  # count the failure</code></pre>
    <p>Returns <code>True</code> if the circuit tripped and slept, <code>False</code> otherwise.</p>
    <p>Pass <code>custom_sleep</code> to override the sleep duration for this specific trip:</p>
    <pre><code class="language-python">except RateLimitError as e:
    circuit.short(custom_sleep=e.retry_after)  # use the server&#x27;s suggested wait time</code></pre>
    <h3><code>trip(custom_sleep=None)</code></h3>
    <p>Immediately trip the circuit, bypassing the counter. Use for catastrophic failures where you don&#x27;t want to wait for the threshold.</p>
    <pre><code class="language-python">try:
    result = call_service()
except CriticalError:
    circuit.trip()  # skip the counter, trip immediately
except MinorError:
    circuit.short()  # count normally</code></pre>
    <p>Always returns <code>True</code> (always sleeps).</p>
    <h3><code>reset_backoff()</code></h3>
    <p>Reset the sleep duration back to the original <code>sleep_time_after_trip</code>. Use after a successful operation to prevent the backoff from snowballing.</p>
    <pre><code class="language-python">result = call_service()  # success!
circuit.reset_backoff()   # back to original sleep time</code></pre>
    <h3>Properties</h3>
    <pre><code class="language-python">circuit.num_shorts_to_trip   # int — threshold before trip (read-only)
circuit.times_shorted        # int — failures since last trip
circuit.total_trips          # int — lifetime trip count
circuit.current_sleep_time   # float — current sleep duration (after backoff)</code></pre>
    <h3>Exponential Backoff</h3>
    <p>Set <code>backoff_factor</code> &gt; 1.0 to increase sleep time after each trip:</p>
    <pre><code class="language-python">circuit = Circuit(
    num_shorts_to_trip=5,
    sleep_time_after_trip=1.0,
    backoff_factor=2.0,
    max_sleep_time=30.0
)

# Trip 1: sleeps 1.0s
# Trip 2: sleeps 2.0s
# Trip 3: sleeps 4.0s
# Trip 4: sleeps 8.0s
# Trip 5: sleeps 16.0s
# Trip 6+: sleeps 30.0s (capped)</code></pre>
    <h3>Jitter</h3>
    <p>Set <code>jitter</code> to add randomness and prevent thundering herd:</p>
    <pre><code class="language-python">circuit = Circuit(
    num_shorts_to_trip=5,
    sleep_time_after_trip=5.0,
    jitter=0.2  # ±20% randomness
)

# sleep durations will be between 4.0s and 6.0s</code></pre>
    <p>The <code>jitter</code> parameter is a decimal (0.2), not a percentage (20). Values are clamped to <code>[0.0, 1.0]</code>.</p>
    <hr>
    <h2><code>BreakingCircuit</code></h2>
    <h3>Creating a BreakingCircuit</h3>
    <pre><code class="language-python">breaker = BreakingCircuit(
    num_shorts_to_trip=3,           # shorts before the circuit breaks
    sleep_time_after_trip=1.0,      # seconds to sleep when breaking
    backoff_factor=1.0,             # multiply sleep time after each reset
    max_sleep_time=30.0,            # maximum sleep time cap
    jitter=0.0                      # randomness added to sleep (0.0 to 1.0)
)</code></pre>
    <p>Minimal:</p>
    <pre><code class="language-python">breaker = BreakingCircuit(num_shorts_to_trip=3, sleep_time_after_trip=1.0)</code></pre>
    <h3><code>short(custom_sleep=None)</code></h3>
    <p>Record a failure. After <code>num_shorts_to_trip</code> failures, the circuit breaks: sleeps, then stays broken.</p>
    <pre><code class="language-python">while not breaker.broken:
    try:
        result = risky_operation()
        break  # success
    except OperationError:
        breaker.short()  # count the failure

if breaker.broken:
    handle_failure()</code></pre>
    <p>Returns <code>None</code>.</p>
    <h3><code>trip(custom_sleep=None)</code></h3>
    <p>Immediately break the circuit, bypassing the counter.</p>
    <pre><code class="language-python">try:
    result = call_service()
except CriticalError:
    breaker.trip()  # immediately broken</code></pre>
    <p>Returns <code>None</code>.</p>
    <h3><code>reset()</code></h3>
    <p>Reset the circuit to operational state. Clears the broken flag, resets the short counter, and applies exponential backoff to the sleep time.</p>
    <pre><code class="language-python">if breaker.broken:
    # decide what to do...
    handle_failure()
    breaker.reset()  # ready to use again</code></pre>
    <p>Note: <code>reset()</code> applies the backoff factor. This means the next time the circuit breaks, it will sleep longer.</p>
    <h3><code>reset_backoff()</code></h3>
    <p>Reset the sleep duration back to the original <code>sleep_time_after_trip</code> without changing the broken state.</p>
    <pre><code class="language-python">breaker.reset()           # reset broken state (applies backoff)
breaker.reset_backoff()   # also reset sleep time to original</code></pre>
    <h3>Properties</h3>
    <pre><code class="language-python">breaker.num_shorts_to_trip   # int — threshold before break (read-only)
breaker.broken               # bool — whether circuit is currently broken
breaker.times_shorted        # int — failures since last trip/reset
breaker.total_trips          # int — lifetime trip count
breaker.current_sleep_time   # float — current sleep duration (after backoff)</code></pre>
    <h3>Exponential Backoff</h3>
    <p>Unlike <code>Circuit</code> (which applies backoff on trip), <code>BreakingCircuit</code> applies backoff on <code>reset()</code>. This means the sleep time increases each time you reset and the circuit breaks again.</p>
    <pre><code class="language-python">breaker = BreakingCircuit(
    num_shorts_to_trip=3,
    sleep_time_after_trip=1.0,
    backoff_factor=2.0,
    max_sleep_time=30.0
)

# Break 1: sleeps 1.0s
# reset() → next sleep will be 2.0s
# Break 2: sleeps 2.0s
# reset() → next sleep will be 4.0s
# Break 3: sleeps 4.0s
# ...</code></pre>
    <hr>
    <h2>Thread Safety</h2>
    <p>Both <code>Circuit</code> and <code>BreakingCircuit</code> are thread-safe. All state access is protected by <code>threading.RLock</code>.</p>
    <pre><code class="language-python">import threading
from suitkaise import Circuit

circuit = Circuit(num_shorts_to_trip=5, sleep_time_after_trip=1.0)

def worker():
    for _ in range(100):
        try:
            process_item()
        except ItemError:
            circuit.short()  # safe from multiple threads

threads = [threading.Thread(target=worker) for _ in range(4)]
for t in threads:
    t.start()
for t in threads:
    t.join()</code></pre>
    <p>The sleep operation happens outside the lock, so other threads aren&#x27;t blocked while one thread sleeps.</p>
    <hr>
    <h2>Async Support</h2>
    <p>Both classes support async usage via <code>.asynced()</code>. The async versions use <code>asyncio.sleep()</code> instead of blocking <code>time.sleep()</code>.</p>
    <pre><code class="language-python"># sync
circuit.short()

# async
await circuit.short.asynced()()

# sync
circuit.trip()

# async
await circuit.trip.asynced()()</code></pre>
    <p>Methods that don&#x27;t sleep (<code>reset()</code>, <code>reset_backoff()</code>, property access) don&#x27;t need async versions.</p>
    <pre><code class="language-python">import asyncio
from suitkaise import Circuit

circuit = Circuit(
    num_shorts_to_trip=5,
    sleep_time_after_trip=2.0,
    backoff_factor=2.0,
    jitter=0.2
)

async def fetch(session, url):
    try:
        async with session.get(url) as response:
            if response.status == 429:
                await circuit.short.asynced()()
                return None
            return await response.json()
    except aiohttp.ClientError:
        await circuit.short.asynced()()
        return None</code></pre>
    <hr>
    <h2><code>Share</code> Integration</h2>
    <p>Both circuit classes include <code>_shared_meta</code> for integration with <code>suitkaise.processing.Share</code>. This enables cross-process circuit breaking.</p>
    <pre><code class="language-python">from suitkaise.processing import Share, Pool, Skprocess
from suitkaise import BreakingCircuit

share = Share()
share.circuit = BreakingCircuit(num_shorts_to_trip=3, sleep_time_after_trip=1.0)

class Worker(Skprocess):
    def __init__(self, share):
        self.share = share

    def __run__(self):
        if self.share.circuit.broken:
            self.stop()
            return

        try:
            result = process_item()
        except FatalError:
            self.share.circuit.short()

pool = Pool(workers=4)
pool.map(Worker, [share] * 4)</code></pre>
    <p>When any process trips the circuit, all other processes see <code>share.circuit.broken == True</code> on their next check. This gives you cross-process coordinated failure handling with zero infrastructure.</p>
    <hr>
    <h2>Choosing Between <code>Circuit</code> and <code>BreakingCircuit</code></h2>
    <p>| Use Case | Class | Why | |----------|-------|-----| | Rate limiting API calls | <code>Circuit</code> | Auto-resets after cooldown, keeps processing | | Retry with backoff | <code>Circuit</code> | Sleeps and continues automatically | | Stop after too many failures | <code>BreakingCircuit</code> | Stays broken, you decide what to do | | Coordinated worker shutdown | <code>BreakingCircuit</code> | One worker breaks it, all see it | | Graceful degradation | Both | <code>Circuit</code> for primary, <code>BreakingCircuit</code> for fallback |</p>
    <hr>
    <h2>Error Handling</h2>
    <p>Circuits don&#x27;t raise exceptions themselves. They sleep (Circuit) or set a flag (BreakingCircuit). You handle the logic:</p>
    <pre><code class="language-python"># Circuit: check the return value of short()
tripped = circuit.short()
if tripped:
    print(&quot;Circuit tripped, just paused&quot;)

# BreakingCircuit: check the broken property
breaker.short()
if breaker.broken:
    print(&quot;Circuit broken, stopping&quot;)</code></pre>
</section>
