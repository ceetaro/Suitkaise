<div class="module-bar" data-module="circuits">
    <button class="module-bar-title">suitkaise.circuits</button>
    <nav class="module-bar-nav">
        <a href="#circuits-why" class="module-bar-link" data-page="circuits-why">why</a>
        <a href="#circuits-quick-start" class="module-bar-link" data-page="circuits-quick-start">quick start</a>
        <a href="#circuits" class="module-bar-link active" data-page="circuits">how to use</a>
        <a href="#circuits-how-it-works" class="module-bar-link" data-page="circuits-how-it-works">how it works</a>
        <a href="#circuits-examples" class="module-bar-link" data-page="circuits-examples">examples</a>
        <a href="#circuits-videos" class="module-bar-link" data-page="circuits-videos">videos</a>
        <a href="#circuits-learn" class="module-bar-link" data-page="circuits-learn">learn</a>
    </nav>
</div>
<section class="module-page">
    <h1>How to use <code><suitkaise-api>circuits</suitkaise-api></code></h1>
    <p><code><suitkaise-api>circuits</suitkaise-api></code> provides two circuit breaker classes for managing failures and rate limiting in your code.</p>
    <ul>
        <li><code><suitkaise-api>Circuit</suitkaise-api></code> — auto-resets after sleeping. Use for rate limiting and temporary failures.</li>
        <li><code><suitkaise-api>BreakingCircuit</suitkaise-api></code> — stays broken until you manually reset. Use for failure thresholds and coordinated shutdown.</li>
    </ul>
    <h2>Importing</h2>
    <pre><code class="language-python">from <suitkaise-api>suitkaise</suitkaise-api> import <suitkaise-api>Circuit</suitkaise-api>, <suitkaise-api>BreakingCircuit</suitkaise-api></code></pre>
    <h2><code><suitkaise-api>Circuit</suitkaise-api></code></h2>
    <h3>Creating a Circuit</h3>
    <pre><code class="language-python"><suitkaise-api>circuit</suitkaise-api> = <suitkaise-api>Circuit(</suitkaise-api>
    num_shorts_to_trip=5,           # shorts before the circuit trips
    sleep_time_after_trip=1.0,      # seconds to sleep on trip
    backoff_factor=1.0,             # multiply sleep time after each trip (1.0 = no backoff)
    max_sleep_time=30.0,            # maximum sleep time cap
    jitter=0.0                      # randomness added to sleep (0.0 to 1.0)
)</code></pre>
    <p>All parameters except <code>num_shorts_to_trip</code> and <code>sleep_time_after_trip</code> have defaults.</p>
    <p>Minimal:</p>
    <pre><code class="language-python"><suitkaise-api>circuit</suitkaise-api> = <suitkaise-api>Circuit(</suitkaise-api>num_shorts_to_trip=5, sleep_time_after_trip=1.0)</code></pre>
    <h3><code><suitkaise-api>short</suitkaise-api>(custom_sleep=None)</code></h3>
    <p>Record a failure. After <code>num_shorts_to_trip</code> failures, the circuit trips: sleeps, then resets the counter automatically.</p>
    <pre><code class="language-python">try:
    result = call_service()
except ServiceError:
    <suitkaise-api>circuit.short()</suitkaise-api>  # count the failure</code></pre>
    <p>Returns</p>
    <p><code>True</code> if the circuit tripped and slept, <code>False</code> otherwise.</p>
    <p>Pass <code>custom_sleep</code> to override the sleep duration for this specific trip:</p>
    <pre><code class="language-python">except RateLimitError as e:
    <suitkaise-api>circuit.short(</suitkaise-api>custom_sleep=e.retry_after)  # use the server&#x27;s suggested wait time</code></pre>
    <h3><code><suitkaise-api>trip</suitkaise-api>(custom_sleep=None)</code></h3>
    <p>Immediately trip the circuit, bypassing the counter. Use for catastrophic failures where you don&#x27;t want to wait for the threshold.</p>
    <pre><code class="language-python">try:
    result = call_service()
except CriticalError:
    <suitkaise-api>circuit.trip()</suitkaise-api>  # skip the counter, trip immediately
except MinorError:
    <suitkaise-api>circuit.short()</suitkaise-api>  # count normally</code></pre>
    <p>Always returns <code>True</code> (always sleeps).</p>
    <h3><code><suitkaise-api>reset_backoff</suitkaise-api>()</code></h3>
    <p>Reset the sleep duration back to the original <code>sleep_time_after_trip</code>. Use after a successful operation to prevent the backoff from snowballing.</p>
    <pre><code class="language-python">result = call_service()  # success!
<suitkaise-api>circuit.reset_backoff()</suitkaise-api>   # back to original sleep time</code></pre>
    <h3>Properties</h3>
    <pre><code class="language-python"><suitkaise-api>circuit.num_shorts_to_trip</suitkaise-api>   # int — threshold before trip (read-only)
<suitkaise-api>circuit.times_shorted</suitkaise-api>        # int — failures since last trip
<suitkaise-api>circuit.total_trips</suitkaise-api>          # int — lifetime trip count
<suitkaise-api>circuit.current_sleep_time</suitkaise-api>   # float — current sleep duration (after backoff)</code></pre>
    <h3>Exponential Backoff</h3>
    <p>Set <code>backoff_factor</code> &gt; 1.0 to increase sleep time after each trip:</p>
    <pre><code class="language-python"><suitkaise-api>circuit</suitkaise-api> = <suitkaise-api>Circuit(</suitkaise-api>
    num_shorts_to_trip=5,
    sleep_time_after_trip=1.0,
    backoff_factor=2.0,
    max_sleep_time=30.0
)

# Trip 1: sleeps 1.0s
# Trip 2: sleeps 2.0s
# Trip 3: sleeps 4.0s
# Trip 4: sleeps 8.0s
# Trip 5: sleeps 16.0s
# Trip 6+: sleeps 30.0s (capped)</code></pre>
    <h3>Jitter</h3>
    <p>Set <code>jitter</code> to add randomness and prevent thundering herd:</p>
    <pre><code class="language-python"><suitkaise-api>circuit</suitkaise-api> = <suitkaise-api>Circuit(</suitkaise-api>
    num_shorts_to_trip=5,
    sleep_time_after_trip=5.0,
    jitter=0.2  # ±20% randomness
)

# sleep durations will be between 4.0s and 6.0s</code></pre>
    <p>The <code>jitter</code> parameter is a decimal (0.2), not a percentage (20). Values are clamped to <code>[0.0, 1.0]</code>.</p>
    <hr>
    <h2><code><suitkaise-api>BreakingCircuit</suitkaise-api></code></h2>
    <h3>Creating a BreakingCircuit</h3>
    <pre><code class="language-python"><suitkaise-api>breaker</suitkaise-api> = <suitkaise-api>BreakingCircuit(</suitkaise-api>
    num_shorts_to_trip=3,           # shorts before the circuit breaks
    sleep_time_after_trip=1.0,      # seconds to sleep when breaking
    backoff_factor=1.0,             # multiply sleep time after each reset
    max_sleep_time=30.0,            # maximum sleep time cap
    jitter=0.0                      # randomness added to sleep (0.0 to 1.0)
)</code></pre>
    <p>Minimal:</p>
    <pre><code class="language-python"><suitkaise-api>breaker</suitkaise-api> = <suitkaise-api>BreakingCircuit(</suitkaise-api>num_shorts_to_trip=3, sleep_time_after_trip=1.0)</code></pre>
    <h3><code><suitkaise-api>short</suitkaise-api>(custom_sleep=None)</code></h3>
    <p>Record a failure. After <code>num_shorts_to_trip</code> failures, the circuit breaks: sleeps, then stays broken.</p>
    <pre><code class="language-python">while not <suitkaise-api>breaker.broken</suitkaise-api>:
    try:
        result = risky_operation()
        break  # success
    except OperationError:
        <suitkaise-api>breaker.short()</suitkaise-api>  # count the failure

if <suitkaise-api>breaker.broken</suitkaise-api>:
    handle_failure()</code></pre>
    <p>Returns</p>
    <p><code>None</code>.</p>
    <h3><code><suitkaise-api>trip</suitkaise-api>(custom_sleep=None)</code></h3>
    <p>Immediately break the circuit, bypassing the counter.</p>
    <pre><code class="language-python">try:
    result = call_service()
except CriticalError:
    <suitkaise-api>breaker.trip()</suitkaise-api>  # immediately broken</code></pre>
    <p>Returns</p>
    <p><code>None</code>.</p>
    <h3><code><suitkaise-api>reset</suitkaise-api>()</code></h3>
    <p>Reset the circuit to operational state. Clears the broken flag, resets the short counter, and applies exponential backoff to the sleep time.</p>
    <pre><code class="language-python">if <suitkaise-api>breaker.broken</suitkaise-api>:
    # decide what to do...
    handle_failure()
    <suitkaise-api>breaker.reset()</suitkaise-api>  # ready to use again</code></pre>
    <p>Note: <code><suitkaise-api>reset</suitkaise-api>()</code> applies the backoff factor. This means the next time the circuit breaks, it will sleep longer.</p>
    <h3><code><suitkaise-api>reset_backoff</suitkaise-api>()</code></h3>
    <p>Reset the sleep duration back to the original <code>sleep_time_after_trip</code> without changing the broken state.</p>
    <pre><code class="language-python"><suitkaise-api>breaker.reset()</suitkaise-api>           # reset broken state (applies backoff)
<suitkaise-api>breaker.reset_backoff()</suitkaise-api>   # also reset sleep time to original</code></pre>
    <h3>Properties</h3>
    <pre><code class="language-python"><suitkaise-api>breaker.num_shorts_to_trip</suitkaise-api>   # int — threshold before break (read-only)
<suitkaise-api>breaker.broken</suitkaise-api>               # bool — whether circuit is currently broken
<suitkaise-api>breaker.times_shorted</suitkaise-api>        # int — failures since last trip/reset
<suitkaise-api>breaker.total_trips</suitkaise-api>          # int — lifetime trip count
<suitkaise-api>breaker.current_sleep_time</suitkaise-api>   # float — current sleep duration (after backoff)</code></pre>
    <h3>Exponential Backoff</h3>
    <p>Unlike <code><suitkaise-api>Circuit</suitkaise-api></code> (which applies backoff on trip), <code><suitkaise-api>BreakingCircuit</suitkaise-api></code> applies backoff on <code><suitkaise-api>reset</suitkaise-api>()</code>. This means the sleep time increases each time you reset and the circuit breaks again.</p>
    <pre><code class="language-python"><suitkaise-api>breaker</suitkaise-api> = <suitkaise-api>BreakingCircuit(</suitkaise-api>
    num_shorts_to_trip=3,
    sleep_time_after_trip=1.0,
    backoff_factor=2.0,
    max_sleep_time=30.0
)

# Break 1: sleeps 1.0s
# reset() → next sleep will be 2.0s
# Break 2: sleeps 2.0s
# reset() → next sleep will be 4.0s
# Break 3: sleeps 4.0s
# ...</code></pre>
    <hr>
    <h2>Thread Safety</h2>
    <p>Both <code><suitkaise-api>Circuit</suitkaise-api></code> and <code><suitkaise-api>BreakingCircuit</suitkaise-api></code> are thread-safe. All state access is protected by <code>threading.RLock</code>.</p>
    <pre><code class="language-python">import threading
from <suitkaise-api>suitkaise</suitkaise-api> import <suitkaise-api>Circuit</suitkaise-api>

<suitkaise-api>circuit</suitkaise-api> = <suitkaise-api>Circuit(</suitkaise-api>num_shorts_to_trip=5, sleep_time_after_trip=1.0)

def worker():
    for _ in range(100):
        try:
            process_item()
        except ItemError:
            <suitkaise-api>circuit.short()</suitkaise-api>  # safe from multiple threads

threads = [threading.Thread(target=worker) for _ in range(4)]
for t in threads:
    t.start()
for t in threads:
    t.join()</code></pre>
    <p>The sleep operation happens outside the lock, so other threads aren&#x27;t blocked while one thread sleeps.</p>
    <hr>
    <h2>Async Support</h2>
    <p>Both classes support async usage via <code>.<suitkaise-api>asynced</suitkaise-api>()</code>. The async versions use <code>asyncio.sleep()</code> instead of blocking <code>time.sleep()</code>.</p>
    <pre><code class="language-python"># sync
<suitkaise-api>circuit.short()</suitkaise-api>

# async
await <suitkaise-api>circuit.short</suitkaise-api>.<suitkaise-api>asynced</suitkaise-api>()()

# sync
<suitkaise-api>circuit.trip()</suitkaise-api>

# async
await <suitkaise-api>circuit.trip</suitkaise-api>.<suitkaise-api>asynced</suitkaise-api>()()</code></pre>
    <p>Methods that don&#x27;t sleep (<code><suitkaise-api>reset</suitkaise-api>()</code>, <code><suitkaise-api>reset_backoff</suitkaise-api>()</code>, property access) don&#x27;t need async versions.</p>
    <pre><code class="language-python">import asyncio
from <suitkaise-api>suitkaise</suitkaise-api> import <suitkaise-api>Circuit</suitkaise-api>

<suitkaise-api>circuit</suitkaise-api> = <suitkaise-api>Circuit(</suitkaise-api>
    num_shorts_to_trip=5,
    sleep_time_after_trip=2.0,
    backoff_factor=2.0,
    jitter=0.2
)

async def fetch(session, url):
    try:
        async with session.get(url) as response:
            if response.status == 429:
                await <suitkaise-api>circuit.short</suitkaise-api>.<suitkaise-api>asynced</suitkaise-api>()()
                return None
            return await response.json()
    except aiohttp.ClientError:
        await <suitkaise-api>circuit.short</suitkaise-api>.<suitkaise-api>asynced</suitkaise-api>()()
        return None</code></pre>
    <hr>
    <h2><code><suitkaise-api>Share</suitkaise-api></code> Integration</h2>
    <p>Both circuit classes include <code>_shared_meta</code> for integration with <code><suitkaise-api>suitkaise</suitkaise-api>.<suitkaise-api>processing</suitkaise-api>.<suitkaise-api>Share</suitkaise-api></code>. This enables cross-process circuit breaking.</p>
    <pre><code class="language-python">from <suitkaise-api>suitkaise</suitkaise-api>.<suitkaise-api>processing</suitkaise-api> import <suitkaise-api>Share</suitkaise-api>, <suitkaise-api>Pool</suitkaise-api>, <suitkaise-api>Skprocess</suitkaise-api>
from <suitkaise-api>suitkaise</suitkaise-api> import <suitkaise-api>BreakingCircuit</suitkaise-api>

<suitkaise-api>share</suitkaise-api> = <suitkaise-api>Share(</suitkaise-api>)
<suitkaise-api>share.circuit</suitkaise-api> = <suitkaise-api>BreakingCircuit(</suitkaise-api>num_shorts_to_trip=3, sleep_time_after_trip=1.0)

class Worker(<suitkaise-api>Skprocess</suitkaise-api>):
    def __init__(self, share):
        self.share = share

    def <suitkaise-api>__run__</suitkaise-api>(self):
        if self.share.<suitkaise-api>circuit.broken</suitkaise-api>:
            self.<suitkaise-api>stop</suitkaise-api>()
            return

        try:
            result = process_item()
        except FatalError:
            self.share.<suitkaise-api>circuit.short()</suitkaise-api>

<suitkaise-api>pool</suitkaise-api> = <suitkaise-api>Pool(</suitkaise-api>workers=4)
<suitkaise-api>pool.map(</suitkaise-api>Worker, [share] * 4)</code></pre>
    <p>When any process trips the circuit, all other processes see <code>share.<suitkaise-api>circuit.broken</suitkaise-api> == True</code> on their next check. This gives you cross-process coordinated failure handling with zero infrastructure.</p>
    <hr>
    <h2>Choosing Between <code><suitkaise-api>Circuit</suitkaise-api></code> and <code><suitkaise-api>BreakingCircuit</suitkaise-api></code></h2>
    <div class="benchmark-table-wrap">
        <table class="benchmark-table">
            <thead>
                <tr><th>Use Case</th><th>Class</th><th>Why</th></tr>
            </thead>
            <tbody>
                <tr><td>Rate limiting API calls</td><td><code><suitkaise-api>Circuit</suitkaise-api></code></td><td>Auto-resets after cooldown, keeps processing</td></tr>
                <tr><td>Retry with backoff</td><td><code><suitkaise-api>Circuit</suitkaise-api></code></td><td>Sleeps and continues automatically</td></tr>
                <tr><td>Stop after too many failures</td><td><code><suitkaise-api>BreakingCircuit</suitkaise-api></code></td><td>Stays broken, you decide what to do</td></tr>
                <tr><td>Coordinated worker shutdown</td><td><code><suitkaise-api>BreakingCircuit</suitkaise-api></code></td><td>One worker breaks it, all see it</td></tr>
                <tr><td>Graceful degradation</td><td>Both</td><td><code><suitkaise-api>Circuit</suitkaise-api></code> for primary, <code><suitkaise-api>BreakingCircuit</suitkaise-api></code> for fallback</td></tr>
            </tbody>
        </table>
    </div>
    <hr>
    <h2>Error Handling</h2>
    <p>Circuits don&#x27;t raise exceptions themselves. They sleep (<code>Circuit</code>) or set a flag (<code>BreakingCircuit</code>). You handle the logic:</p>
    <pre><code class="language-python"># Circuit: check the return value of short()
tripped = circuit.<suitkaise-api>short()</suitkaise-api>
if tripped:
    print("Circuit tripped, just paused")

# BreakingCircuit: check the broken property
breaker.<suitkaise-api>short()</suitkaise-api>
if <suitkaise-api>breaker.broken</suitkaise-api>:
    print("Circuit broken, stopping")</code></pre>
</section>
