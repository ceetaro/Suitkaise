<div class="module-bar" data-module="circuit">
    <button class="module-bar-title">suitkaise.circuit</button>
    <nav class="module-bar-nav">
        <a href="#circuit-why" class="module-bar-link" data-page="circuit-why">why</a>
        <a href="#circuit" class="module-bar-link" data-page="circuit">how to use</a>
        <a href="#circuit-how-it-works" class="module-bar-link active" data-page="circuit-how-it-works">how it works</a>
        <a href="#circuit-videos" class="module-bar-link" data-page="circuit-videos">videos</a>
        <a href="#circuit-tests" class="module-bar-link" data-page="circuit-tests">tests</a>
        <a href="#circuit-examples" class="module-bar-link" data-page="circuit-examples">examples</a>
    </nav>
</div>
<section class="module-page">
    <h1>How <code>circuit</code> actually works</h1>
    
    <p><code>circuit</code> has no dependencies outside of the standard library.</p>
    <p>It contains one class: <code>Circuit</code>.</p>

    <hr>

    <h2><code>Circuit</code> class</h2>

    <p>A "circuit breaker" that trips and can stop execution after a certain number of <code>short()</code> calls (failures), or immediately if you call <code>trip()</code>.</p>
    
    <p><strong>Initialize with:</strong></p>
    <ul>
        <li><code>num_shorts_to_trip</code>: Maximum number of shorts before the circuit trips (<code>int</code>)</li>
        <li><code>sleep_time_after_trip</code>: Sleep duration in seconds when circuit trips (<code>float</code>, default <code>0.0</code>)</li>
    </ul>

<pre><code class="language-python">from suitkaise.circuit import Circuit

# Create a circuit that trips after 5 shorts
breaker = Circuit(num_shorts_to_trip=5, sleep_time_after_trip=0.5)</code></pre>

    <h3><code>Circuit.__init__()</code></h3>
    <ol>
        <li>Stores <code>num_shorts_to_trip</code> as the threshold limit</li>
        <li>Stores <code>sleep_time_after_trip</code> as the default sleep duration</li>
        <li>Sets <code>broken</code> to <code>False</code> (circuit starts operational)</li>
        <li>Sets <code>times_shorted</code> to <code>0</code> (no failures yet)</li>
        <li>Sets <code>total_trips</code> to <code>0</code> (lifetime trip counter)</li>
        <li>Creates <code>_lock</code> as a <code>threading.RLock()</code> for thread safety</li>
    </ol>
    <p>The circuit is now ready to track failures.</p>

    <hr>

    <h2>Properties</h2>

    <h3><code>Circuit.broken</code></h3>
    <p>Boolean indicating whether the circuit has broken.</p>
    <ul>
        <li><code>False</code> — circuit is operational, loop should continue</li>
        <li><code>True</code> — circuit has broken, loop should exit</li>
    </ul>
    <p>Typical usage:</p>
<pre><code class="language-python"># while the circuit hasn't broken...
while not breaker.broken:
    # ... your loop logic ...</code></pre>

    <h3><code>Circuit.times_shorted</code></h3>
    <p>Integer counter tracking how many times <code>short()</code> has been called since last reset.</p>
    <p>Resets to <code>0</code> when the circuit trips or when <code>reset()</code> is called.</p>

    <h3><code>Circuit.total_trips</code></h3>
    <p>Integer counter tracking the total number of failures over the lifetime of the circuit.</p>
    <p>Incremented by:</p>
    <ul>
        <li>Each call to <code>short()</code></li>
        <li>Each call to <code>trip()</code></li>
    </ul>
    <p>Never resets — persists across <code>reset()</code> calls. Useful for monitoring overall failure rate.</p>

    <hr>

    <h2>Methods</h2>

    <h3><code>Circuit.short()</code></h3>
    <p>Increments the failure count and trips the circuit if the limit is reached.</p>
    <p><strong>Arguments:</strong></p>
    <ul>
        <li><code>custom_sleep</code>: Optional override for sleep duration if this short causes a trip (<code>float</code>)</li>
    </ul>
    <p><strong>Returns:</strong> <code>None</code></p>
    <ol>
        <li>Increments <code>times_shorted</code> by 1</li>
        <li>Increments <code>total_trips</code> by 1</li>
        <li>Checks if <code>times_shorted >= num_shorts_to_trip</code>:
            <ul>
                <li><strong>If True:</strong> Calls <code>_break_circuit()</code> with the sleep duration (uses <code>custom_sleep</code> if provided, otherwise uses <code>sleep_time_after_trip</code>)</li>
                <li><strong>If False:</strong> Does nothing (just counts the failure)</li>
            </ul>
        </li>
    </ol>

<pre><code class="language-python">breaker = circuit.Circuit(num_shorts_to_trip=3, sleep_time_after_trip=1.0)

breaker.short()  # times_shorted = 1, total_trips = 1, broken = False
breaker.short()  # times_shorted = 2, total_trips = 2, broken = False
breaker.short()  # times_shorted = 3 -> 0, total_trips = 3, broken = True, sleeps 1.0s</code></pre>

    <h3><code>Circuit.trip()</code></h3>
    <p>Immediately trips the circuit, bypassing short counting.</p>
    <p><strong>Arguments:</strong></p>
    <ul>
        <li><code>custom_sleep</code>: Optional override for sleep duration (<code>float</code>)</li>
    </ul>
    <p><strong>Returns:</strong> <code>None</code></p>
    <ol>
        <li>Increments <code>total_trips</code> by 1</li>
        <li>Calls <code>_break_circuit()</code> immediately</li>
        <li>Uses <code>custom_sleep</code> if provided, otherwise uses <code>sleep_time_after_trip</code></li>
    </ol>
    <p>This is useful when you want to force the circuit to trip regardless of the current short count. In circuit breaker terminology, when a breaker activates it "trips".</p>

<pre><code class="language-python">breaker = circuit.Circuit(num_shorts_to_trip=10, sleep_time_after_trip=0.5)

# Something catastrophic happened, trip immediately
if critical_failure:
    breaker.trip()  # broken = True, sleeps 0.5s</code></pre>

    <h3><code>Circuit.reset()</code></h3>
    <p>Resets the circuit to its initial operational state.</p>
    <p><strong>Arguments:</strong> None</p>
    <p><strong>Returns:</strong> <code>None</code></p>
    <ol>
        <li>Sets <code>broken</code> to <code>False</code></li>
        <li>Sets <code>times_shorted</code> to <code>0</code></li>
    </ol>
    <p>This allows you to reuse the same circuit after it has broken.</p>

<pre><code class="language-python">breaker = circuit.Circuit(num_shorts_to_trip=3, sleep_time_after_trip=1.0)

# First batch of operations
while not breaker.broken:
    try:
        risky_operation()
    except Error:
        breaker.short()

# Reset for next batch
breaker.reset()

# Second batch of operations (total_trips persists)
while not breaker.broken:
    # ...</code></pre>

    <hr>

    <h2>Internal Methods</h2>

    <h3><code>Circuit._break_circuit()</code></h3>
    <p>Internal method that handles the actual circuit tripping.</p>
    <p><strong>Arguments:</strong></p>
    <ul>
        <li><code>sleep_duration</code>: How long to sleep after tripping (<code>float</code>)</li>
    </ul>
    <p><strong>Returns:</strong> <code>None</code></p>
    <ol>
        <li>Sets <code>broken</code> to <code>True</code></li>
        <li>Resets <code>times_shorted</code> to <code>0</code></li>
        <li>If <code>sleep_duration > 0</code>: Calls <code>sktime.sleep(sleep_duration)</code></li>
    </ol>
    <p>The sleep gives downstream systems time to recover before the next attempt (if the circuit is reset).</p>

    <hr>

    <h2>State Transitions</h2>
    <p>The circuit has two states:</p>

    <h3>Running State (<code>broken = False</code>)</h3>
    <ul>
        <li>Loop continues running</li>
        <li><code>short()</code> increments counter</li>
        <li>Transitions to Broken when <code>times_shorted >= num_shorts_to_trip</code> or when <code>trip()</code> is called</li>
    </ul>

    <h3>Broken State (<code>broken = True</code>)</h3>
    <ul>
        <li>Loop should exit</li>
        <li>Counter is reset to 0</li>
        <li>Transitions back to Running via <code>reset()</code></li>
    </ul>

    <hr>

    <p>When the circuit breaks, <code>times_shorted</code> is reset to 0.</p>
    <p>Use <code>total_trips</code> to track lifetime trips across resets.</p>

    <hr>

    <h2>Sleep Behavior</h2>
    <p>By default, <code>sleep_time_after_trip=0</code> (no sleep). Set it if you want a cooldown:</p>

<pre><code class="language-python">breaker = circuit.Circuit(num_shorts_to_trip=5, sleep_time_after_trip=1.0)  # Sleeps 1s on trip</code></pre>

    <p>The <code>custom_sleep</code> parameter on <code>short()</code> and <code>trip()</code> allows per-call overrides:</p>

<pre><code class="language-python">breaker = circuit.Circuit(num_shorts_to_trip=3, sleep_time_after_trip=1.0)

# Normal failure
breaker.short()  # Would sleep 1.0s if this trips

# Critical failure with longer cooldown
breaker.short(custom_sleep=5.0)  # Would sleep 5.0s if this trips</code></pre>

    <hr>

    <h2>Thread Safety</h2>
    <p><code>Circuit</code> is thread-safe. All property access and state modifications are protected by an internal <code>threading.RLock()</code>.</p>
    <p>You can safely use a single <code>Circuit</code> instance across multiple threads:</p>

<pre><code class="language-python">import threading
from suitkaise import circuit

breaker = circuit.Circuit(num_shorts_to_trip=5)

def worker():
    while not breaker.broken:  # Thread-safe read
        try:
            do_work()
        except Error:
            breaker.short()  # Thread-safe modification

# Multiple threads can share the same breaker
threads = [threading.Thread(target=worker) for _ in range(4)]
for t in threads:
    t.start()
for t in threads:
    t.join()</code></pre>

    <details>
        <summary>What is a reentrant lock?</summary>
        <div class="dropdown-content">
            <p>A reentrant lock is a lock that can be acquired by the same thread multiple times without deadlocking.</p>
            <p>This is useful for thread safety, as it allows the same thread to acquire the lock multiple times from different code or methods.</p>
        </div>
    </details>

    <hr>

    <h2>Error Handling</h2>
    <p>The <code>Circuit</code> class does not raise exceptions. All methods are safe to call:</p>
    <ul>
        <li><code>short()</code> — never raises</li>
        <li><code>trip()</code> — never raises</li>
        <li><code>reset()</code> — never raises</li>
    </ul>
    <p>The only potential exception is from <code>sktime.sleep()</code> if interrupted, which would propagate normally.</p>

    <hr>

    <h2>Memory</h2>
    <p>Each <code>Circuit</code> instance stores 6 values:</p>
    <ul>
        <li><code>num_shorts_to_trip</code> (int) — ~28 bytes</li>
        <li><code>sleep_time_after_trip</code> (float) — ~24 bytes</li>
        <li><code>_broken</code> (bool) — ~28 bytes</li>
        <li><code>_times_shorted</code> (int) — ~28 bytes</li>
        <li><code>_total_trips</code> (int) — ~28 bytes</li>
        <li><code>_lock</code> (RLock) — ~56 bytes</li>
    </ul>
    <p>Total: ~192 bytes per instance. (very lightweight)</p>

</section>
