<div class="module-bar" data-module="circuits">
    <button class="module-bar-title">suitkaise.circuits</button>
    <nav class="module-bar-nav">
        <a href="#circuits-why" class="module-bar-link" data-page="circuits-why">why</a>
        <a href="#circuits-quick-start" class="module-bar-link active" data-page="circuits-quick-start">quick start</a>
        <a href="#circuits" class="module-bar-link" data-page="circuits">how to use</a>
        <a href="#circuits-how-it-works" class="module-bar-link" data-page="circuits-how-it-works">how it works</a>
        <a href="#circuits-examples" class="module-bar-link" data-page="circuits-examples">examples</a>
        <a href="#circuits-videos" class="module-bar-link" data-page="circuits-videos">videos</a>
        <a href="#circuits-learn" class="module-bar-link" data-page="circuits-learn">learn</a>
    </nav>
</div>
<section class="module-page">
    <h1><code><suitkaise-api>circuits</suitkaise-api></code> quick start guide</h1>
    <pre><code class="language-bash">pip install <suitkaise-api>suitkaise</suitkaise-api></code></pre>
    <h2>Auto-resetting circuit (<code><suitkaise-api>Circuit</suitkaise-api></code>)</h2>
    <p>Sleeps after N failures, then resets and continues.</p>
    <pre><code class="language-python">from <suitkaise-api>suitkaise</suitkaise-api> import <suitkaise-api>Circuit</suitkaise-api>

<suitkaise-api>circuit</suitkaise-api> = <suitkaise-api>Circuit(</suitkaise-api>num_shorts_to_trip=5, sleep_time_after_trip=1.0<suitkaise-api>)</suitkaise-api>

for request in incoming_requests:
    try:
        process(request)
    except ServiceError:
        <suitkaise-api>circuit.short()</suitkaise-api>  # after 5 failures, sleeps 1s, then resets</code></pre>
    <h2>Breaking circuit (<code><suitkaise-api>BreakingCircuit</suitkaise-api></code>)</h2>
    <p>Stays broken after N failures until you manually reset.</p>
    <pre><code class="language-python">from <suitkaise-api>suitkaise</suitkaise-api> import <suitkaise-api>BreakingCircuit</suitkaise-api>

<suitkaise-api>breaker</suitkaise-api> = <suitkaise-api>BreakingCircuit(</suitkaise-api>num_shorts_to_trip=3, sleep_time_after_trip=1.0<suitkaise-api>)</suitkaise-api>

while not <suitkaise-api>breaker.broken</suitkaise-api>:
    try:
        <suitkaise-api>result</suitkaise-api> = risky_operation()
        break
    except OperationError:
        <suitkaise-api>breaker.short()</suitkaise-api>

if <suitkaise-api>breaker.broken</suitkaise-api>:
    handle_failure()
    <suitkaise-api>breaker.reset()</suitkaise-api>  # manually reset when ready</code></pre>
    <h2>Exponential backoff (with jitter and max sleep time)</h2>
    <pre><code class="language-python"><suitkaise-api>circuit</suitkaise-api> = <suitkaise-api>Circuit(</suitkaise-api>
    num_shorts_to_trip=5,
    sleep_time_after_trip=1.0,
    backoff_factor=2.0,    # double sleep time after each trip
    max_sleep_time=30.0    # cap at 30 seconds
<suitkaise-api>)</suitkaise-api>
# Trip 1: 1s, Trip 2: 2s, Trip 3: 4s, Trip 4: 8s, ...</code></pre>
    <h2>Jitter (randomness to prevent thundering herd)</h2>
    <pre><code class="language-python"><suitkaise-api>circuit</suitkaise-api> = <suitkaise-api>Circuit(</suitkaise-api>
    num_shorts_to_trip=5,
    sleep_time_after_trip=5.0,
    jitter=0.2  # ±20% randomness to prevent thundering herd
<suitkaise-api>)</suitkaise-api></code></pre>
    <h2>Immediate trip (bypass the counter)</h2>
    <pre><code class="language-python">try:
    <suitkaise-api>result</suitkaise-api> = call_service()
except CriticalError:
    <suitkaise-api>circuit.trip()</suitkaise-api>  # skip the counter, trip immediately
except MinorError:
    <suitkaise-api>circuit.short()</suitkaise-api>  # count normally</code></pre>
    <h2>Async support (native async support)</h2>
    <pre><code class="language-python"># sync
<suitkaise-api>circuit.short()</suitkaise-api>

# async — .asynced() returns the async version, second () calls it
await <suitkaise-api>circuit.short.asynced()()</suitkaise-api>

# equivalent to:
<suitkaise-api>async_short</suitkaise-api> = <suitkaise-api>circuit.short.asynced()</suitkaise-api>
await <suitkaise-api>async_short()</suitkaise-api></code></pre>
    <h2>Check state (get the current state of the circuit)</h2>
    <pre><code class="language-python"><suitkaise-api>circuit.times_shorted</suitkaise-api>       # failures since last trip
<suitkaise-api>circuit.total_trips</suitkaise-api>         # lifetime trip count
<suitkaise-api>circuit.current_sleep_time</suitkaise-api>  # current backoff delay

<suitkaise-api>breaker.broken</suitkaise-api>              # is it broken?</code></pre>
    <h2>Reset backoff after success</h2>
    <pre><code class="language-python"><suitkaise-api>circuit</suitkaise-api> = <suitkaise-api>Circuit(</suitkaise-api>
    num_shorts_to_trip=3,
    sleep_time_after_trip=1.0,
    backoff_factor=2.0,
    max_sleep_time=60.0
<suitkaise-api>)</suitkaise-api>

for batch in get_batches():
    try:
        result = process_batch(batch)
        <suitkaise-api>circuit.reset_backoff()</suitkaise-api>  # success! next failure starts at 1s, not wherever backoff left off
    except BatchError:
        <suitkaise-api>circuit.short()</suitkaise-api></code></pre>
    <h2>Want to learn more?</h2>
    <ul>
        <li><strong>Why page</strong> — why <code><suitkaise-api>circuits</suitkaise-api></code> exists, coordinated shutdown, and cross-process circuit breaking</li>
        <li><strong>How to use</strong> — full API reference for <code><suitkaise-api>Circuit</suitkaise-api></code> and <code><suitkaise-api>BreakingCircuit</suitkaise-api></code></li>
        <li><strong>Examples</strong> — progressively complex examples into a full script</li>
        <li><strong>How it works</strong> — internal architecture (locks, backoff, <code><suitkaise-api>Share</suitkaise-api></code> integration) (level: beginner-intermediate)</li>
    </ul>
</section>
