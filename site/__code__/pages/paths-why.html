<div class="module-bar" data-module="paths">
    <button class="module-bar-title">suitkaise.paths</button>
    <nav class="module-bar-nav">
        <a href="#paths-why" class="module-bar-link active" data-page="paths-why">why</a>
        <a href="#paths-quick-start" class="module-bar-link" data-page="paths-quick-start">quick start</a>
        <a href="#paths" class="module-bar-link" data-page="paths">how to use</a>
        <a href="#paths-how-it-works" class="module-bar-link" data-page="paths-how-it-works">how it works</a>
        <a href="#paths-examples" class="module-bar-link" data-page="paths-examples">examples</a>
        <a href="#paths-videos" class="module-bar-link" data-page="paths-videos">videos</a>
        <a href="#paths-tests" class="module-bar-link" data-page="paths-tests">tests</a>
        <a href="#paths-learn" class="module-bar-link" data-page="paths-learn">learn</a>
    </nav>
</div>
<section class="module-page why-page">
    <h1>Why you would use <code>paths</code></h1>
    <h2>TLDR</h2>
    <p><code>paths</code> exists because path handling in Python is:</p>
    <ol>
        <li><strong>Inconsistent</strong> — <code>\</code> vs <code>/</code>, absolute vs relative, string vs Path</li>
        <li><strong>Manual</strong> — find root, resolve, normalize, convert, repeat</li>
        <li><strong>Error-prone</strong> — works on your machine, breaks on theirs</li>
        <li><strong>Tedious</strong> — same boilerplate in every project</li>
    </ol>
    <p><code>paths</code> makes it:</p>
    <ol>
        <li><strong>Consistent</strong> — normalized slashes, project-relative paths, cross-platform by default</li>
        <li><strong>Automatic</strong> — root detection, type conversion, caller detection</li>
        <li><strong>Reliable</strong> — same <code>rp</code> on every machine, every OS</li>
        <li><strong>Simple</strong> — one line instead of thirteen</li>
    </ol>
    <p>Stop fighting with paths. Start using them.</p>
    <hr>
    <p>File paths are a pain to work with.</p>
    <p>Sometimes pure hell, even.</p>
    <p>I got gutted the moment I started trying to write cross-platform code. Slashes going the wrong way, paths breaking when my teammate ran the same script, logs full of absolute paths that meant nothing on another machine. Well shit, man. Whoops.</p>
    <p>Find the project root, resolve the path, make it relative, normalize the slashes, cast it to a string, pass it in. Over and over. Just to achieve simple cross-platform compatibility.</p>
    <p>I don&#x27;t want to inspect the stack to find the caller path.</p>
    <p>I don&#x27;t want to <code>.resolve()</code> every single path.</p>
    <p>I just want path handling to be easy, consistent, and have some basic level of standardization.</p>
    <p>So I made <code>paths</code>.</p>
    <h3>Drop-in upgrade from <code>pathlib</code></h3>
    <p><code>Skpath</code> wraps <code>pathlib.Path</code>. Everything <code>pathlib.Path</code> does, <code>Skpath</code> does too -- same methods, same interface, same behavior. You don&#x27;t have to relearn anything.</p>
    <p>What <code>Skpath</code> adds on top:</p>
    <ul>
        <li>project-relative paths (<code>rp</code>) that are identical on every machine and OS</li>
        <li>automatic project root detection</li>
        <li>platform-aware absolute paths</li>
        <li>reversible path IDs for database storage</li>
    </ul>
    <p>If you already use <code>pathlib</code>, switching to <code>Skpath</code> is a one-word change in your imports with zero risk of breaking existing code.</p>
    <h3>Automatic path detection — <code>Skpath()</code> with no arguments</h3>
    <p>Need to know the path of the current file? Don&#x27;t inspect the stack yourself.</p>
    <pre><code class="language-python"># get the current file&#x27;s path as an Skpath, automatically
here = Skpath()</code></pre>
    <p>That&#x27;s it. <code>Skpath()</code> with no arguments detects the caller&#x27;s file path. Works in scripts, modules, notebooks, and test runners.</p>
    <h2><code>Skpath</code> paths</h2>
    <p>Every <code>Skpath</code> stores three paths:</p>
    <ul>
        <li><code>ap</code> — absolute path, always forward slashes (<code>/Users/me/project/data/file.txt</code>)</li>
        <li><code>rp</code> — normalized path relative to project root (<code>data/file.txt</code>)</li>
        <li><code>platform</code> — absolute path with the correct separators for the current platform</li>
    </ul>
    <p><code>rp</code> is the same on every machine, every OS, as long as the project structure is the same. Which it should be! Make sure to pull guys! Haha! Resolve those merge conflicts!</p>
    <p>On a serious note, this changes everything -- and is a huge jump in path standardization.</p>
    <h2><code>@autopath</code> — make any function path-safe</h2>
    <p>The fastest way to make your codebase cross-platform: slap <code>@autopath()</code> on any function that takes paths.</p>
    <pre><code class="language-python">from suitkaise.paths import autopath, AnyPath

@autopath()
def process_file(path: AnyPath):
    # path is now an Skpath, regardless of what was passed in
    # str, Path, or Skpath -- all converted automatically
    print(path.rp)  # always cross-platform</code></pre>
    <p>Pass a <code>str</code>, a <code>Path</code>, or an <code>Skpath</code> -- <code>@autopath()</code> reads the type annotation and converts it for you. Your function just works, no matter what the caller gives it.</p>
    <p>Combined with <code>AnyPath</code> (a union of <code>str</code>, <code>Path</code>, and <code>Skpath</code>), you can upgrade your entire codebase to use <code>Skpath</code> incrementally without breaking anything that already passes strings or Paths.</p>
    <p>This is the &quot;pit of success&quot; -- once <code>@autopath()</code> is on a function, it&#x27;s impossible to accidentally use a platform-specific path inside it.</p>
    <h2>What about just using <code>pathlib</code>?</h2>
    <p><code>pathlib</code> is great. It handles slash differences internally and gives you a nice object to work with.</p>
    <p>But it doesn&#x27;t know about your project. It doesn&#x27;t auto-detect the root. It doesn&#x27;t give you a consistent path that works everywhere. And it doesn&#x27;t convert types for you.</p>
    <p><code>Skpath</code> wraps <code>pathlib.Path</code> and adds project awareness, so you don&#x27;t have to make it aware of things yourself.</p>
    <p>The <code>paths</code> module also adds a bunch of cool things like <code>@autopath</code> and <code>AnyPath</code> to help you in your quest to make paths easy and standardized for your entire team.</p>
    <p><code>pathlib.Path</code> handles cross-platform normalization internally, but the moment you convert to a string (for logging, storing, or passing to a library), you&#x27;re back to platform-specific slashes. What&#x27;s the point?</p>
    <pre><code class="language-python">path = Path(&quot;config/settings.yaml&quot;)
str(path)

# &quot;config/settings.yaml&quot; on Mac, &quot;config\\settings.yaml&quot; on Windows</code></pre>
    <p>Here is a set of problems that <code>paths</code> solves.</p>
    <details>
        <summary>1. <code>\</code> vs <code>/</code></summary>
        <div class="dropdown-content">
    <p>Windows uses <code>\</code>, everything else uses <code>/</code>.</p>
    <p>While most developers use Mac with Python (it runs better), users will be using your code on both Mac and Windows. So you need to support both.</p>
    <p>So, you write code on a Mac, push it, and your teammate on Windows gets broken paths.</p>
    <pre><code class="language-python"># You write this on Mac
config_path = &quot;config/settings.yaml&quot;

# Works fine on Mac
open(config_path)  # ✓

# Your teammate on Windows logs the resolved path
print(Path(config_path).resolve())

# C:\Users\teammate\project\config\settings.yaml

# Later, that path gets stored or compared somewhere
# Now you have mixed slashes in your system</code></pre>
    <p>With <code>Skpath</code></p>
    <pre><code class="language-python">path = Skpath(&quot;config/settings.yaml&quot;)

path.ap  # Always forward slashes: &quot;/Users/me/project/config/settings.yaml&quot;

path.rp  # Always forward slashes: &quot;config/settings.yaml&quot;

path.platform  # platform specific

str(path)  # Always forward slashes (same as ap)</code></pre>
    <p>Need to pass a path to a Windows-specific tool or open a file? Use <code>path.platform</code>. Want to log or store paths consistently? Use <code>path.rp</code> (or <code>path.ap</code>).</p>
    <p><code>Skpath</code> normalizes to forward slashes everywhere, except for <code>platform</code>, which you would want to use for OS-specific operations.</p>
        </div>
    </details>
    <details>
        <summary>2. Relative paths</summary>
        <div class="dropdown-content">
    <p>Writing out the full path to a file sucks.</p>
    <p>But relative paths are inconsistent and unclear.</p>
    <p>Is the <code>data/file.txt</code> path relative to the root? The cwd? What if there are multiple files of the same name under different <code>/data</code> directories?</p>
    <p>So, you have to do something like this every time.</p>
    <pre><code class="language-python">path = Path(&quot;data/file.txt&quot;)
path = path.resolve()
path = str(path)</code></pre>
    <p>You could do it in one long line if you want, I guess.</p>
    <pre><code class="language-python">path = str(Path(&quot;data/file.txt&quot;).resolve())</code></pre>
    <p>With <code>Skpath</code>, you just create it and it&#x27;s ready to use cross-platform.</p>
    <pre><code class="language-python">path = Skpath(&quot;data/file.txt&quot;)</code></pre>
    <p>So much cleaner, so much simpler.</p>
    <p><code>Skpath</code>s are awesome because they actually store 3 paths.</p>
    <ul>
        <li>stores absolute path</li>
        <li>also auto detects the project root and stores the path relative to it</li>
        <li>stores platform specific separator absolute path</li>
    </ul>
    <p><code>Skpath</code>s are automatically cross-platform compatible.</p>
    <p>When you work with <code>Skpath</code> objects across machines or even operating systems, as long as the project root is the same, the paths will work the same.</p>
    <p>So now you can just <code>Skpath</code> everything and not have to worry about platform issues, or having to manually relate paths to the root.</p>
    <p>No more &quot;relative path&quot; confusion. Everything is project root based.</p>
        </div>
    </details>
    <details>
        <summary>3. Project root related issues</summary>
        <div class="dropdown-content">
    <p>Finding the project root recursively is not standardized at all.</p>
    <p>Also a drag to do.</p>
    <p>Each dev does it slightly differently, and there are inconsistencies.</p>
    <p>You end up having to copy paste something like this every time:</p>
    <pre><code class="language-python">def find_project_root():
    current = Path(__file__).resolve().parent
    while current != current.parent:
        if (current / &quot;pyproject.toml&quot;).exists():
            return current
        if (current / &quot;.git&quot;).exists():
            return current
        current = current.parent
    raise RuntimeError(&quot;Could not find project root&quot;)

PROJECT_ROOT = find_project_root()</code></pre>
    <p>Which is cloudy and relies on exact indicators.</p>
    <p>With <code>Skpath</code>, you can just do this:</p>
    <pre><code class="language-python"># 1 line into Skpath
PROJECT_ROOT = Skpath().root</code></pre>
    <p>Or this:</p>
    <pre><code class="language-python"># 1 line into Path
PROJECT_ROOT = Skpath().root_path</code></pre>
    <p>Or this:</p>
    <pre><code class="language-python"># 1 line into str
PROJECT_ROOT = Skpath().root_str</code></pre>
    <p>Or this:</p>
    <pre><code class="language-python"># 1 line into Skpath
PROJECT_ROOT = paths.get_project_root()</code></pre>
    <p>With <code>paths</code> you can also use different roots quickly and easily.</p>
    <ul>
        <li>you can add a <code>setup.sk</code> file to your project root to guarantee detection (it will look for things like <code>setup.py</code> even if you don&#x27;t do this, but it will look for this first)</li>
        <li>you can use <code>set_custom_root</code> to set a custom root that all <code>Skpath</code> objects will use</li>
        <li>you can use the <code>CustomRoot</code> context manager to temporarily set a custom root for a code block for things like testing</li>
    </ul>
    <p>Note that <code>Skpath</code>s are created with the project root they were given, so either use a custom root or don&#x27;t.</p>
        </div>
    </details>
    <details>
        <summary>4. Figuring out if you need to use a <code>Path</code> or a <code>str</code></summary>
        <div class="dropdown-content">
    <p>Even if you are in an IDE/code editor, figuring out what type of path you need to use for what function across a whole project base is frustrating.</p>
    <p>You have to make everyone use either <code>Path</code> or <code>str</code>, or let everyone code how they want and then hover over every function using paths to see the expected types.</p>
    <p><code>@autopath</code> does this for you.</p>
    <pre><code class="language-python">@autopath()
def function_that_uses_strs(path: str, ...):

    # changes all Paths to strings for you before passing them in</code></pre>
    <pre><code class="language-python">@autopath()
def function_that_uses_paths(path: Path, ...):

    # changes all strings to Paths for you before passing them in</code></pre>
    <p>All you have to do is slap <code>@autopath()</code> on the function and it will automatically convert the paths to the types that you expect, and automatically normalize them through <code>Skpath</code> as well, guaranteeing cross-platform compatibility.</p>
    <p>There is also another way to do this: the <code>AnyPath</code> type.</p>
    <p><code>AnyPath</code> is a union of <code>str</code>, <code>Path</code>, and <code>Skpath</code>.</p>
    <p>This allows you to quickly update your code to use the superior <code>Skpath</code> type, while not breaking previous code.</p>
    <pre><code class="language-python">from suitkaise.paths import AnyPath

def function_that_uses_any_paths(path: AnyPath, ...):

    # allows you to accept all 3 path types 
    # without having to create unions every time</code></pre>
    <p>And when you combine them...</p>
    <pre><code class="language-python">from suitkaise.paths import autopath, AnyPath

@autopath()
def function_that_uses_any_paths(path: AnyPath, ...):

    # automatically converts strs and Paths to Skpaths for you
    # gives you access to the more awesome Skpath quickly</code></pre>
    <p>I do a lot of solo coding, and even I was having trouble standardizing path code! When working in a team, don&#x27;t even get me started.</p>
    <p>This is a game changer.</p>
        </div>
    </details>
    <details>
        <summary>5. Comparing paths</summary>
        <div class="dropdown-content">
    <p>Say you&#x27;re writing a script that processes files and saves which ones are done to a log file, so you can skip them on future runs.</p>
    <pre><code class="language-python">from pathlib import Path
import json

LOG_FILE = &quot;processed_files.json&quot;

def load_processed():
    if Path(LOG_FILE).exists():
        return set(json.load(open(LOG_FILE)))
    return set()

def save_processed(processed):
    json.dump(list(processed), open(LOG_FILE, &quot;w&quot;))

def process_file(path, processed):
    path_str = str(Path(path).resolve())
    if path_str in processed:
        print(f&quot;Skipping {path}, already processed&quot;)
        return

    # ... do the actual processing ...

    processed.add(path_str)
    save_processed(processed)</code></pre>
    <p>Murphy runs the script on his Mac:</p>
    <pre><code class="language-python">processed = load_processed()
process_file(&quot;data/report.csv&quot;, processed)</code></pre>
    <p>The log file now contains:</p>
    <pre><code class="language-json">[&quot;/Users/murphy/projects/myapp/data/report.csv&quot;]</code></pre>
    <p>Gurphy pulls the latest changes and runs the same script on his Windows machine:</p>
    <pre><code class="language-python">processed = load_processed()
process_file(&quot;data/report.csv&quot;, processed)</code></pre>
    <p>His resolved path is <code>C:\Users\gurphy\projects\myapp\data\report.csv</code>, which doesn&#x27;t match Murphy&#x27;s path in the log.</p>
    <p>The same file gets processed twice because absolute paths don&#x27;t match across machines or operating systems.</p>
    <p>You could try to fix this by storing paths relative to the project root:</p>
    <pre><code class="language-python">def process_file(path, processed):
    path_resolved = Path(path).resolve()
    path_relative = str(path_resolved.relative_to(PROJECT_ROOT))
    if path_relative in processed:
        # ...</code></pre>
    <p>But now you need to find <code>PROJECT_ROOT</code> consistently and correctly, and fix the separators to be consistent.</p>
    <p>The funniest thing here is that the log file might not even load in the first place because the paths are different.</p>
    <p>With <code>paths</code></p>
    <pre><code class="language-python">from suitkaise.paths import Skpath, autopath
import json

LOG_FILE = &quot;processed_files.json&quot;

@autopath()
def process_file(path: Skpath, processed: set[Skpath]):

    if path.rp in processed:
        print(f&quot;Skipping {path.rp}, already processed&quot;)
        return
    
    # ... do the actual processing ...
    
    processed.add(path.rp)
    save_processed(processed)</code></pre>
    <p>The log file now contains:</p>
    <pre><code class="language-json">[&quot;data/report.csv&quot;]</code></pre>
    <p>Same on Murphy&#x27;s Macbook. Same on Gurphy&#x27;s Windows PC. Same on Furphy&#x27;s Linux desktop.</p>
        </div>
    </details>
    <details>
        <summary>6. General path handling is still so manual</summary>
        <div class="dropdown-content">
    <p>General path handling is still so manual and error prone.</p>
    <p>You have to normalize paths, resolve them, convert to strings, and more.</p>
    <p>Sometimes you need to know which file called your function -- for logging, for relative path resolution, for debugging.</p>
    <p>Without <code>paths</code> - <em>13 lines</em></p>
    <pre><code class="language-python">import inspect # 1
from pathlib import Path # 2

def get_caller_file(): # 3
    stack = inspect.stack() # 4
    
    for frame in stack[1:]: # 5
        filename = frame.filename # 6
        
        # Skip built-in/frozen modules # 7
        if filename.startswith(&quot;&lt;&quot;): # 8
            continue # 9

        more_filtering_logic() # 10
        
        return Path(filename).resolve() # 11
    
    raise RuntimeError(&quot;Could not detect caller&quot;) # 12

caller = get_caller_file() # 13</code></pre>
    <p>And this doesn&#x27;t even handle edge cases like notebook environments, compiled code, or filtering out your own library&#x27;s frames.</p>
    <p>With <code>paths</code> - <em>1 line</em></p>
    <pre><code class="language-python">caller = Skpath()</code></pre>
    <p>Or this:</p>
    <pre><code class="language-python">caller = get_caller_path()</code></pre>
    <p>Or this:</p>
    <pre><code class="language-python">@autopath(use_caller=True) # 1
def function_that_uses_caller_path(path: Skpath):

    # path will be the caller&#x27;s file path if not explicitly provided</code></pre>
        </div>
    </details>
    <details>
        <summary>7. Path IDs for storage</summary>
        <div class="dropdown-content">
    <p>Storing file paths in a database is a nightmare.</p>
    <p>Absolute paths are different on every machine. Relative paths need context. Backslashes break JSON. Forward slashes break some Windows tools.</p>
    <p>What if you could store a single, URL-safe string that reconstructs the original path? And have it take up less space than the full path?</p>
    <pre><code class="language-python">path = Skpath(&quot;data/reports/2024/q1.csv&quot;)

# get a reversible, URL-safe ID
path_id = path.id
# &quot;ZGF0YS9yZXBvcnRzLzIwMjQvcTEuY3N2&quot;

# store it in your database, pass it in URLs, use it as a cache key
db.execute(&quot;INSERT INTO files (path_id, ...) VALUES (?, ...)&quot;, (path_id, ...))

# later, reconstruct the full path from the ID
same_path = Skpath(path_id)
print(same_path.rp)
# &quot;data/reports/2024/q1.csv&quot;</code></pre>
    <p>The ID is:</p>
    <ul>
        <li>Base64url encoded (URL-safe, no weird characters)</li>
        <li>Reversible (you can always get the original path back)</li>
        <li>Cross-platform (uses the normalized <code>rp</code>, not the absolute path)</li>
        <li>Compact (shorter than most full paths)</li>
    </ul>
    <p>Perfect for databases, APIs, cache keys, and anywhere you need to reference a file without storing a full path.</p>
        </div>
    </details>
    <details>
        <summary>8. Finding where code lives</summary>
        <div class="dropdown-content">
    <p>Ever needed to know where a module or class is actually defined?</p>
    <pre><code class="language-python">import json

# where is the json module?
json.__file__
# might be None for built-in modules

# what about a class from a third-party library?
from requests import Session
# ... now what?</code></pre>
    <p>With <code>paths</code>:</p>
    <pre><code class="language-python">from suitkaise import paths
import json
from requests import Session

# get the file path for any module, class, or function
json_path = paths.get_module_path(json)
print(json_path.ap)
# &quot;/usr/lib/python3.11/json/__init__.py&quot;

session_path = paths.get_module_path(Session)
print(session_path.ap)
# &quot;/home/user/.venv/lib/python3.11/site-packages/requests/sessions.py&quot;

# works with your own code too
from myapp.utils import MyHelper
my_path = paths.get_module_path(MyHelper)
print(my_path.rp)
# &quot;myapp/utils.py&quot;</code></pre>
    <p>Useful for debugging, documentation generation, or even if you are just curious about where a module is actually defined.</p>
        </div>
    </details>
    <details>
        <summary>9. Project structure at a glance</summary>
        <div class="dropdown-content">
    <p>Need to see what&#x27;s in your project? Generate a file list? Create documentation?</p>
    <pre><code class="language-python">from suitkaise import paths

# get all files in your project (respects .gitignore automatically)
all_files = paths.get_project_paths()
py_files = [f for f in all_files if f.suffix == &quot;.py&quot;]
print(f&quot;Found {len(py_files)} Python files&quot;)

# get a nested dictionary structure
structure = paths.get_project_structure()
# {
#     &quot;src&quot;: {
#         &quot;main.py&quot;: {},
#         &quot;utils&quot;: {
#             &quot;helpers.py&quot;: {},
#             &quot;config.py&quot;: {}
#         }
#     },
#     &quot;tests&quot;: {...}
# }

# or a nice tree string for documentation
tree = paths.get_formatted_project_tree(depth=2)
print(tree)
# myproject/
# ├── src/
# │   ├── main.py
# │   └── utils/
# └── tests/
#     └── test_main.py</code></pre>
    <p>All of these respect <code>.gitignore</code> by default, so you don&#x27;t get flooded with <code>node_modules</code> or <code>.venv</code> files.</p>
        </div>
    </details>
    <details>
        <summary>10. Filename validation and sanitization</summary>
        <div class="dropdown-content">
    <p>User uploads a file called <code>&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;.txt</code>. Or <code>CON.txt</code> (reserved on Windows). Or <code>файл с пробелами.txt</code> (Cyrillic with spaces).</p>
    <p>Now what?</p>
    <pre><code class="language-python">from suitkaise.paths import is_valid_filename, streamline_path, streamline_path_quick

# check if a filename is valid on all platforms
is_valid_filename(&quot;report.pdf&quot;)           # True
is_valid_filename(&quot;file&lt;name&gt;.txt&quot;)       # False - contains &lt; and &gt;
is_valid_filename(&quot;CON&quot;)                  # False - Windows reserved name
is_valid_filename(&quot;file\twith\ttabs.txt&quot;) # False - contains tabs

# sanitize a filename to be safe everywhere
clean = streamline_path_quick(&quot;My Report (Final) — версия 2.pdf&quot;)
# &quot;My_Report__Final______2.pdf&quot;

# more control over sanitization
clean = streamline_path(
    &quot;User Upload: &lt;script&gt;.txt&quot;,
    replacement_char=&quot;-&quot;,
    lowercase=True,
    max_len=20
)
# &quot;user-upload---script.txt&quot;</code></pre>
    <p>Never trust user input. Sanitize everything. <code>paths</code> makes it easy.</p>
        </div>
    </details>
    <details>
        <summary>11. Temporary root override for testing</summary>
        <div class="dropdown-content">
    <p>Testing code that uses project paths is annoying. Your tests run from a different directory, your CI runs from yet another place.</p>
    <pre><code class="language-python">from suitkaise.paths import CustomRoot, Skpath

# in your test file
def test_config_loading():
    # temporarily set a custom root for this test
    with CustomRoot(&quot;/tmp/test_project&quot;):
        # all Skpath operations now use /tmp/test_project as root
        config = Skpath(&quot;config/settings.yaml&quot;)
        assert config.root_str == &quot;/tmp/test_project&quot;
        
        # your code that depends on project root works correctly
        result = load_config()
        assert result[&quot;setting&quot;] == &quot;test_value&quot;
    
    # outside the block, normal root detection resumes</code></pre>
    <p>No more patching, no more environment variables, no more test fixtures that set up fake directory structures.</p>
        </div>
    </details>
    <details>
        <summary>12. Using paths as dict keys or in sets</summary>
        <div class="dropdown-content">
    <p>You want to track which files you&#x27;ve seen. Simple, right?</p>
    <p>Without <code>paths</code> - <em>8 lines</em></p>
    <pre><code class="language-python">from pathlib import Path # 1

seen = set() # 2

def mark_seen(path: str):

    # Normalize to avoid duplicates
    normalized = Path(path) # 3
    normalized = normalized.resolve() # 4
    normalized = str(normalized) # 5
    seen.add(normalized)

def is_seen(path: str):
    normalized = Path(path) # 6
    normalized = normalized.resolve() # 7
    normalized = str(normalized) # 8
    return normalized in seen

# this STILL might mess up and have duplicate paths
len(seen)</code></pre>
    <p>You have to manually normalize every time you add or check. And if you forget once, you get duplicates or missed lookups.</p>
    <p>With <code>paths</code></p>
    <pre><code class="language-python">from suitkaise import paths # 1

seen = set() # 2

@paths.autopath() # 3
def mark_seen(path: paths.AnyPath):
    seen.add(path)

@paths.autopath() # 4
def is_seen(path: paths.AnyPath):
    return path in seen

len(seen) # no duplicates</code></pre>
    <p><code>Skpath</code> objects hash and compare using their normalized path (<code>rp</code>), so different representations of the same file are recognized as equal.</p>
    <p>Works in sets, works as dict keys, no extra effort.</p>
        </div>
    </details>
</section>
